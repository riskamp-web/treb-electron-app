/*! v10.12.11. Copyright 2018-2021 Structured Data, LLC. All rights reserved. CC BY-ND: https://treb.app/license */
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/riskampjs-mc/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/riskampjs-mc/dist/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("!function(r,t){ true?t(exports):0}(this,(function(r){\"use strict\";var t=new(function(){function r(r){void 0===r&&(r=0),this.m_w=0,this.m_z=0,this.Seed(r)}return r.prototype.Seed=function(r){void 0===r&&(r=0),r?(this.m_w=Math.round(2863311530&r)||1,this.m_z=Math.round(1431655765&r)||1):(this.m_w=Math.round(1e5*Math.random()),this.m_z=Math.round((new Date).getTime()))},r.prototype.Next=function(){this.m_z=36969*(65535&this.m_z)+(this.m_z>>16)&4294967295,this.m_w=18e3*(65535&this.m_w)+(this.m_w>>16)&4294967295;var r=(this.m_z<<16)+this.m_w&4294967295;return(r/=4294967296)+.5},r.prototype.GetState=function(){return[this.m_w,this.m_z]},r}()),a=function(){function r(){}return r.Sort=function(r,t){this.QuickSort(r,t,0,r.length)},r.Partition=function(r,t,a,o){for(var e=r[o-1],n=a,i=a;i<o-1;i+=1)r[i]<=e&&(this.Swap(r,t,i,n),n+=1);return this.Swap(r,t,n,o-1),n},r.Swap=function(r,t,a,o){var e=r[a];r[a]=r[o],r[o]=e,e=t[a],t[a]=t[o],t[o]=e},r.QuickSort=function(r,t,a,o){if(a<o){var e=this.Partition(r,t,a,o);this.QuickSort(r,t,a,e),this.QuickSort(r,t,e+1,o)}},r}(),o=function(){return(o=Object.assign||function(r){for(var t,a=1,o=arguments.length;a<o;a++)for(var e in t=arguments[a])Object.prototype.hasOwnProperty.call(t,e)&&(r[e]=t[e]);return r}).apply(this,arguments)},e=function(){function r(){}return r.Sort=function(r){return this.QuickSort(r,0,r.length-1),r},r.Swap=function(r,t,a){var o=r[t];r[t]=r[a],r[a]=o},r.Partition=function(r,t,a){for(var o=r[Math.floor((a+t)/2)];t<=a;){for(;r[t]<o;)t++;for(;r[a]>o;)a--;t<=a&&(this.Swap(r,t,a),t++,a--)}return t},r.QuickSort=function(r,t,a){var o;return r.length>1&&(t<(o=this.Partition(r,t,a))-1&&this.QuickSort(r,t,o-1),o<a&&this.QuickSort(r,o,a)),r},r}(),n=function(){function r(){}return r.Correlation=function(r,t){for(var a=0,o=0,e=0,n=0,i=0,s=0,h=0;h<r.length;h++)o+=r[h]*t[h],e+=r[h],n+=t[h],i+=r[h]*r[h],s+=t[h]*t[h];return(a=r.length*o-e*n)&&(a/=Math.sqrt((r.length*i-e*e)*(r.length*s-n*n))),a},r.TickRange=function(r,t,a){var o=r/(t-1),e=Math.ceil(this.Log10(o)-1),n=Math.pow(10,e);return Math.ceil(o/n)*n},r.Log10=function(r){return Math.log(r)/Math.LN10},r.Log2=function(r){return Math.log(r)/Math.LN2},r.Percentiles=function(r,t){for(var a=e.Sort(r.slice(0)),o=a.length,n=new Array(101),i=0;i<100;i++)n[i]=a[Math.round(o*i/100)];return n[100]=a[o-1],n},r.Percentile=function(r,t){var a=e.Sort(r.slice(0)),o=a.length;return a[Math.max(0,Math.min(o-1,Math.round(o*t)))]},r.Interval=function(r){var t=0;if(!r.data||!r.data.length)return 0;if(void 0===r.min){if(void 0===r.max)return 1;for(var a=0,o=r.data;a<o.length;a++){(h=o[a])<=r.max&&t++}}else if(void 0===r.max)for(var e=0,n=r.data;e<n.length;e++){(h=n[e])>=r.min&&t++}else for(var i=0,s=r.data;i<s.length;i++){var h;(h=s[i])>=r.min&&h<=r.max&&t++}return t/r.data.length},r.R2=function(r,t){for(var a=0,o=0,e=0,n=0,i=0,s=0,h=0,f=0,u=0;u<r.length;u++)n+=(o=t[u])*(e=r[u]),i+=o,s+=e,h+=o*o,f+=e*e;return(a=r.length*n-i*s)&&(a/=Math.sqrt((r.length*h-i*i)*(r.length*f-s*s))),a*=a},r.ToSD=function(r,t){if(void 0===t&&(t=2),t=t||2,0===r)return r;var a=Math.pow(10,Math.floor(this.Log10(r))+1-t);return Math.round(r/a)*a},r.Statistics=function(r){for(var t=this.Range(r),a=r.length,n=0,i=0,s=0,h=0,f=e.Sort(r.slice(0)),u=f[Math.round(a/2)],l=0;l<a;l++)n+=r[l];var d=n/=a;for(l=0;l<a;l++){var v=r[l]-n;i+=v*v,h+=v*v*v,s+=v*v*v*v}var c=a,m=i/a,M=Math.sqrt(i/a),p=h/((a-1)*Math.pow(M,3)),w=s/((a-1)*Math.pow(M,4)),y=Math.sqrt(i/a)/Math.sqrt(a),g={};for(l=5;l<100;l+=5)g[l]=f[Math.round(a*l/100)];g[0]=f[0],g[100]=f[a-1];var _=this.Interval({data:r,max:0});return o(o({},t),{median:u,mean:d,N:c,variance:m,stdev:M,skewness:p,kurtosis:w,stderr:y,percentiles:g,zero:_})},r.Truncate=function(r,t,a){var o=e.Sort(r.slice(0));return o.slice(Math.round(o.length*t/100),Math.round(o.length*a/100))},r.Histogram=function(r,t){void 0===t&&(t=\"sturges\");for(var a=!0,o=0;a&&o<r.length;o++)a=a&&r[o]===Math.round(r[o]);var e=this.Range(r);if(\"string\"==typeof t||!t)if(\"fd\"===t){var n=this.FD(r);t=0===n||0===e.range?1:Math.round(e.range/n+1)}else t=this.Sturges(r);var i=[],s=[];if(a&&t>e.range){t=e.range+1;for(o=0;o<t;o++)i[o]=0,s[o]=e.min+o;for(var h=0,f=r;h<f.length;h++){i[(M=f[h])-e.min]++}}else{var u=this.TickRange(e.range,t),l=this.FirstBin(e.max,e.min,t,u),d=Math.ceil(this.Log10(u)-1);for(o=0;o<t;o++)i[o]=0,s[o]=(l+o*u).toFixed(Math.max(0,-d));for(var v=l-u,c=0,m=r;c<m.length;c++){var M=m[c];i[Math.floor((M-v)/u)]++}}return{bins:i,labels:s}},r.Sturges=function(r){return Math.ceil(this.Log2(r.length)+1)},r.IQR=function(r){var t=this.Quantiles(r,[.25,.75]);return t[1]-t[0]},r.Quantiles=function(r,t){void 0===t&&(t=[0,.25,.5,.75,1]);var a=e.Sort(r.slice(0));return t.map((function(r){return a[Math.floor((a.length-1)*r)]}))},r.FD=function(r){return 2*this.IQR(r)*Math.pow(r.length,-1/3)},r.FirstBin=function(r,t,a,o){var e=(Math.floor(t/o)+1)*o,n=Math.floor((e+(a-1)*o-r)/o);return n>=2?e-n/2*o:e},r.Range=function(r){for(var t=r.length,a=t>0?r[0]:0,o=t>0?r[0]:0,e=1;e<t;e++)r[e]>o&&(o=r[e]),r[e]<a&&(a=r[e]);return{min:a,max:o,range:o-a}},r.EPSILON_DOUBLE=2220446049250313e-31,r.QUIET_NAN=Number.NaN,r.s_undefined=\"undefined\",r.s_object=\"object\",r.s_number=\"number\",r}(),i=function(){function r(){this.rows=0,this.columns=0,this.data=[]}return r.Zero=function(t,a){return void 0===a&&(a=t),(new r).Reset(t,a)},r.Identity=function(r){for(var t=this.Zero(r,r),a=0;a<r;a++)t.data[a][a]=1;return t},r.Clone=function(t){var a=new r;a.rows=t.rows,a.columns=t.columns;for(var o=0,e=t.data;o<e.length;o++){var n=e[o];a.data.push(new Float64Array(n))}return a},r.FromArray=function(r,t){void 0===t&&(t=!1);var a=r[0].length,o=r.length;if(t){for(var e=this.Zero(a,o),n=0;n<o;n++)for(var i=0;i<a;i++)e.data[n][i]=r[n][i];return e}for(e=this.Zero(o,a),n=0;n<o;n++)for(i=0;i<a;i++)e.data[i][n]=r[n][i]||0;return e},r.prototype.Reset=function(r,t){this.data=new Array(t);for(var a=0;a<t;a++)this.data[a]=new Float64Array(r);return this.rows=r,this.columns=t,this},r.prototype.CopyTo=function(r){r.rows=this.rows,r.columns=this.columns,r.data=new Array(this.columns);for(var t=0,a=this.data;t<a.length;t++){var o=a[t];r.data.push(new Float64Array(o))}return r},r.prototype.GetColumn=function(r){return this.data[r]},r.prototype.SetColumn=function(r,t){this.data[r]=new Float64Array(t)},r.prototype.Transpose=function(){for(var t=r.Zero(this.columns,this.rows),a=0;a<this.columns;a++)for(var o=0;o<this.rows;o++)t.data[a][o]=this.data[o][a];return t},r.prototype.Symmetrize=function(t){void 0===t&&(t=!1);var a=this.Transpose(),o=r.Clone(this);if(t)for(n=1;n<this.columns;n++)for(e=0;e<n;e++)o.data[e][n]=a.data[e][n];else for(var e=1;e<this.rows;e++)for(var n=0;n<e;n++)o.data[e][n]=a.data[e][n];return o},r.prototype.Cholesky=function(t){if(void 0===t&&(t=!1),this.rows!==this.columns)throw new Error(\"matrix not square\");for(var a=this.rows,o=r.Zero(a),e=0;e<a;e++){for(var n=0,i=0;i<e;i++){for(var s=0,h=0;h<i;h++)s+=o.data[i][h]*o.data[e][h];if(o.data[e][i]=s=(this.data[e][i]-s)/o.data[i][i],n+=s*s,this.data[i][e]!==this.data[e][i])throw new Error(\"matrix not symmetrical\")}if((n=this.data[e][e]-n)<=0)throw new Error(\"matrix not pos-def (\"+n+\")\");o.data[e][e]=n>0?Math.sqrt(n):0;for(i=e+1;i<a;i++)o.data[e][i]=0}return t?o.Transpose():o},r.prototype.Multiply=function(t){for(var a=0,o=0,e=r.Zero(this.rows,t.columns),n=0;n<this.rows;n++)for(var i=0;i<t.columns;i++){for(o=a=0;a<this.columns;a++)o+=this.data[a][n]*t.data[i][a];e.data[i][n]=o}return e},r.prototype.Inverse=function(){if(this.rows!==this.columns)throw new Error(\"invalid matrix\");for(var t=r.Clone(this),a=0,o=t.rows,e=1;e<o;e++)t.data[e][0]/=t.data[0][0];for(e=1;e<o;e++){for(var n=e;n<o;n++){a=0;for(var i=0;i<e;i++)a+=t.data[i][n]*t.data[e][i];t.data[e][n]-=a}if(e!==o-1)for(n=e+1;n<o;n++){a=0;for(i=0;i<e;i++)a+=t.data[i][e]*t.data[n][i];t.data[n][e]=(t.data[n][e]-a)/t.data[e][e]}}for(e=0;e<o;e++)for(n=e;n<o;n++){var s=1;if(e!==n){s=0;for(i=e;i<n;i++)s-=t.data[i][n]*t.data[e][i]}t.data[e][n]=s/t.data[n][n]}for(e=0;e<o;e++)for(n=e;n<o;n++)if(e!==n){a=0;for(i=e;i<n;i++)a+=t.data[n][i]*(e===i?1:t.data[i][e]);t.data[n][e]=-a}for(e=0;e<o;e++)for(n=0;n<o;n++){a=0;for(i=e>n?e:n;i<o;i++)a+=(n===i?1:t.data[i][n])*t.data[e][i];t.data[e][n]=a}return t},r.prototype.SortColumns=function(t){void 0===t&&(t=!1);for(var a=r.Clone(this),o=t?function(r,t){return t-r}:function(r,t){return r-t},e=0,n=a.data;e<n.length;e++){n[e].sort(o)}return a},r.prototype.Rank=function(t){void 0===t&&(t=!1);for(var o=r.Clone(this),e=new Int32Array(this.rows),n=0;n<this.rows;n++)e[n]=n;for(var i=0;i<this.columns;i++){var s=new Int32Array(e);a.Sort(o.data[i],s),t&&s.reverse();for(n=0;n<this.rows;n++)o.data[i][s[n]]=n}return o},r.prototype.Rank2=function(t,o){void 0===t&&(t=!1);for(var e=r.Zero(this.rows,this.columns),n=new Int32Array(this.rows),i=0;i<this.rows;i++)n[i]=i;for(var s=0;s<this.columns;s++){var h=new Int32Array(n);a.Sort(this.data[s],h),t&&h.reverse();for(i=0;i<this.rows;i++)e.data[s][h[i]]=o.data[s][i]}return e},r.prototype.Correl=function(){for(var t=r.Zero(this.columns,this.columns),a=0;a<this.columns;a++){t.data[a][a]=1;for(var o=0;o<a;o++)t.data[o][a]=n.Correlation(this.data[a],this.data[o])}return t.Symmetrize()},r.prototype.IsSymmetric=function(){if(this.rows!==this.columns)return!1;for(var r=0;r<this.columns;r++)for(var t=0;t<this.rows;t++)if(this.data[r][t]!==this.data[t][r])return!1;return!0},r.prototype.toString=function(r){var t=\"\";r=r||2;for(var a=0;a<this.rows;a++){for(var o=0;o<this.columns;o++){var e=this.data[o][a];e>=0&&(t+=\" \"),t+=e.toFixed(r),t+=\" \"}t+=\"\\n\"}return t},r}();Math.hypot||(Math.hypot=function(){for(var r=0,t=arguments.length,a=0;a<t;a++){if(arguments[a]===1/0||arguments[a]===-1/0)return 1/0;r+=arguments[a]*arguments[a]}return Math.sqrt(r)});var s=function(){function r(){}return r.Guid=function(){for(var r=\"\",t=0;t<8;t++)r+=Math.round(256*Math.random()).toString(16);return r},r.Log10=function(r){return Math.log(r)/Math.LN10},r.ToSD=function(r,t){if(void 0===t&&(t=2),t=t||2,0===r)return r;var a=r<0?-1:1;r*=a;var o=Math.pow(10,Math.floor(this.Log10(r))+1-t);return Math.round(r/o)*o*a},r.ToSDCeil=function(r,t){if(void 0===t&&(t=2),t=t||2,0===r)return r;var a=r<0?-1:1;r*=a;var o=Math.pow(10,Math.floor(this.Log10(r))+1-t);return Math.ceil(r/o)*o*a},r.SuggestDecimals=function(r){if(\"number\"!=typeof r){for(var t=r[0],a=r[0],o=0,e=r;o<e.length;o++){var n=e[o];t=Math.min(t,n),a=Math.max(a,n)}r=a-t}var i=Math.ceil(this.Log10(r));return console.log(i),i<=0?1-i:1},r.YearFraction=function(r){var t=new Date(r.getTime());return t.setMonth(11,31),(t.getTime()-r.getTime())/this.MILLIS_YEAR},r.DEFAULT_NUMBER_FORMAT=\"(0,0.00)\",r.DEFAULT_PCT_FORMAT=\"0.00\",r.DEFAULT_CURRENCY_FORMAT=\"(0,0)\",r.MILLIS_YEAR=315576e5,r}(),h=function(){function r(r){this.order=0,this.realvalues=[],this.ivalues=[],this.vectors=[];var t=r.length;this.order=t,this.vectors=[];for(var a=!0,o=0;a&&o<t;o++){if(r[o].length!==t)throw new Error(\"not square\");for(var e=0;e<t;e++)r[o][e]!==r[e][o]&&(a=!1)}if(a){for(o=0;o<t;o++)Array.isArray(r[o])?this.vectors.push(r[o].slice(0)):this.vectors.push(Array.from(r[o]));this.tred2(),this.tql2()}else{var n=[],i=[];for(o=0;o<t;o++){Array.isArray(r[o])?n.push(r[o].slice(0)):n.push(Array.from(r[o])),this.vectors.push([]);for(e=0;e<t;e++)this.vectors[o][e]=0;i.push(0)}this.orthes(n,i),this.hqr2(n,i)}}return r.prototype.GetDiagonal=function(){for(var r=[],t=0;t<this.order;t++){r.push([]);for(var a=0;a<this.order;a++)r[t][a]=0;r[t][t]=this.realvalues[t],this.ivalues[t]>0?r[t][t+1]=this.ivalues[t]:this.ivalues[t]<0&&(r[t][t-1]=this.ivalues[t])}return r},r.prototype.tred2=function(){for(var r=0,t=0,a=0,o=0,e=0,n=this.order,i=this.vectors,s=this.realvalues,h=this.ivalues,f=0;f<n;f++)s[f]=i[n-1][f];for(var u=n-1;u>0;u--){a=0,o=0;for(var l=0;l<u;l++)a+=Math.abs(s[l]);if(0===a){h[u]=s[u-1];for(f=0;f<u;f++)s[f]=i[u-1][f],i[u][f]=0,i[f][u]=0}else{for(l=0;l<u;l++)s[l]/=a,o+=s[l]*s[l];r=s[u-1],t=Math.sqrt(o),r>0&&(t=-t),h[u]=a*t,o-=r*t,s[u-1]=r-t;for(f=0;f<u;f++)h[f]=0;for(f=0;f<u;f++){r=s[f],i[f][u]=r;var d=h[f]+i[f][f]*r;for(l=f+1;l<=u-1;l++)d+=i[l][f]*s[l],h[l]+=i[l][f]*r;h[f]=d}r=0;for(f=0;f<u;f++)h[f]/=o,r+=h[f]*s[f];e=r/(o+o);for(f=0;f<u;f++)h[f]-=e*s[f];for(f=0;f<u;f++){r=s[f],t=h[f];for(l=f;l<=u-1;l++)i[l][f]-=r*h[l]+t*s[l];s[f]=i[u-1][f],i[u][f]=0}}s[u]=o}for(u=0;u<n-1;u++){if(i[n-1][u]=i[u][u],i[u][u]=1,0!==(o=s[u+1])){for(l=0;l<=u;l++)s[l]=i[l][u+1]/o;for(f=0;f<=u;f++){t=0;for(l=0;l<=u;l++)t+=i[l][u+1]*i[l][f];for(l=0;l<=u;l++)i[l][f]-=t*s[l]}}for(l=0;l<=u;l++)i[l][u+1]=0}for(f=0;f<n;f++)s[f]=i[n-1][f],i[n-1][f]=0;i[n-1][n-1]=1,h[0]=0},r.prototype.tql2=function(){var r,t,a,o,e,n,i,s,h,f,u,l,d,v,c,m,M,p,w,y=this.order,g=this.vectors,_=this.realvalues,b=this.ivalues;for(r=1;r<y;r++)b[r-1]=b[r];for(b[y-1]=0,i=0,s=0,h=Math.pow(2,-52),t=0;t<y;t++){for(s=Math.max(s,Math.abs(_[t])+Math.abs(b[t])),n=t;n<y&&!(Math.abs(b[n])<=h*s);)n++;if(n>t)do{for(f=_[t],o=(_[t+1]-f)/(2*b[t]),u=Math.hypot(o,1),o<0&&(u=-u),_[t]=b[t]/(o+u),_[t+1]=b[t]*(o+u),l=_[t+1],d=f-_[t],r=t+2;r<y;r++)_[r]-=d;for(i+=d,o=_[n],c=v=1,m=v,M=b[t+1],p=0,w=0,r=n-1;r>=t;r--)for(m=c,c=v,w=p,f=v*b[r],d=v*o,u=Math.hypot(o,b[r]),b[r+1]=p*u,p=b[r]/u,o=(v=o/u)*_[r]-p*f,_[r+1]=d+p*(v*f+p*_[r]),a=0;a<y;a++)d=g[a][r+1],g[a][r+1]=p*g[a][r]+v*d,g[a][r]=v*g[a][r]-p*d;o=-p*w*m*M*b[t]/l,b[t]=p*o,_[t]=v*o}while(Math.abs(b[t])>h*s);_[t]=_[t]+i,b[t]=0}for(r=0;r<y-1;r++){for(a=r,o=_[r],e=r+1;e<y;e++)_[e]<o&&(a=e,o=_[e]);if(a!==r)for(_[a]=_[r],_[r]=o,e=0;e<y;e++)o=g[e][r],g[e][r]=g[e][a],g[e][a]=o}},r.prototype.orthes=function(r,t){var a,o,e,n,i,s,h,f=this.order,u=this.vectors,l=(this.realvalues,this.ivalues,f-1);for(s=1;s<=l-1;s++){for(h=0,n=s;n<=l;n++)h+=Math.abs(r[n][s-1]);if(0!==h){for(e=0,n=l;n>=s;n--)t[n]=r[n][s-1]/h,e+=t[n]*t[n];for(o=Math.sqrt(e),t[s]>0&&(o=-o),e-=t[s]*o,t[s]=t[s]-o,i=s;i<f;i++){for(a=0,n=l;n>=s;n--)a+=t[n]*r[n][i];for(a/=e,n=s;n<=l;n++)r[n][i]-=a*t[n]}for(n=0;n<=l;n++){for(a=0,i=l;i>=s;i--)a+=t[i]*r[n][i];for(a/=e,i=s;i<=l;i++)r[n][i]-=a*t[i]}t[s]=h*t[s],r[s][s-1]=h*o}}for(n=0;n<f;n++)for(i=0;i<f;i++)u[n][i]=n===i?1:0;for(s=l-1;s>=1;s--)if(0!==r[s][s-1]){for(n=s+1;n<=l;n++)t[n]=r[n][s-1];for(i=s;i<=l;i++){for(o=0,n=s;n<=l;n++)o+=t[n]*u[n][i];for(o=o/t[s]/r[s][s-1],n=s;n<=l;n++)u[n][i]+=o*t[n]}}},r.prototype.cdiv=function(r,t,a,o){var e=0,n=0;return Math.abs(a)>Math.abs(o)?{r:(r+(e=o/a)*t)/(n=a+e*o),i:(t-e*r)/n}:{r:((e=a/o)*r+t)/(n=o+e*a),i:(e*t-r)/n}},r.prototype.hqr2=function(r,t){var a,o,e,n,i,s,h,f,u,l,d,v=this.order,c=this.vectors,m=this.realvalues,M=this.ivalues,p=v,w=p-1,y=p-1,g=Math.pow(2,-52),_=0,b=0,S=0,I=0,L=0,A=0,N=0;for(s=0;s<p;s++)for((s<0||s>y)&&(m[s]=r[s][s],M[s]=0),h=Math.max(s-1,0);h<p;h++)N+=Math.abs(r[s][h]);for(u=0;w>=0;){for(l=w;l>0&&(0===(L=Math.abs(r[l-1][l-1])+Math.abs(r[l][l]))&&(L=N),!(Math.abs(r[l][l-1])<g*L));)l--;if(l===w)r[w][w]=r[w][w]+_,m[w]=r[w][w],M[w]=0,w--,u=0;else if(l===w-1){if(o=r[w][w-1]*r[w-1][w],S=(b=(r[w-1][w-1]-r[w][w])/2)*b+o,A=Math.sqrt(Math.abs(S)),r[w][w]=r[w][w]+_,r[w-1][w-1]=r[w-1][w-1]+_,e=r[w][w],S>=0){for(A=b>=0?b+A:b-A,m[w-1]=e+A,m[w]=m[w-1],0!==A&&(m[w]=e-o/A),M[w-1]=0,M[w]=0,b=(e=r[w][w-1])/(L=Math.abs(e)+Math.abs(A)),S=A/L,b/=I=Math.sqrt(b*b+S*S),S/=I,h=w-1;h<p;h++)A=r[w-1][h],r[w-1][h]=S*A+b*r[w][h],r[w][h]=S*r[w][h]-b*A;for(s=0;s<=w;s++)A=r[s][w-1],r[s][w-1]=S*A+b*r[s][w],r[s][w]=S*r[s][w]-b*A;for(s=0;s<=y;s++)A=c[s][w-1],c[s][w-1]=S*A+b*c[s][w],c[s][w]=S*c[s][w]-b*A}else m[w-1]=e+b,m[w]=e+b,M[w-1]=A,M[w]=-A;w-=2,u=0}else{if(e=r[w][w],n=0,o=0,l<w&&(n=r[w-1][w-1],o=r[w][w-1]*r[w-1][w]),10===u){for(_+=e,s=0;s<=w;s++)r[s][s]-=e;e=n=.75*(L=Math.abs(r[w][w-1])+Math.abs(r[w-1][w-2])),o=-.4375*L*L}if(30===u&&(L=(L=(n-e)/2)*L+o)>0){for(L=Math.sqrt(L),n<e&&(L=-L),L=e-o/((n-e)/2+L),s=0;s<=w;s++)r[s][s]-=L;_+=L,e=n=o=.964}for(u+=1,d=w-2;d>=l&&(b=((I=e-(A=r[d][d]))*(L=n-A)-o)/r[d+1][d]+r[d][d+1],S=r[d+1][d+1]-A-I-L,I=r[d+2][d+1],b/=L=Math.abs(b)+Math.abs(S)+Math.abs(I),S/=L,I/=L,d!==l)&&!(Math.abs(r[d][d-1])*(Math.abs(S)+Math.abs(I))<g*(Math.abs(b)*(Math.abs(r[d-1][d-1])+Math.abs(A)+Math.abs(r[d+1][d+1]))));)d--;for(s=d+2;s<=w;s++)r[s][s-2]=0,s>d+2&&(r[s][s-3]=0);for(f=d;f<=w-1;f++){var F=f!==w-1;if(f!==d&&(b=r[f][f-1],S=r[f+1][f-1],I=F?r[f+2][f-1]:0,0!==(e=Math.abs(b)+Math.abs(S)+Math.abs(I))&&(b/=e,S/=e,I/=e)),0===e)break;if(L=Math.sqrt(b*b+S*S+I*I),b<0&&(L=-L),0!==L){for(f!==d?r[f][f-1]=-L*e:l!==d&&(r[f][f-1]=-r[f][f-1]),e=(b+=L)/L,n=S/L,A=I/L,S/=b,I/=b,h=f;h<p;h++)b=r[f][h]+S*r[f+1][h],F&&(b+=I*r[f+2][h],r[f+2][h]=r[f+2][h]-b*A),r[f][h]=r[f][h]-b*e,r[f+1][h]=r[f+1][h]-b*n;for(s=0;s<=Math.min(w,f+3);s++)b=e*r[s][f]+n*r[s][f+1],F&&(b+=A*r[s][f+2],r[s][f+2]=r[s][f+2]-b*I),r[s][f]=r[s][f]-b,r[s][f+1]=r[s][f+1]-b*S;for(s=0;s<=y;s++)b=e*c[s][f]+n*c[s][f+1],F&&(b+=A*c[s][f+2],c[s][f+2]=c[s][f+2]-b*I),c[s][f]=c[s][f]-b,c[s][f+1]=c[s][f+1]-b*S}}}}if(0!==N){for(w=p-1;w>=0;w--)if(b=m[w],0===(S=M[w]))for(l=w,r[w][w]=1,s=w-1;s>=0;s--){for(o=r[s][s]-b,I=0,h=l;h<=w;h++)I+=r[s][h]*r[h][w];if(M[s]<0)A=o,L=I;else if(l=s,0===M[s]?r[s][w]=0!==o?-I/o:-I/(g*N):(e=r[s][s+1],n=r[s+1][s],a=(e*L-A*I)/(S=(m[s]-b)*(m[s]-b)+M[s]*M[s]),r[s][w]=a,Math.abs(e)>Math.abs(A)?r[s+1][w]=(-I-o*a)/e:r[s+1][w]=(-L-n*a)/A),g*(a=Math.abs(r[s][w]))*a>1)for(h=s;h<=w;h++)r[h][w]=r[h][w]/a}else if(S<0)for(l=w-1,Math.abs(r[w][w-1])>Math.abs(r[w-1][w])?(r[w-1][w-1]=S/r[w][w-1],r[w-1][w]=-(r[w][w]-b)/r[w][w-1]):(i=this.cdiv(0,-r[w-1][w],r[w-1][w-1]-b,S),r[w-1][w-1]=i.r,r[w-1][w]=i.i),r[w][w-1]=0,r[w][w]=1,s=w-2;s>=0;s--){var x=void 0,T=void 0,C=void 0,E=void 0;for(x=0,T=0,h=l;h<=w;h++)x+=r[s][h]*r[h][w-1],T+=r[s][h]*r[h][w];if(o=r[s][s]-b,M[s]<0)A=o,I=x,L=T;else if(l=s,0===M[s]?(i=this.cdiv(-x,-T,o,S),r[s][w-1]=i.r,r[s][w]=i.i):(e=r[s][s+1],n=r[s+1][s],C=(m[s]-b)*(m[s]-b)+M[s]*M[s]-S*S,E=2*(m[s]-b)*S,0===C&&0===E&&(C=g*N*(Math.abs(o)+Math.abs(S)+Math.abs(e)+Math.abs(n)+Math.abs(A))),i=this.cdiv(e*I-A*x+S*T,e*L-A*T-S*x,C,E),r[s][w-1]=i.r,r[s][w]=i.i,Math.abs(e)>Math.abs(A)+Math.abs(S)?(r[s+1][w-1]=(-x-o*r[s][w-1]+S*r[s][w])/e,r[s+1][w]=(-T-o*r[s][w]-S*r[s][w-1])/e):(i=this.cdiv(-I-n*r[s][w-1],-L-n*r[s][w],A,S),r[s+1][w-1]=i.r,r[s+1][w]=i.i)),g*(a=Math.max(Math.abs(r[s][w-1]),Math.abs(r[s][w])))*a>1)for(h=s;h<=w;h++)r[h][w-1]=r[h][w-1]/a,r[h][w]=r[h][w]/a}for(s=0;s<p;s++)if(s<0||s>y)for(h=s;h<p;h++)c[s][h]=r[s][h];for(h=p-1;h>=0;h--)for(s=0;s<=y;s++){for(A=0,f=0;f<=Math.min(h,y);f++)A+=c[s][f]*r[f][h];c[s][h]=A}}},r}(),f=Math.pow(2,-52),u=function(){function r(){this.rows=0,this.columns=0,this._data=[]}return r.FromArray=function(r){for(var t=r[0].length,a=r.length,o=this.Zero(a,t),e=0;e<a;e++)for(var n=0;n<t;n++)o._data[e][n]=r[e][n]||0;return o},r.Zero=function(t,a){return void 0===a&&(a=t),(new r).Reset(t,a)},r.Identity=function(r){for(var t=this.Zero(r),a=0;a<r;a++)t._data[a][a]=1;return t},r.Clone=function(r){for(var t=this.Zero(r.rows,r.columns),a=0;a<r.rows;a++)t._data[a]=new Float64Array(r._data[a]);return t},r.prototype.Reset=function(r,t){void 0===t&&(t=r),this._data=new Array(r);for(var a=0;a<r;a++)this._data[a]=new Float64Array(t);return this.rows=r,this.columns=t,this},r.prototype.CopyTo=function(r){r.rows=this.rows,r.columns=this.columns,r._data=[];for(var t=0;t<this.rows;t++)r._data[t]=new Float64Array(this._data[t]);return r},r.prototype.Row=function(r,t){return void 0!==t&&(this._data[r]=new Float64Array(t)),Array.from(this._data[r])},r.prototype.Column=function(r,t){if(void 0!==t)for(var a=0;a<this.rows;a++)this._data[a][r]=arguments[1][a];var o=new Array(this.rows);for(a=0;a<this.rows;a++)o[a]=this._data[a][r];return o},r.prototype.Transpose=function(){for(var t=r.Zero(this.columns,this.rows),a=0;a<this.rows;a++)for(var o=0;o<this.columns;o++)t._data[o][a]=this._data[a][o];return t},r.prototype.ToArray=function(r){void 0===r&&(r=!1);var t=[];if(r)for(var a=0;a<this.columns;a++)t.push(this.Column(a));else for(var o=0;o<this.rows;o++)t.push(this.Row(o));return t},r.prototype.EigenSystem=function(){return new h(this._data)},r.prototype.IsPosDef=function(){return new h(this._data).realvalues.every((function(r){return r>0}))},r.prototype.MakePosDef=function(t){void 0===t&&(t=f);var a,o,e=new h(this._data),n=e.realvalues.length,i=r.Zero(n),s=r.Zero(n),u=0,l=r.Zero(n);for(e.vectors.forEach((function(r,t){return l.Row(t,r)})),a=0;a<n;a++){for(o=0;o<n;o++)i._data[a][o]=t;e.realvalues[a]>t&&(i._data[a][a]=e.realvalues[a])}for(a=0;a<n;a++){for(u=0,o=0;o<n;o++)s._data[a][o]=0,u+=e.vectors[a][o]*e.vectors[a][o]*i._data[o][o];s._data[a][a]=Math.sqrt(1/u)}for(a=0;a<n;a++)i._data[a][a]=Math.sqrt(i._data[a][a]);for(var d=s.Multiply(l.Multiply(i)),v=d.Multiply(d.Transpose()).Symmetrize(),c=0;c<v.rows;c++)v._data[c][c]=1;return v},r.prototype.Symmetrize=function(t){void 0===t&&(t=!1);var a,o,e=this.Transpose(),n=r.Clone(this);if(t)for(a=1;a<this.rows;a++)for(o=0;o<a;o++)n._data[a][o]=e._data[a][o];else for(o=1;o<this.columns;o++)for(a=0;a<o;a++)n._data[a][o]=e._data[a][o];return n},r.prototype.Cholesky=function(t){if(void 0===t&&(t=!1),this.rows!==this.columns)throw new Error(\"matrix not square\");var a,o,e,n,i,s=this.rows,h=r.Zero(s);for(n=0;n<s;n++){for(o=0,i=0;i<n;i++){for(a=0,e=0;e<i;e++)a+=h._data[e][i]*h._data[e][n];if(h._data[i][n]=a=(this._data[i][n]-a)/h._data[i][i],o+=a*a,this._data[i][n]!=this._data[n][i])throw new Error(\"matrix not symmetrical\")}if((o=this._data[n][n]-o)<=0)throw new Error(\"matrix not pos-def\");for(h._data[n][n]=o>0?Math.sqrt(o):0,i=n+1;i<s;i++)h._data[i][n]=0}return t?h.Transpose():h},r.prototype.Multiply=function(t){var a,o,e,n,i=r.Zero(this.rows,t.columns);for(a=0;a<this.rows;a++)for(o=0;o<t.columns;o++){for(n=e=0;e<this.columns;e++)n+=this._data[a][e]*t._data[e][o];i._data[a][o]=n}return i},r.prototype.Inverse=function(){if(this.rows!==this.columns)throw new Error(\"invalid matrix\");var t,a,o,e,n=r.Clone(this),i=n.rows;for(a=1;a<i;a++)n._data[0][a]/=n._data[0][0];for(a=1;a<i;a++){for(o=a;o<i;o++){for(t=0,e=0;e<a;e++)t+=n._data[o][e]*n._data[e][a];n._data[o][a]-=t}if(a!=i-1)for(o=a+1;o<i;o++){for(t=0,e=0;e<a;e++)t+=n._data[a][e]*n._data[e][o];n._data[a][o]=(n._data[a][o]-t)/n._data[a][a]}}for(a=0;a<i;a++)for(o=a;o<i;o++){var s=1;if(a!=o)for(s=0,e=a;e<o;e++)s-=n._data[o][e]*n._data[e][a];n._data[o][a]=s/n._data[o][o]}for(a=0;a<i;a++)for(o=a;o<i;o++)if(a!=o){for(t=0,e=a;e<o;e++)t+=n._data[e][o]*(a==e?1:n._data[a][e]);n._data[a][o]=-t}for(a=0;a<i;a++)for(o=0;o<i;o++){for(t=0,e=a>o?a:o;e<i;e++)t+=(o==e?1:n._data[o][e])*n._data[e][a];n._data[o][a]=t}return n},r.prototype.SortColumns=function(t){void 0===t&&(t=!1);for(var a=r.Clone(this),o=t?function(r,t){return t-r}:function(r,t){return r-t},e=0;e<this.columns;e++)a.Column(e,this.Column(e).sort(o));return a},r.prototype.Rank=function(t){void 0===t&&(t=!1);for(var o,e=r.Clone(this),n=new Array(this.rows),i=new Array(this.rows),s=0;s<this.columns;s++){for(o=0;o<this.rows;o++)i[o]=o,n[o]=this._data[o][s];for(a.Sort(n,i),t&&i.reverse(),o=0;o<this.rows;o++)e._data[i[o]][s]=o}return e},r.prototype.Correl=function(){for(var t=new Array(this.columns),a=0;a<this.columns;a++)t[a]=this.Column(a);for(var o=r.Zero(this.columns),e=0;e<this.columns;e++){o._data[e][e]=1;for(var i=0;i<e;i++)o._data[e][i]=n.Correlation(t[e],t[i])}return o.Symmetrize()},r.prototype.IsSymmetric=function(){if(this.rows!=this.columns)return!1;for(var r=0;r<this.rows;r++)for(var t=0;t<this.columns;t++)if(this._data[r][t]!==this._data[t][r])return!1;return!0},r}();Math.hypot||(Math.hypot=function(){for(var r=0,t=arguments.length,a=0;a<t;a++){if(arguments[a]===1/0||arguments[a]===-1/0)return 1/0;r+=arguments[a]*arguments[a]}return Math.sqrt(r)});for(var l=function(){function r(){}return r.Normal=function(r,t){var a=this;void 0===t&&(t={});var e=o({mean:0,sd:1,lhs:!1,ordered:!1},t);return(e.lhs?this.LHSField(r,e.ordered):this.UniformField(r,e.ordered)).map((function(r){return a.InverseNormal2(r)*e.sd+e.mean}))},r.ReverseInverseNormal2=function(r,t){var a=this;void 0===t&&(t=40);for(var o=[0,Math.min(1,Math.max(0,.5+.125*r)),1],e=o.map((function(r){return a.InverseNormal2(r)})),n=0;n<t;n++){if(Math.abs(e[1]-r)<=1e-6)return o[1];e[1]<r?(o=[o[1],(o[1]+o[2])/2,o[2]],e=[e[1],this.InverseNormal2(o[1]),e[2]]):(o=[o[0],(o[0]+o[1])/2,o[1]],e=[e[0],this.InverseNormal2(o[1]),e[1]])}return o[1]},r.TruncatedNormal=function(r,t){var a=this;void 0===t&&(t={});var e=o({mean:0,sd:1,lhs:!1,ordered:!1},t),n=e.lhs?this.LHSField(r,e.ordered):this.UniformField(r,e.ordered),i=0,s=1;\"number\"==typeof e.min&&(i=this.ReverseInverseNormal2((e.min-e.mean)/e.sd,e.max_iterations)),\"number\"==typeof e.max&&(s=this.ReverseInverseNormal2((e.max-e.mean)/e.sd,e.max_iterations));var h=s-i;return(n=n.map((function(r){return r*h+i}))).map((function(r){return a.InverseNormal2(r)*e.sd+e.mean}))},r.LogNormal=function(r,t){void 0===t&&(t={});for(var a=o({mean:1,sd:1,lhs:!1,ordered:!1},t),e=a.lhs?this.LHSFieldDouble(r,a.ordered):this.UniformField(r,a.ordered),n=0;n<e.length;n++)e[n]=Math.exp(this.InverseNormal2(e[n])*a.sd+a.mean);return e},r.LogNormalReturn=function(r,t){void 0===t&&(t={});var a=o({mean:1,sd:1,lhs:!1,ordered:!1},t),e=a.lhs?this.LHSFieldDouble(r,a.ordered):this.UniformField(r,a.ordered);a.mean+=1;for(var n=a.mean*a.mean,i=a.sd*a.sd,s=Math.log(n/Math.sqrt(n+i)),h=Math.sqrt(Math.log((n+i)/n)),f=0;f<r;f++)e[f]=Math.exp(this.InverseNormal2(e[f])*h+s)-1;return e},r.Triangular=function(r,t){var a=this;void 0===t&&(t={});var e=o({a:0,b:1,c:.5,lhs:!1,ordered:!1,field:null},t);return(e.field||(e.lhs?this.LHSField(r,e.ordered):this.UniformField(r,e.ordered))).map((function(r){return a.InverseTriangular(r,e.a,e.b,e.c)}))},r.PERT=function(r,t){void 0===t&&(t={});var a=o({field:null,lhs:!1,a:0,b:1,c:.5,lambda:4,ordered:!1},t),e=a.field||(a.lhs?this.LHSField(r,a.ordered):this.UniformField(r,a.ordered));return this.InversePERTField(e,a.a,a.b,a.c,a.lambda)},r.Uniform=function(r,t){void 0===t&&(t={});for(var a=o({lhs:!1,min:0,max:1,ordered:!1},t),e=a.lhs?this.LHSFieldDouble(r,a.ordered):this.UniformField(r,a.ordered),n=a.max-a.min,i=0;i<e.length;i++)e[i]=e[i]*n+a.min;return e},r.Bernoulli=function(r,t){void 0===t&&(t={});var a=o({lhs:!1,p:.5},t);return this.Uniform(r,{lhs:a.lhs,min:0,max:1}).map((function(r){return r<=a.p}))},r.Beta=function(r,t){var a=this;void 0===t&&(t={});var e=o({lhs:!1,a:0,b:1,ordered:!1},t);return(e.lhs?this.LHSField(r,e.ordered):this.UniformField(r,e.ordered)).map((function(r){return a.InverseBeta(r,e.a,e.b)}))},r.Discretize=function(r,t){var a=r.slice(0);t=t||Math.round;for(var o=0;o<a.length;o++)a[o]=t(a[o]);return a},r.Constant=function(r,t){for(var a=new Array(r),o=0;o<r;o++)a[o]=t;return a},r.Fixed=function(r,t){void 0===t&&(t={}),t=o({value:0},t);for(var a=new Array(r),e=0;e<r;e++)a[e]=t.value;return a},r.Conditional=function(r,t,a,o,e,n){void 0===e&&(e=0);for(var i=n||this.Bernoulli(r,{lhs:!0,p:t}),s=a(Math.ceil(r*t),o),h=new Array(r),f=0,u=0;f<r;f++)h[f]=i[f]?s[u++]:e;return h},r.Correlate=function(r,t,a){void 0===a&&(a=!1);var o,e=t.length,n=t[0].length,i=u.Zero(n,e);for(o=0;o<e;o++)i.Column(o,this.VDWField(n));var s=i.Multiply(r.Cholesky(!0).Multiply(i.Correl().Cholesky(!0).Inverse()).Transpose()).Rank();return a?t.map((function(r,t){var a=new Array(r.length),e=s.Column(t);for(o=0;o<e.length;o++)a[o]=r[e[o]];return a})):t.map((function(r,t){var a=r.slice(0).sort((function(r,t){return r-t})),e=new Array(r.length),n=s.Column(t);for(o=0;o<n.length;o++)e[o]=a[n[o]];return e}))},r.CorrelateCDM=function(r,t,a){void 0===a&&(a=!1);var o,e=t.length,n=t[0].length,s=i.Zero(n,e);for(o=0;o<e;o++)s.SetColumn(o,this.VDWField(n));var h=new i;if(h.rows=n,h.columns=e,h.data=t.map((function(r){return new Float64Array(r)})),!a)throw new Error(\"E_NOTIMPL: correlateCDM !ordered\");return s.Multiply(r.Cholesky(!0).Multiply(s.Correl().Cholesky(!0).Inverse()).Transpose()).Rank2(!1,h).data},r.P80Pert=function(r,t,a,o){var e=this.PERTParameters(r,t,a,o),n=(e.max-e.min)/(this.InverseBeta(.9,e.v,e.w)-this.InverseBeta(.1,e.v,e.w)),i=e.min-this.InverseBeta(.1,e.v,e.w)*n,s=e.max+(1-this.InverseBeta(.9,e.v,e.w))*n;return{a:i/e.scale,b:s/e.scale,c:a}},r.P80Triangular=function(r,t,a){var o,e=(a-r)/(t-r),n=e<.5;n&&(e=1-e);var i=2.1266864*e-.1596122-2.1742909*e*e+1.1087738*e*e*e;n&&(i=1-i);var s=(t-r)/(.6890868-.4434898*e+.35757*e*e);return{a:o=a-i*s,b:o+s,c:a}},r.BetaDensity=function(r,t,a){if(\"number\"!=typeof r){for(var o=new Array(r.length),e=0;e<r.length;e++)r[e]<=0||r[e]>=1?o[e]=0:o[e]=Math.exp((t-1)*Math.log(r[e])+(a-1)*Math.log(1-r[e])-this.LnGamma(t)-this.LnGamma(a)+this.LnGamma(t+a));return o}return r<=0||r>=1?0:Math.exp((t-1)*Math.log(r)+(a-1)*Math.log(1-r)-this.LnGamma(t)-this.LnGamma(a)+this.LnGamma(t+a))},r.PERTDensity=function(r,t,a,o,e){void 0===e&&(e=4);var n,i,s=(t+a+e*o)/(e+2);return i=(n=o===s?e/2+1:(s-t)*(2*o-t-a)/((o-s)*(a-t)))*(a-s)/(s-t),this.BetaDensity(r,n,i)},r.NormalDensity=function(r){if(\"number\"!=typeof r){for(var t=new Array(r.length),a=0;a<r.length;a++)t[a]=.398942280401433*Math.exp(-r[a]*r[a]/2);return t}return.398942280401433*Math.exp(-r*r/2)},r.Shuffle=function(r){var a,o,e;for(o=r.length-1;o>=0;o--)a=Math.floor(t.Next()*(o+1)),e=r[o],r[o]=r[a],r[a]=e;return r},r.VDWField=function(r){if(this.vdw_cache.length!==r){this.vdw_cache=new Float64Array(r);for(var t=0;t<r;t++)this.vdw_cache[t]=this.InverseNormal2((t+1)/(r+1))}var a=new Float64Array(this.vdw_cache);return this.Shuffle(a)},r.LHSFieldDouble=function(r,a){void 0===a&&(a=!1);for(var o=1/r,e=new Float64Array(r),n=0;n<r;n++)e[n]=t.Next()*o+n*o;return a||this.Shuffle(e),e},r.LHSField=function(r,a){void 0===a&&(a=!1);for(var o=1/r,e=new Array(r),n=0;n<r;n++)e[n]=t.Next()*o+n*o;return a||this.Shuffle(e),e},r.UniformField=function(r,a){void 0===a&&(a=!1);for(var o=new Array(r),e=0;e<r;e++)o[e]=t.Next();return a&&o.sort((function(r,t){return r-t})),o},r.InverseTriangular=function(r,t,a,o){return t===a?t:r<=(o-t)/(a-t)?t+Math.sqrt((a-t)*(o-t)*r):a-Math.sqrt((a-t)*(a-o)*(1-r))},r.InverseNormal=function(r){return.5===r?0:(t=r<1&&r>.5?1-r:r,o=(a=Math.sqrt(Math.log(1/Math.pow(t,2))))-(2.515517+.802853*a+.010328*Math.pow(a,2))/(1+1.432788*a+.189269*Math.pow(a,2)+.001308*Math.pow(a,3)),r>.5?o:-o);var t,a,o},r.InverseNormal2=function(r){var t,a,o=r-.5;return Math.abs(o)<=.425?o*(((((((2509.0809287301227*(a=.180625-o*o)+33430.57558358813)*a+67265.7709270087)*a+45921.95393154987)*a+13731.69376550946)*a+1971.5909503065513)*a+133.14166789178438)*a+3.3871328727963665)/(((((((5226.495278852854*a+28729.085735721943)*a+39307.89580009271)*a+21213.794301586597)*a+5394.196021424751)*a+687.1870074920579)*a+42.31333070160091)*a+1):(a=o<0?r:1-r)<=0?0:(t=(a=Math.sqrt(-Math.log(a)))<=5?(((((((.0007745450142783414*(a-=1.6)+.022723844989269184)*a+.2417807251774506)*a+1.2704582524523684)*a+3.6478483247632045)*a+5.769497221460691)*a+4.630337846156546)*a+1.4234371107496835)/(((((((1.0507500716444169e-9*a+.0005475938084995345)*a+.015198666563616457)*a+.14810397642748008)*a+.6897673349851)*a+1.6763848301838038)*a+2.053191626637759)*a+1):(((((((2.0103343992922881e-7*(a-=5)+27115555687434876e-21)*a+.0012426609473880784)*a+.026532189526576124)*a+.29656057182850487)*a+1.7848265399172913)*a+5.463784911164114)*a+6.657904643501103)/(((((((20442631033899397e-31*a+1.421511758316446e-7)*a+18463183175100548e-21)*a+.0007868691311456133)*a+.014875361290850615)*a+.1369298809227358)*a+.599832206555888)*a+1),o<0?-t:t)},r.Log1p=function(r){var t=1+r;return Math.log(t)-(t-1-r)/t},r.BetaContFrac=function(t,a,o,e){var n,i=2*Number.MIN_VALUE,s=0,h=1,f=1-(t+a)*o/(t+1);for(Math.abs(f)<i&&(f=r.QUIET_NAN),n=f=1/f;s<512;){var u,l=s+1,d=l*(a-l)*o/((t-1+2*l)*(t+2*l));if(f=1+d*f,h=1+d/h,Math.abs(f)<i&&(f=r.QUIET_NAN),Math.abs(h)<i&&(h=r.QUIET_NAN),n*=u=(f=1/f)*h,f=1+(d=-(t+l)*(t+a+l)*o/((t+2*l)*(t+2*l+1)))*f,h=1+d/h,Math.abs(f)<i&&(f=r.QUIET_NAN),Math.abs(h)<i&&(h=r.QUIET_NAN),n*=u=(f=1/f)*h,Math.abs(u-1)<2*r.EPSILON_DOUBLE)break;if(n*Math.abs(u-1)<e)break;++s}return s>=512?r.QUIET_NAN:n},r.BetaCDF=function(t,a,o){if(t<=0)return 0;if(t>=1)return 1;if(0===t)return 0;if(1===t)return 1;var e,n=-(this.LnGamma(a)+this.LnGamma(o)-this.LnGamma(a+o))+a*Math.log(t)+o*this.Log1p(-t),i=Math.exp(n);return t<(a+1)/(a+o+2)?(e=Math.abs(0/(1*i/a))*r.EPSILON_DOUBLE,i*this.BetaContFrac(a,o,t,e)/a*1+0):(e=Math.abs(1/(1*i/o))*r.EPSILON_DOUBLE,1*(1-i*this.BetaContFrac(o,a,1-t,e)/o)+0)},r.LnGamma=function(r){var t=r-1,a=t+5.5;a-=(t+.5)*Math.log(a);var o=1;return o+=76.18009173/(t+=1),o+=-86.50532033/(t+=1),o+=24.01409822/(t+=1),o+=-1.231739516/(t+=1),o+=.00120858003/(t+=1),o+=-536382e-11/(t+=1),-a+Math.log(2.50662827465*o)},r.BetaPDF=function(r,t,a){return r<0||r>1?0:Math.exp(this.LnGamma(t+a)-this.LnGamma(t)-this.LnGamma(a))*Math.pow(r,t-1)*Math.pow(1-r,a-1)},r.InverseBeta=function(r,t,a){var o,e,n,i,s,h,f,u,l=0;if(r<0||r>1||t<0||a<0)return 0;if(0===r)return 0;if(1===r)return 1;if(r>.5){var d=1-r;return d>.5?this.InverseBeta(1-d,t,a):1-this.InverseBeta(d,a,t)}if(e=t/(t+a),r<.1){var v=(Math.log(t)+this.LnGamma(t)+this.LnGamma(a)-this.LnGamma(t+a)+Math.log(r))/t;v<=0?(o=Math.exp(v),o*=Math.pow(1-o,-(a-1)/t)):o=e,o>e&&(o=e)}else o=e;do{if(i=r-this.BetaCDF(o,t,a),s=this.BetaPDF(o,t,a),0===i||l++>64)return o;u=-((t-1)/o-(a-1)/(1-o))*(n=i/Math.max(2*Math.abs(i/o),s))*n/2,h=f=n,Math.abs(u)<Math.abs(f)?h+=u:h*=2*Math.abs(f/u),o+h>0&&o+h<1?o+=h:o=Math.sqrt(o)*Math.sqrt(e)}while(Math.abs(f)>1e-10*o);return o},r.InversePERTField=function(r,t,a,o,e){var n=this;if(a<=t)return r.map((function(){return t}));try{var i=this.PERTParameters(t,a,o,e);return r.map((function(r){return(n.InverseBeta(r,i.v,i.w)*(i.max-i.min)+i.min)/i.scale}))}catch(o){return t===a?r.map((function(r){return t})):r.map((function(r){return 0}))}},r.PERTParameters=function(r,t,a,o){if(void 0===o&&(o=4),r>=t||o<0||a<r||a>t)throw new Error(\"Invalid parameters\");for(var e,n,i=1;Math.abs(r)<1&&Math.abs(t)<1;)i*=10,r*=10,t*=10,a*=10;return e=(r+t+o*a)/(o+2),{v:n=(0===a?Math.abs(e-a):Math.abs((e-a)/a))<=1e-12?o/2+1:(e-r)*(2*a-r-t)/((a-e)*(t-r)),w:n*(t-e)/(e-r),min:r,max:t,scale:i}},r.InversePERT=function(r,t,a,o,e){void 0===e&&(e=4);var n=this.PERTParameters(t,a,o,e);return(this.InverseBeta(r,n.v,n.w)*(n.max-n.min)+n.min)/n.scale},r.EPSILON_DOUBLE=2220446049250313e-31,r.QUIET_NAN=Number.NaN,r.M_LN_SQRT_2PI=.9189385332046728,r.M_1_SQRT_2PI=.3989422804014327,r.vdw_cache=new Float64Array(0),r}(),d=new Array(256),v=0;v<256;++v)d[v]=(v+256).toString(16).substr(1);var c=function(){function r(){this.buffer=[],this.buffer=[];for(var r=0;r<16;r++)this.buffer[r]=Math.floor(256*t.Next())}return r.prototype.toString=function(){var r=0;return d[this.buffer[r++]]+d[this.buffer[r++]]+d[this.buffer[r++]]+d[this.buffer[r++]]+\"-\"+d[this.buffer[r++]]+d[this.buffer[r++]]+\"-\"+d[this.buffer[r++]]+d[this.buffer[r++]]+\"-\"+d[this.buffer[r++]]+d[this.buffer[r++]]+\"-\"+d[this.buffer[r++]]+d[this.buffer[r++]]+d[this.buffer[r++]]+d[this.buffer[r++]]+d[this.buffer[r++]]+d[this.buffer[r++]]},r}();r.CDMatrix=i,r.Eigensystem=h,r.MC=l,r.Matrix=u,r.QSort=e,r.QSort2=a,r.Random=t,r.Stats=n,r.UUID=c,r.Util=s,Object.defineProperty(r,\"__esModule\",{value:!0})}));\n\n\n//# sourceURL=webpack://treb/./node_modules/riskampjs-mc/dist/index.js?");

/***/ }),

/***/ "./treb-base-types/src/area.ts":
/*!*************************************!*\
  !*** ./treb-base-types/src/area.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IsCellAddress\": () => (/* binding */ IsCellAddress),\n/* harmony export */   \"Area\": () => (/* binding */ Area)\n/* harmony export */ });\n/**\n * type guard function\n * FIXME: is there a naming convention for these?\n */\nconst IsCellAddress = (obj) => {\n    return (typeof obj === 'object' &&\n        typeof obj.row !== 'undefined' &&\n        typeof obj.column !== 'undefined');\n};\n/**\n * class represents a rectangular area on a sheet. can be a range,\n * single cell, entire row/column, or entire sheet.\n *\n * \"entire\" row/column/sheet is represented with an infinity in the\n * start/end value for row/column/both, so watch out on loops. the\n * sheet class has a method for reducing infinite ranges to actual\n * populated ranges.\n */\nclass Area {\n    /**\n     *\n     * @param start\n     * @param end\n     * @param normalize: calls the normalize function\n     */\n    constructor(start, end = start, normalize = false) {\n        /*\n        // copy\n        this.start_ = {\n          row: start.row, column: start.column,\n          absolute_column: !!start.absolute_column,\n          absolute_row: !!start.absolute_row };\n    \n        this.end_ = {\n          row: end.row, column: end.column,\n          absolute_column: !!end.absolute_column,\n          absolute_row: !!end.absolute_row };\n        */\n        // patch nulls. this is an effect of transferring via JSON, \n        // infinities are -> null. make sure to strict === null.\n        // NOTE that the patch function returns a clone, so we can store the \n        // returned object (instead of copying, which we used to do).\n        this.end_ = this.PatchNull(end);\n        this.start_ = this.PatchNull(start);\n        if (normalize)\n            this.Normalize();\n        // this.ResetIterator();\n    }\n    static FromColumn(column) {\n        return new Area({ row: Infinity, column });\n    }\n    static FromRow(row) {\n        return new Area({ row, column: Infinity });\n    }\n    static ColumnToLabel(c) {\n        let s = String.fromCharCode(65 + c % 26);\n        while (c > 25) {\n            c = Math.floor(c / 26) - 1;\n            s = String.fromCharCode(65 + c % 26) + s;\n        }\n        return s;\n    }\n    static CellAddressToLabel(address, sheet_id = false) {\n        const prefix = sheet_id ? `${address.sheet_id || 0}!` : '';\n        return prefix\n            + (address.absolute_column ? '$' : '')\n            + this.ColumnToLabel(address.column)\n            + (address.absolute_row ? '$' : '')\n            + (address.row + 1);\n    }\n    /**\n     * merge two areas and return a new area.\n     * UPDATE to support arbitrary arguments\n     */\n    static Join(base, ...args) {\n        const area = new Area(base.start, base.end);\n        for (const arg of args) {\n            if (arg) {\n                area.ConsumeAddress(arg.start);\n                area.ConsumeAddress(arg.end);\n            }\n        }\n        return area;\n    }\n    /**\n     * creates an area that expands the original area in all directions\n     * (except at the top/left edges)\n     */\n    static Bleed(area, length = 1) {\n        return new Area({\n            row: Math.max(0, area.start.row - length),\n            column: Math.max(0, area.start.column - length),\n        }, {\n            row: area.end.row + length,\n            column: area.end.column + length,\n        });\n    }\n    /** accessor returns a _copy_ of the start address */\n    get start() {\n        return Object.assign({}, this.start_);\n    }\n    /** accessor */\n    set start(value) { this.start_ = value; }\n    /** accessor returns a _copy_ of the end address */\n    get end() {\n        return Object.assign({}, this.end_);\n    }\n    /** accessor */\n    set end(value) { this.end_ = value; }\n    /** returns number of rows, possibly infinity */\n    get rows() {\n        if (this.start_.row === Infinity || this.end_.row === Infinity)\n            return Infinity;\n        return this.end_.row - this.start_.row + 1;\n    }\n    /** returns number of columns, possibly infinity */\n    get columns() {\n        if (this.start_.column === Infinity || this.end_.column === Infinity)\n            return Infinity;\n        return this.end_.column - this.start_.column + 1;\n    }\n    /** returns number of cells, possibly infinity */\n    get count() {\n        return this.rows * this.columns;\n    }\n    /** returns flag indicating this is the entire sheet, usually after \"select all\" */\n    get entire_sheet() {\n        return this.entire_row && this.entire_column;\n    }\n    /** returns flag indicating this range includes infinite rows */\n    get entire_column() {\n        return (this.start_.row === Infinity);\n    }\n    /** returns flag indicating this range includes infinite columns */\n    get entire_row() {\n        return (this.start_.column === Infinity);\n    }\n    PatchNull(address) {\n        const copy = Object.assign({}, address);\n        if (copy.row === null) {\n            copy.row = Infinity;\n        }\n        if (copy.column === null) {\n            copy.column = Infinity;\n        }\n        return copy;\n    }\n    SetSheetID(id) {\n        this.start_.sheet_id = id;\n    }\n    Normalize() {\n        /*\n        let columns = [this.start.column, this.end.column].sort((a, b) => a-b);\n        let rows = [this.start.row, this.end.row].sort((a, b) => a-b);\n    \n        this.start_ = {row: rows[0], column: columns[0]};\n        this.end = {row:rows[1], column: columns[1]};\n        */\n        // we need to bind the element and the absolute/relative status\n        // so sorting is too simple\n        const start = Object.assign({}, this.start_);\n        const end = Object.assign({}, this.end_);\n        /*\n        const start = {\n          sheet_id: this.start_.sheet_id,\n          row: this.start_.row,\n          column: this.start_.column,\n          absolute_column: this.start_.absolute_column,\n          absolute_row: this.start_.absolute_row };\n    \n        const end = {\n          sheet_id: this.end_.sheet_id, // we don't ever use this, but copy JIC\n          row: this.end_.row,\n          column: this.end_.column,\n          absolute_column: this.end_.absolute_column,\n          absolute_row: this.end_.absolute_row };\n        */\n        // swap row\n        if (start.row === Infinity || end.row === Infinity) {\n            start.row = end.row = Infinity;\n        }\n        else if (start.row > end.row) {\n            start.row = this.end_.row;\n            start.absolute_row = this.end_.absolute_row;\n            end.row = this.start_.row;\n            end.absolute_row = this.start_.absolute_row;\n        }\n        // swap column\n        if (start.column === Infinity || end.column === Infinity) {\n            start.column = end.column = Infinity;\n        }\n        else if (start.column > end.column) {\n            start.column = this.end_.column;\n            start.absolute_column = this.end_.absolute_column;\n            end.column = this.start_.column;\n            end.absolute_column = this.start_.absolute_column;\n        }\n        this.start_ = start;\n        this.end_ = end;\n    }\n    /** returns the top-left cell in the area */\n    TopLeft() {\n        const address = { row: 0, column: 0 };\n        if (!this.entire_row)\n            address.column = this.start.column;\n        if (!this.entire_column)\n            address.row = this.start.row;\n        return address;\n    }\n    /** returns the bottom-right cell in the area */\n    BottomRight() {\n        const address = { row: 0, column: 0 };\n        if (!this.entire_row)\n            address.column = this.end.column;\n        if (!this.entire_column)\n            address.row = this.end.row;\n        return address;\n    }\n    ContainsRow(row) {\n        return this.entire_column || (row >= this.start_.row && row <= this.end_.row);\n    }\n    ContainsColumn(column) {\n        return this.entire_row || (column >= this.start_.column && column <= this.end_.column);\n    }\n    Contains(address) {\n        return (this.entire_column || (address.row >= this.start_.row && address.row <= this.end_.row))\n            && (this.entire_row || (address.column >= this.start_.column && address.column <= this.end_.column));\n    }\n    /**\n     * returns true if this area completely contains the argument area\n     * (also if areas are ===, as a side effect). note that this returns\n     * true if A contains B, but not vice-versa\n     */\n    ContainsArea(area) {\n        return this.start.column <= area.start.column\n            && this.end.column >= area.end.column\n            && this.start.row <= area.start.row\n            && this.end.row >= area.end.row;\n    }\n    /**\n     * returns true if there's an intersection. note that this won't work\n     * if there are infinities -- needs real area ?\n     */\n    Intersects(area) {\n        return !(area.start.column > this.end.column\n            || this.start.column > area.end.column\n            || area.start.row > this.end.row\n            || this.start.row > area.end.row);\n    }\n    Equals(area) {\n        return area.start_.row === this.start_.row\n            && area.start_.column === this.start_.column\n            && area.end_.row === this.end_.row\n            && area.end_.column === this.end_.column;\n    }\n    Clone() {\n        return new Area(this.start, this.end); // ensure copies\n    }\n    Array() {\n        if (this.entire_column || this.entire_row)\n            throw new Error('can\\'t convert infinite area to array');\n        const array = new Array(this.rows * this.columns);\n        const sheet_id = this.start_.sheet_id;\n        let index = 0;\n        // does this need sheet ID?\n        for (let row = this.start_.row; row <= this.end_.row; row++) {\n            for (let column = this.start_.column; column <= this.end_.column; column++) {\n                array[index++] = { row, column, sheet_id };\n            }\n        }\n        return array;\n    }\n    get left() {\n        const area = new Area(this.start_, this.end_);\n        area.end_.column = area.start_.column;\n        return area;\n    }\n    get right() {\n        const area = new Area(this.start_, this.end_);\n        area.start_.column = area.end_.column;\n        return area;\n    }\n    get top() {\n        const area = new Area(this.start_, this.end_);\n        area.end_.row = area.start_.row;\n        return area;\n    }\n    get bottom() {\n        const area = new Area(this.start_, this.end_);\n        area.start_.row = area.end_.row;\n        return area;\n    }\n    /** shifts range in place */\n    Shift(rows, columns) {\n        this.start_.row += rows;\n        this.start_.column += columns;\n        this.end_.row += rows;\n        this.end_.column += columns;\n        return this; // fluent\n    }\n    /** Resizes range in place so that it includes the given address */\n    ConsumeAddress(addr) {\n        if (!this.entire_row) {\n            if (addr.column < this.start_.column)\n                this.start_.column = addr.column;\n            if (addr.column > this.end_.column)\n                this.end_.column = addr.column;\n        }\n        if (!this.entire_column) {\n            if (addr.row < this.start_.row)\n                this.start_.row = addr.row;\n            if (addr.row > this.end_.row)\n                this.end_.row = addr.row;\n        }\n    }\n    /** Resizes range in place so that it includes the given area (merge) */\n    ConsumeArea(area) {\n        this.ConsumeAddress(area.start);\n        this.ConsumeAddress(area.end);\n    }\n    /** resizes range in place (updates end) */\n    Resize(rows, columns) {\n        this.end_.row = this.start_.row + rows - 1;\n        this.end_.column = this.start_.column + columns - 1;\n        return this; // fluent\n    }\n    Iterate(f) {\n        if (this.entire_column || this.entire_row) {\n            console.warn(`don't iterate infinite area`);\n            return;\n        }\n        for (let c = this.start_.column; c <= this.end_.column; c++) {\n            for (let r = this.start_.row; r <= this.end_.row; r++) {\n                f({ column: c, row: r, sheet_id: this.start_.sheet_id });\n            }\n        }\n    }\n    /* *\n     * testing: we may have to polyfill for IE11, or just not use it at\n     * all, depending on support level... but it works OK (kind of a clumsy\n     * implementation though).\n     *\n     * as it turns out we don't really use iteration that much (I thought\n     * we did) so it's probably not worth the polyfill...\n     *\n     * /\n    public next(): IteratorResult<ICellAddress> {\n  \n      // sanity\n  \n      if (this.entire_column || this.entire_row) {\n        console.warn('don\\'t iterate over infinte range');\n        return { value: undefined, done: true };\n      }\n  \n      // return current, unless it's OOB; if so, advance\n  \n      if (this.iterator_index.column > this.end.column) {\n        this.iterator_index.column = this.start_.column;\n        this.iterator_index.row++;\n  \n        if (this.iterator_index.row > this.end.row) {\n          this.ResetIterator();\n          return { value: undefined, done: true };\n        }\n  \n      }\n  \n      const result = { value: { ...this.iterator_index }, done: false };\n      this.iterator_index.column++;\n  \n      return result;\n    }\n  \n    public [Symbol.iterator](): IterableIterator <ICellAddress> {\n      return this;\n    }\n    */\n    /**\n     * returns the range in A1-style spreadsheet addressing. if the\n     * entire sheet is selected, returns nothing (there's no way to\n     * express that in A1 notation). returns the row numbers for entire\n     * columns and vice-versa for rows.\n     */\n    get spreadsheet_label() {\n        let s;\n        if (this.entire_sheet)\n            return '';\n        if (this.entire_column) {\n            s = Area.ColumnToLabel(this.start_.column);\n            s += ':' + Area.ColumnToLabel(this.end_.column);\n            return s;\n        }\n        if (this.entire_row) {\n            s = String(this.start_.row + 1);\n            s += ':' + (this.end_.row + 1);\n            return s;\n        }\n        s = Area.CellAddressToLabel(this.start_);\n        if (this.columns > 1 || this.rows > 1)\n            return s + ':' + Area.CellAddressToLabel(this.end_);\n        return s;\n    }\n    /**\n     * FIXME: is this different than what would be returned if\n     * we just used the default json serializer? (...)\n     */\n    toJSON() {\n        return {\n            start: Object.assign({}, this.start_),\n            end: Object.assign({}, this.end_),\n        };\n        /*\n        return {\n          start: {\n            row: this.start.row,\n            absolute_row: this.start.absolute_row,\n            column: this.start.column,\n            absolute_column: this.start.absolute_column,\n          },\n          end: {\n            row: this.end.row,\n            absolute_row: this.end.absolute_row,\n            column: this.end.column,\n            absolute_column: this.end.absolute_column,\n          },\n        };\n        */\n    }\n}\n\n\n//# sourceURL=webpack://treb/./treb-base-types/src/area.ts?");

/***/ }),

/***/ "./treb-base-types/src/basic_types.ts":
/*!********************************************!*\
  !*** ./treb-base-types/src/basic_types.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * utility types collected from various other files,\n * attempting to consolidate\n */\n\n\n\n//# sourceURL=webpack://treb/./treb-base-types/src/basic_types.ts?");

/***/ }),

/***/ "./treb-base-types/src/cell.ts":
/*!*************************************!*\
  !*** ./treb-base-types/src/cell.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ValidationType\": () => (/* binding */ ValidationType),\n/* harmony export */   \"Cell\": () => (/* binding */ Cell)\n/* harmony export */ });\n/* harmony import */ var _value_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value-type */ \"./treb-base-types/src/value-type.ts\");\n// import { Parser } from 'treb-parser';\n\n/**\n * restructuring from the old system, which had lots of separate arrays for\n * things. for the most part I think having a single array (or object) with\n * objects will be more useful (if not necessarily more efficient). the\n * standout case where this will be inefficient is in passing data to a\n * calculation service, where style information is not useful.\n *\n * things that are in the cell class:\n *  - raw data (formula or value)\n *  - formatted representation\n *  - type (data type including formula or value, implicitly)\n *  - array pointer -- if this cell is part of an array, the array object\n *\n * things that are NOT in the cell class:\n *  - raw per-cell style information. this is in a separate array (object).\n */\n/* *\n * I _think_ using enums is faster. I'm not actually sure about that, though.\n * it stands to reason that a single int compare is faster than a string\n * compare, but you never know with javascript. undefined preferred over null.\n * formula implies a string.\n *\n * undefined is 0 so we can test it as falsy.\n *\n * we're passing this type information out to calculators, so it needs\n * to have known values. DO NOT MODIFY EXISTING INDEXES, or at least be\n * aware of the implications. definitely do not change undefined => 0.\n * /\nexport enum ValueType {\n  undefined = 0,\n\n  // formula is a string; we usually test the first character === '='\n  formula = 1,\n  string = 2,\n  number = 3,\n  boolean = 4,\n\n  // we don't actually use this type, it's here for matching only\n  object = 5,\n\n  // error is a STRING VALUE... object errors are layered on top? is that\n  // correct? (...) it sort of makes sense... since we have separate typing\n  error = 6,\n}\n*/\n/**\n * validation TODO: date, number, boolean, &c\n */\nvar ValidationType;\n(function (ValidationType) {\n    ValidationType[ValidationType[\"List\"] = 0] = \"List\";\n    ValidationType[ValidationType[\"Date\"] = 1] = \"Date\";\n    ValidationType[ValidationType[\"Range\"] = 2] = \"Range\";\n    ValidationType[ValidationType[\"Number\"] = 3] = \"Number\";\n    ValidationType[ValidationType[\"Boolean\"] = 4] = \"Boolean\";\n})(ValidationType || (ValidationType = {}));\nclass Cell {\n    // --- class methods --------------------------------------------------------\n    constructor(value, value_type) {\n        // the value type, js intrinics plus a special type for formula\n        this.type = _value_type__WEBPACK_IMPORTED_MODULE_0__.ValueType.undefined;\n        this.render_dirty = true;\n        if (typeof value !== 'undefined')\n            this.Set(value, value_type);\n    }\n    // --- static methods -------------------------------------------------------\n    static StringToColumn(s) {\n        let index = 0;\n        s = s.toUpperCase();\n        for (let i = 0; i < s.length; i++) {\n            index *= 26;\n            index += (s.charCodeAt(i) - 64);\n        }\n        return index - 1;\n    }\n    /** type guard */\n    ValueIsNumber() {\n        return this.type === _value_type__WEBPACK_IMPORTED_MODULE_0__.ValueType.number;\n    }\n    /** type guard */\n    ValueIsFormula() {\n        return this.type === _value_type__WEBPACK_IMPORTED_MODULE_0__.ValueType.formula;\n    }\n    /** type guard */\n    ValueIsBoolean() {\n        return this.type === _value_type__WEBPACK_IMPORTED_MODULE_0__.ValueType.boolean;\n    }\n    ///\n    /** flush style information and things that rely on it (formatted value) */\n    FlushStyle() {\n        this.formatted = this.rendered_type = this.style = undefined;\n        this.render_dirty = true;\n    }\n    /** flush array information */\n    FlushArray() {\n        this.area = undefined;\n    }\n    /** flush cached data: formatted and calculated */\n    FlushCache() {\n        this.calculated\n            = this.calculated_type\n                = this.formatted\n                    = this.rendered_type\n                        = this.render_function\n                            = this.click_function\n                                = undefined;\n        this.render_dirty = true;\n    }\n    Reset() {\n        this.type = _value_type__WEBPACK_IMPORTED_MODULE_0__.ValueType.undefined;\n        this.value\n            = this.note\n                = this.hyperlink\n                    = this.formatted\n                        = this.rendered_type\n                            = this.style\n                                = this.calculated\n                                    = this.calculated_type\n                                        = this.area\n                                            = this.renderer_data // keep here?\n                                                = this.render_function\n                                                    = this.click_function\n                                                        = undefined;\n        this.render_dirty = true;\n    }\n    Set(value, type = (0,_value_type__WEBPACK_IMPORTED_MODULE_0__.GetValueType)(value)) {\n        this.value = value;\n        this.type = type;\n        this.formatted =\n            this.rendered_type =\n                this.style =\n                    this.calculated =\n                        this.calculated_type =\n                            this.render_function =\n                                this.click_function =\n                                    this.area = undefined;\n        this.render_dirty = true;\n    }\n    /** sets calculated value and flushes cached value */\n    SetCalculatedValue(value, type = (0,_value_type__WEBPACK_IMPORTED_MODULE_0__.GetValueType)(value)) {\n        if (this.calculated === value)\n            return;\n        this.calculated = value;\n        this.calculated_type = type;\n        this.formatted = this.rendered_type = undefined;\n        this.render_dirty = true;\n    }\n    /**\n     * composite method for setting value or error, based on value\n     */\n    SetCalculatedValueOrError(value, type) {\n        if (typeof type === 'undefined') {\n            if (typeof value === 'object' && value.error) {\n                type = _value_type__WEBPACK_IMPORTED_MODULE_0__.ValueType.error;\n                value = value.error;\n            }\n            else {\n                type = (0,_value_type__WEBPACK_IMPORTED_MODULE_0__.GetValueType)(value);\n            }\n        }\n        if (this.calculated === value)\n            return;\n        this.calculated = value;\n        this.calculated_type = type;\n        this.formatted = this.rendered_type = undefined;\n        this.render_dirty = true;\n    }\n    /**\n     * get value -- calculation result (not formatted) or literal. for\n     * literal strings, we strip leading apostrophes (these are used to\n     * prevent parsing of literal strings that look like other things).\n     */\n    GetValue() {\n        if (this.calculated_type)\n            return this.calculated;\n        // if (this.type === ValueType.string &&\n        //    this.value && this.value[0] === '\\'') return this.value.slice(1);\n        // we maintain a type, but typescript won't associate the two so\n        // this test needs to use the actual type\n        if (typeof this.value === 'string' && this.value[0] === '\\'') {\n            return this.value.slice(1);\n        }\n        return this.value;\n    }\n    /* *\n     * new version of GetValue that preserves errors. for non-errors this\n     * behaves identically to the original GetValue. for errors, returns\n     * an error object {error: string};\n     * /\n    public GetValue2(): CellValue | {error: CellValue} {\n      if (this.calculated_type) {\n        return (this.calculated_type === ValueType.error) ?\n          { error: this.calculated } : this.calculated;\n      }\n      // if (this.type === ValueType.string &&\n      //    this.value && this.value[0] === '\\'') return this.value.slice(1);\n      if (typeof this.value === 'string' && this.value[0] === '\\'') { return this.value.slice(1); } // @see GetValue\n  \n      return this.value;\n    }\n    */\n    /* *\n     * we have an issue where a reference to an empty cell winds up returning\n     * a string, goes into a numerical calculation, and slows everything down.\n     *\n     * this is kind of a corner case. it's not that there's a reference to an\n     * empty cell -- that works OK. there's a reference to a cell, which is\n     * itself a reference to an empty cell. that's why it's a function, which\n     * is being returned as a string.\n     *\n     * in this case because it's the function value, I think returning 0 is ok.\n     * BUT, it still might make sense to return undefined.\n     * /\n    public GetValue3(): CellValue|{error: string} { // |FunctionError {\n  \n      // so... what is this? shouldn't this be an object? (...)\n     \n      if (this.calculated_type) {\n        return (this.calculated_type === ValueType.error) ?\n          { error: this.calculated as string } : this.calculated;\n      }\n  \n      if (this.type === ValueType.formula) {\n        // formula, but no calc type... undefined or zero? (...)\n        return 0; // undefined;\n      }\n      // if (this.type === ValueType.string &&\n      //    this.value && this.value[0] === '\\'') return this.value.slice(1);\n      if (typeof this.value === 'string' && this.value[0] === '\\'') { return this.value.slice(1); } // @see GetValue\n  \n      return this.value;\n    }\n    */\n    /**\n     * this function follows the rule of GetValue3, which is: if the type\n     * is a function but there is no calculated value, then return 0.\n     */\n    GetValue4() {\n        if (this.calculated_type) {\n            return {\n                type: this.calculated_type,\n                value: this.calculated,\n            };\n        }\n        if (this.type === _value_type__WEBPACK_IMPORTED_MODULE_0__.ValueType.formula) {\n            return {\n                type: _value_type__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                value: 0,\n            };\n        }\n        return {\n            type: this.type,\n            value: (typeof this.value === 'string' && this.value[0] === '\\'') ? this.value.slice(1) : this.value, // @see GetValue \n        };\n    }\n    /**\n     * set note. set undefined to clear.\n     */\n    SetNote(note) {\n        this.note = note;\n        this.render_dirty = true;\n    }\n    /** sets error (FIXME: error type) */\n    SetCalculationError(err = 'ERR') {\n        this.SetCalculatedValue(err, _value_type__WEBPACK_IMPORTED_MODULE_0__.ValueType.error);\n    }\n    SetArray(area) {\n        this.type = _value_type__WEBPACK_IMPORTED_MODULE_0__.ValueType.undefined;\n        this.value =\n            this.formatted =\n                this.rendered_type =\n                    this.style =\n                        this.hyperlink = // note?\n                            this.calculated =\n                                this.calculated_type = undefined;\n        this.area = area;\n        this.render_dirty = true;\n    }\n    SetArrayHead(area, value) {\n        this.type = (0,_value_type__WEBPACK_IMPORTED_MODULE_0__.GetValueType)(value);\n        this.value = value;\n        this.formatted =\n            this.rendered_type =\n                this.style =\n                    this.calculated =\n                        this.calculated_type = undefined;\n        this.area = area;\n        this.render_dirty = true;\n    }\n}\n\n\n//# sourceURL=webpack://treb/./treb-base-types/src/cell.ts?");

/***/ }),

/***/ "./treb-base-types/src/cells.ts":
/*!**************************************!*\
  !*** ./treb-base-types/src/cells.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IsFlatData\": () => (/* binding */ IsFlatData),\n/* harmony export */   \"IsFlatDataArray\": () => (/* binding */ IsFlatDataArray),\n/* harmony export */   \"IsNestedRowArray\": () => (/* binding */ IsNestedRowArray),\n/* harmony export */   \"Cells\": () => (/* binding */ Cells)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _area__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./area */ \"./treb-base-types/src/area.ts\");\n/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cell */ \"./treb-base-types/src/cell.ts\");\n/* harmony import */ var _value_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./value-type */ \"./treb-base-types/src/value-type.ts\");\n/* harmony import */ var _union__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./union */ \"./treb-base-types/src/union.ts\");\n/**\n * switched to row-major, seems to have no ill effects\n * (not sure if there are benefits yet either)\n */\n\n\n\n\n\n// some type guards for the various data types\nconst IsFlatData = (test) => {\n    return !test.cells;\n};\nconst IsFlatDataArray = (test) => {\n    return (!!test[0]) && IsFlatData(test[0]);\n};\nconst IsNestedRowArray = (test) => {\n    return (!!test[0]) && (test[0].row !== undefined);\n};\n// ...\n/**\n * collection of cells, basically a wrapper around an\n * array, with some accessor and control methods.\n */\nclass Cells {\n    constructor() {\n        /** switching to row-major */\n        this.data = [];\n        // tslint:disable-next-line:variable-name\n        this.rows_ = 0;\n        // tslint:disable-next-line:variable-name\n        this.columns_ = 0;\n    }\n    get rows() { return this.rows_; }\n    get columns() { return this.columns_; }\n    /**\n     * the sheet wants to make sure this row exists, probably because it has\n     * a header. so we will update our dimensions to match. we don't actually\n     * add data.\n     *\n     * this is not serialized. specific headers aren't serialized either, at\n     * the moment, so it's sort of irrelevant. if we start serializing headers,\n     * the deserialization routine can call this function to pad out, so we\n     * don't need to store it here.\n     */\n    EnsureRow(row) {\n        this.rows_ = Math.max(row + 1, this.rows_);\n    }\n    /** @see EnsureRow */\n    EnsureColumn(column) {\n        this.columns_ = Math.max(column + 1, this.columns_);\n    }\n    /**\n     * this class does none of the validation/correction\n     * required when inserting rows/columns. that should\n     * be done by external logic. this method only does\n     * the mechanical work of inserting rows/columns.\n     */\n    InsertColumns(before = 0, count = 1) {\n        // NOTE: iterating a sparse array, in chrome at least, only\n        // hits populated keys. the returned array has the same\n        // indexes. that is very nice.\n        this.data = this.data.map((row) => {\n            if (row.length >= before) {\n                const tmp = row.slice(0, before);\n                let index = before + count;\n                row.slice(before).forEach((column) => tmp[index++] = column);\n                return tmp;\n            }\n            return row;\n        });\n        this.columns_ += count;\n    }\n    DeleteColumns(index, count = 1) {\n        // trap! splice returns _removed_ elements so don't use map()\n        this.data.forEach((row) => row.splice(index, count));\n        this.columns_ -= count;\n    }\n    DeleteRows(index, count = 1) {\n        this.data.splice(index, count);\n        this.rows_ -= count;\n    }\n    /**\n     * this class does none of the validation/correction\n     * required when inserting rows/columns. that should\n     * be done by external logic. this method only does\n     * the mechanical work of inserting rows/columns.\n     */\n    InsertRows(before = 0, count = 1) {\n        const args = [before, 0, []];\n        for (let i = 1; i < count; i++)\n            args.push([]);\n        Array.prototype.splice.apply(this.data, args);\n        this.rows_ += count;\n    }\n    /**\n     * return the given cell or `undefined`, optionally creating\n     * new cells as necessary\n     *\n     * @param create_new always return a cell\n     */\n    GetCell(address, create_new) {\n        const { row, column } = address;\n        if (!this.data[row]) {\n            if (create_new) {\n                this.data[row] = [];\n                this.rows_ = Math.max(this.rows_, row + 1);\n            }\n            else\n                return undefined;\n        }\n        if (!this.data[row][column]) {\n            if (create_new) {\n                this.data[row][column] = new _cell__WEBPACK_IMPORTED_MODULE_1__.Cell();\n                this.columns_ = Math.max(this.columns_, column + 1);\n            }\n        }\n        return this.data[row][column];\n    }\n    /**\n     * apply function to range or address. skips empty cells (for now...)\n     * (already have this function, it's called \"IterateArea\". \"Apply\" is better.)\n     * /\n    public Apply(target: ICellAddress|IArea, func: (cell: Cell) => void): void {\n  \n      if (IsCellAddress(target)) {\n        target = new Area(target);\n      }\n  \n      const start = target.start;\n      const end = target.end;\n  \n      for (let r = start.row; r <= end.row; r++) {\n        if (this.data[r]) {\n          const row = this.data[r];\n          for (let c = start.column; c < end.column; c++) {\n            if (this.data[r][c]) {\n              func.call(undefined, row[c]);\n            }\n          }\n        }\n      }\n  \n    }\n    */\n    /** returns an existing cell or creates a new cell. */\n    EnsureCell(address) {\n        const { row, column } = address;\n        let ref = this.data[row];\n        if (!ref) {\n            this.data[row] = ref = [];\n            this.rows_ = Math.max(this.rows_, row + 1);\n        }\n        let cell = ref[column];\n        if (!cell) {\n            cell = ref[column] = new _cell__WEBPACK_IMPORTED_MODULE_1__.Cell();\n            this.columns_ = Math.max(this.columns_, column + 1);\n        }\n        return cell;\n    }\n    /**\n     * with the update, we assume the passed-in data is row-major.\n     * when reading an older file, transpose.\n     */\n    FromArray(data = [], transpose = false) {\n        this.data = [];\n        let rows = 0;\n        let columns = 0;\n        if (transpose) {\n            columns = data.length;\n            for (let c = 0; c < columns; c++) {\n                const ref = data[c];\n                rows = Math.max(rows, ref.length);\n                for (let r = 0; r < ref.length; r++) {\n                    if (!this.data[r])\n                        this.data[r] = [];\n                    this.data[r][c] = new _cell__WEBPACK_IMPORTED_MODULE_1__.Cell(ref[r]);\n                }\n            }\n        }\n        else {\n            rows = data.length;\n            for (let r = 0; r < rows; r++) {\n                const column = [];\n                const ref = data[r];\n                columns = Math.max(columns, ref.length);\n                for (let c = 0; c < ref.length; c++)\n                    column[c] = new _cell__WEBPACK_IMPORTED_MODULE_1__.Cell(ref[c]);\n                this.data[r] = column;\n            }\n        }\n        this.rows_ = rows;\n        this.columns_ = columns;\n    }\n    FromJSON(data = []) {\n        this.data = [];\n        // handle nested data; fix. we can make the simplifying assumption\n        // that data is either nested, or not, but never both. therefore, we\n        // just need to check the first element.\n        if (!IsFlatDataArray(data)) {\n            const new_data = [];\n            if (IsNestedRowArray(data)) {\n                for (const block of data) {\n                    for (const cell of block.cells) {\n                        new_data.push(Object.assign(Object.assign({}, cell), { row: block.row }));\n                    }\n                }\n            }\n            else {\n                for (const block of data) {\n                    for (const cell of block.cells) {\n                        new_data.push(Object.assign(Object.assign({}, cell), { column: block.column }));\n                    }\n                }\n            }\n            data = new_data;\n        }\n        /*\n        if (data[0] && data[0].cells) {\n    \n          // console.info('reading nested data');\n    \n          const new_data: any[] = [];\n          for (const element of data) {\n            if (typeof element.row !== 'undefined') {\n              for (const cell of element.cells) {\n                new_data.push({row: element.row, ...cell});\n              }\n            }\n            else if (typeof element.column !== 'undefined') {\n              for (const cell of element.cells) {\n                new_data.push({column: element.column, ...cell});\n              }\n            }\n          }\n          data = new_data;\n    \n        }\n        */\n        for (const obj of data) {\n            if (!this.data[obj.row])\n                this.data[obj.row] = [];\n            const cell = new _cell__WEBPACK_IMPORTED_MODULE_1__.Cell(obj.value);\n            if (typeof obj.calculated !== 'undefined') {\n                // cell.calculated = obj.calculated;\n                // cell.calculated_type = obj.calculated_type;\n                cell.SetCalculatedValue(obj.calculated, obj.calculated_type);\n            }\n            if (typeof obj.note !== 'undefined') {\n                cell.note = obj.note;\n            }\n            if (typeof obj.hyperlink !== 'undefined') {\n                cell.hyperlink = obj.hyperlink;\n            }\n            // stop wrecking arrays\n            if (this.data[obj.row][obj.column] && this.data[obj.row][obj.column].area) {\n                cell.area = this.data[obj.row][obj.column].area;\n            }\n            this.data[obj.row][obj.column] = cell;\n            // since we are serializing the array data (when storing calculated\n            // values), is this getting called every time? I think it might be...\n            // we're fixing the former, anyway.\n            if (obj.area) {\n                const area = new _area__WEBPACK_IMPORTED_MODULE_0__.Area(obj.area.start, obj.area.end); // isn't there a clone method?\n                for (let row = area.start.row; row <= area.end.row; row++) {\n                    for (let column = area.start.column; column <= area.end.column; column++) {\n                        if (!this.data[row])\n                            this.data[row] = [];\n                        if (!this.data[row][column])\n                            this.data[row][column] = new _cell__WEBPACK_IMPORTED_MODULE_1__.Cell();\n                        this.data[row][column].area = area;\n                    }\n                }\n            }\n            if (obj.merge_area) {\n                const merge_area = new _area__WEBPACK_IMPORTED_MODULE_0__.Area(obj.merge_area.start, obj.merge_area.end);\n                for (let row = merge_area.start.row; row <= merge_area.end.row; row++) {\n                    for (let column = merge_area.start.column; column <= merge_area.end.column; column++) {\n                        if (!this.data[row])\n                            this.data[row] = [];\n                        if (!this.data[row][column])\n                            this.data[row][column] = new _cell__WEBPACK_IMPORTED_MODULE_1__.Cell();\n                        this.data[row][column].merge_area = merge_area;\n                    }\n                }\n            }\n            if (obj.validation) {\n                cell.validation = obj.validation;\n            }\n            //if (obj.locked) {\n            //  cell.locked = obj.locked;\n            //}\n        }\n        this.rows_ = this.data.length;\n        this.columns_ = this.data.reduce((max, row) => Math.max(max, row.length), 0);\n    }\n    toJSON(options = {}) {\n        let start_column = 0;\n        let start_row = 0;\n        let end_row = this.data.length - 1;\n        let end_column;\n        if (options.subset) {\n            start_column = options.subset.start.column;\n            start_row = options.subset.start.row;\n            end_row = options.subset.end.row;\n        }\n        const data = [];\n        let last_row = -1;\n        let last_col = -1;\n        // unifying [FIXME: move into class]\n        // FIXME: why not use the original, instead of requiring a method\n        // call, and then re-order? that also makes it easier to pivot\n        // (order by rows or columns)\n        // ... (we did that)\n        const row_keys = {};\n        const column_keys = {};\n        for (let row = start_row; row <= end_row; row++) {\n            if (this.data[row]) {\n                const ref = this.data[row];\n                end_column = ref.length - 1;\n                if (options.subset)\n                    end_column = options.subset.end.column;\n                for (let column = start_column; column <= end_column; column++) {\n                    const cell = ref[column];\n                    // because only the array head will have a value, this test\n                    // will filter out empty cells and non-head array cells\n                    // update: also add merge heads\n                    const merge_head = cell && cell.merge_area\n                        && cell.merge_area.start.row === row\n                        && cell.merge_area.start.column === column;\n                    const array_head = cell && cell.area\n                        && cell.area.start.row === row\n                        && cell.area.start.column === column;\n                    const is_empty = cell ? (cell.type === _value_type__WEBPACK_IMPORTED_MODULE_2__.ValueType.string && !cell.value) : true;\n                    // NOTE: we added the check on calculated && calculated_value,\n                    // so we preserve rendered data for arrays. but that actually writes\n                    // the array data as well, which is unnecessary (?) -- FIXME\n                    //\n                    // actually, check how that's interpreted on load, because it might\n                    // break if we have a value but not the array area (...)\n                    // FIXME: what's up with this? we check style? (...) can't recall\n                    // why we do that, because we should ensure empty cells if there's\n                    // a style (separately).\n                    // NOTE: switching test from \"calculated\" to \"calculated type\": this\n                    // should preserve zeros.\n                    if (cell && (!is_empty || options.preserve_empty_strings) &&\n                        (merge_head || cell.type || (cell.calculated_type && options.expand_arrays) ||\n                            (cell.calculated_type && options.calculated_value) ||\n                            (cell.validation) ||\n                            (options.decorated_cells && cell.style &&\n                                (cell.style.fill || cell.style.border_bottom ||\n                                    cell.style.border_top || cell.style.border_left || cell.style.border_right)))) {\n                        const obj = { row, column, value: cell.value };\n                        if (cell.note) {\n                            obj.note = cell.note;\n                        }\n                        if (cell.hyperlink) {\n                            obj.hyperlink = cell.hyperlink;\n                        }\n                        if (options.preserve_type)\n                            obj.type = cell.type;\n                        if (options.sheet_id)\n                            obj.sheet_id = options.sheet_id;\n                        if (options.calculated_value &&\n                            typeof cell.calculated !== 'undefined') { // && cell.calculated_type !== ValueType.error) {\n                            obj.calculated = cell.calculated;\n                            // always preserve error type, because we can't infer\n                            if (options.preserve_type || cell.calculated_type === _value_type__WEBPACK_IMPORTED_MODULE_2__.ValueType.error) {\n                                obj.calculated_type = cell.calculated_type;\n                            }\n                        }\n                        if (cell.area && array_head) {\n                            obj.area = cell.area.toJSON();\n                        }\n                        if (cell.merge_area) {\n                            obj.merge_area = cell.merge_area.toJSON();\n                        }\n                        if (cell.validation) {\n                            obj.validation = cell.validation; // safe? \n                        }\n                        //if (cell.locked) {\n                        //  obj.locked = cell.locked; // d'oh\n                        //}\n                        if (options.cell_style_refs &&\n                            options.cell_style_refs[column] &&\n                            options.cell_style_refs[column][row]) {\n                            obj.style_ref = options.cell_style_refs[column][row];\n                            options.cell_style_refs[column][row] = 0; // consume\n                            // console.info(`consume @ ${column}, ${row}: ${obj.style_ref } => ${options.cell_style_refs[column][row]}`);\n                        }\n                        row_keys[row] = row;\n                        column_keys[column] = column;\n                        last_row = Math.max(row, last_row);\n                        last_col = Math.max(column, last_col);\n                        data.push(obj);\n                    }\n                }\n            }\n        }\n        if (options.nested) {\n            const row_key_map = Object.keys(row_keys);\n            const col_key_map = Object.keys(column_keys);\n            // extra test to make sure it's not empty\n            if ((row_key_map.length <= col_key_map.length) && row_key_map.length) {\n                const cells = {};\n                // use rows\n                const new_data = [];\n                for (const element of data) {\n                    const { row } = element, remainder = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(element, [\"row\"]);\n                    if (!cells[element.row])\n                        cells[element.row] = [];\n                    cells[element.row].push(remainder);\n                }\n                for (const key of row_key_map) {\n                    const row = Number(key);\n                    new_data.push({ row, cells: cells[row] });\n                }\n                return { data: new_data, rows: last_row, columns: last_col + 1 };\n            }\n            else if (col_key_map.length) {\n                const cells = {};\n                // use columns\n                const new_data = [];\n                for (const element of data) {\n                    const { column } = element, remainder = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(element, [\"column\"]);\n                    if (!cells[element.column])\n                        cells[element.column] = [];\n                    cells[element.column].push(remainder);\n                }\n                for (const key of col_key_map) {\n                    const column = Number(key);\n                    new_data.push({ column, cells: cells[column] });\n                }\n                return { data: new_data, rows: last_row, columns: last_col + 1 };\n            }\n        }\n        return { data, rows: last_row + 1, columns: last_col + 1 };\n    }\n    GetAll(transpose = false) {\n        return this.GetRange({ row: 0, column: 0 }, { row: this.rows_ - 1, column: this.columns_ - 1 }, transpose);\n    }\n    /** simply cannot make this work with overloads (prove me wrong) */\n    Normalize2(from, to) {\n        if (from.column === Infinity) {\n            from = Object.assign(Object.assign({}, from), { column: 0 });\n        }\n        if (from.row === Infinity) {\n            from = Object.assign(Object.assign({}, from), { row: 0 });\n        }\n        if (to.column === Infinity) {\n            to = Object.assign(Object.assign({}, to), { column: this.columns_ - 1 });\n        }\n        if (to.row === Infinity) {\n            to = Object.assign(Object.assign({}, to), { row: this.rows_ - 1 });\n        }\n        return { from, to };\n    }\n    /** simply cannot make this work with overloads (prove me wrong) */\n    Normalize1(from) {\n        if (from.column === Infinity) {\n            from = Object.assign(Object.assign({}, from), { column: 0 });\n        }\n        if (from.row === Infinity) {\n            from = Object.assign(Object.assign({}, from), { row: 0 });\n        }\n        return from;\n    }\n    /**\n     * get raw values (i.e. not calculated). anything outside of actual\n     * range will be undefined OR not populated.\n     *\n     * to match GetRange, we return a single value in the case of a single cell,\n     * or a matrix.\n     *\n     * NOTE that I'm not sure this is good behavior. if you're going to\n     * return a single value for one cell, you should return a vector for\n     * a single row OR a single column. alternatively, you should always\n     * return a matrix.\n     *\n     * @param from\n     * @param to\n     * @param transpose\n     */\n    RawValue(from, to = from) {\n        ({ from, to } = this.Normalize2(from, to));\n        if (from.row === to.row && from.column === to.column) {\n            if (this.data[from.row] && this.data[from.row][from.column]) {\n                return this.data[from.row][from.column].value;\n            }\n            return undefined;\n        }\n        const result = [];\n        // grab rows\n        const rows = this.data.slice(from.row, to.row + 1);\n        // now columns\n        const start = from.column;\n        const end = to.column + 1;\n        for (const source of rows) {\n            const target = [];\n            for (let column = start, index = 0; column < end; column++, index++) {\n                const cell = source[column];\n                target.push(cell ? cell.value : undefined);\n            }\n            result.push(target);\n        }\n        return result;\n    }\n    /** gets range as values */\n    GetRange(from, to, transpose = false) {\n        if (to) {\n            ({ from, to } = this.Normalize2(from, to));\n        }\n        else {\n            from = this.Normalize1(from);\n        }\n        // console.info(\"getrange\", from, to, transpose);\n        if (!to || from === to || (from.column === to.column && from.row === to.row)) {\n            if (this.data[from.row] && this.data[from.row][from.column]) {\n                return this.data[from.row][from.column].GetValue();\n            }\n            return undefined;\n        }\n        const value = [];\n        if (transpose) {\n            for (let c = from.column; c <= to.column; c++) {\n                const column = [];\n                for (let r = from.row; r <= to.row; r++) {\n                    if (this.data[r] && this.data[r][c])\n                        column.push(this.data[r][c].GetValue());\n                    else\n                        column.push(undefined);\n                }\n                value.push(column);\n            }\n        }\n        else {\n            for (let r = from.row; r <= to.row; r++) {\n                const row = [];\n                for (let c = from.column; c <= to.column; c++) {\n                    if (this.data[r] && this.data[r][c])\n                        row.push(this.data[r][c].GetValue());\n                    else\n                        row.push(undefined);\n                }\n                value.push(row);\n            }\n        }\n        // console.info(value)\n        return value;\n    }\n    /* *\n     * updated version of GetRange that preserves errors, by calling\n     * the GetValue2 cell function.\n     * /\n    public GetRange2(from: ICellAddress, to?: ICellAddress, transpose = false) {\n  \n      if (!to || from === to || (from.column === to.column && from.row === to.row )){\n        if (this.data[from.row] && this.data[from.row][from.column]){\n          return this.data[from.row][from.column].GetValue2();\n        }\n        return undefined;\n      }\n  \n      const value = [];\n  \n      if (transpose){\n        for ( let c = from.column; c <= to.column; c++ ){\n          const column = [];\n          for ( let r = from.row; r <= to.row; r++ ){\n            if (this.data[r] && this.data[r][c]) column.push(this.data[r][c].GetValue2());\n            else column.push(undefined);\n          }\n          value.push(column);\n        }\n      }\n      else {\n        for ( let r = from.row; r <= to.row; r++ ){\n          const row = [];\n          for ( let c = from.column; c <= to.column; c++ ){\n            if (this.data[r] && this.data[r][c]) row.push(this.data[r][c].GetValue2());\n            else row.push(undefined);\n          }\n          value.push(row);\n        }\n      }\n  \n      return value;\n  \n    }\n    */\n    GetRange4(from, to = from, transpose = false) {\n        ({ from, to } = this.Normalize2(from, to));\n        if (from.row === to.row && from.column === to.column) {\n            if (this.data[from.row] && this.data[from.row][from.column]) {\n                return this.data[from.row][from.column].GetValue4();\n            }\n            return { value: undefined, type: _value_type__WEBPACK_IMPORTED_MODULE_2__.ValueType.undefined };\n        }\n        const value = [];\n        if (transpose) {\n            for (let c = from.column; c <= to.column; c++) {\n                const column = [];\n                for (let r = from.row; r <= to.row; r++) {\n                    if (this.data[r] && this.data[r][c])\n                        column.push(this.data[r][c].GetValue4());\n                    else\n                        column.push((0,_union__WEBPACK_IMPORTED_MODULE_3__.UndefinedUnion)());\n                }\n                value.push(column);\n            }\n        }\n        else {\n            for (let r = from.row; r <= to.row; r++) {\n                const row = [];\n                for (let c = from.column; c <= to.column; c++) {\n                    if (this.data[r] && this.data[r][c])\n                        row.push(this.data[r][c].GetValue4());\n                    else\n                        row.push((0,_union__WEBPACK_IMPORTED_MODULE_3__.UndefinedUnion)());\n                }\n                value.push(row);\n            }\n        }\n        return value;\n    }\n    /**\n     * apply function to address/area\n     */\n    Apply(area, f, create_missing_cells = false) {\n        // allow single address\n        if ((0,_area__WEBPACK_IMPORTED_MODULE_0__.IsCellAddress)(area)) {\n            area = new _area__WEBPACK_IMPORTED_MODULE_0__.Area(area);\n        }\n        // why not just cap? (...)\n        if (area.entire_column || area.entire_row) {\n            throw new Error(`don't iterate infinite cells`);\n        }\n        // these are accessors so we don't want them in the loop\n        const start = area.start;\n        const end = area.end;\n        if (create_missing_cells) {\n            for (let r = start.row; r <= end.row; r++) {\n                if (!this.data[r])\n                    this.data[r] = [];\n                const row = this.data[r];\n                for (let c = start.column; c <= end.column; c++) {\n                    if (!row[c])\n                        row[c] = new _cell__WEBPACK_IMPORTED_MODULE_1__.Cell();\n                    f(row[c], c, r);\n                }\n            }\n        }\n        else {\n            // we can loop over indexes that don't exist, just check for existence\n            for (let r = start.row; r <= end.row; r++) {\n                if (this.data[r]) {\n                    const row = this.data[r];\n                    for (let c = start.column; c <= end.column; c++) {\n                        if (row[c])\n                            f(row[c], c, r);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * set area. shortcut to reduce overhead. consolidates single value\n     * and array value methods, although the implementation is separate.\n     *\n     * watch out for typed arrays, which do not satisfy Array.isArray\n     *\n     * when would this function get a 1D typed array? can't figure that out.\n     * might have something to do with simulation data, but not sure.\n     *\n     * just drop for the time being.\n     *\n     */\n    SetArea(area, values) {\n        if (ArrayBuffer.isView(values)) {\n            throw new Error('ABIV');\n        }\n        if (Array.isArray(values)) { // || ArrayBuffer.isView(values)) {\n            for (let r = area.start.row, i = 0; r <= area.end.row; r++, i++) {\n                if (!this.data[r])\n                    this.data[r] = [];\n                const row = this.data[r];\n                if (values[i]) {\n                    for (let c = area.start.column, j = 0; c <= area.end.column; c++, j++) {\n                        if (!row[c])\n                            row[c] = new _cell__WEBPACK_IMPORTED_MODULE_1__.Cell();\n                        row[c].Set(values[i][j]); // undefined should be implicit\n                    }\n                }\n            }\n        }\n        else {\n            const value_type = (0,_value_type__WEBPACK_IMPORTED_MODULE_2__.GetValueType)(values); // otherwise we'd just call it every time\n            for (let r = area.start.row; r <= area.end.row; r++) {\n                if (!this.data[r])\n                    this.data[r] = [];\n                const row = this.data[r];\n                for (let c = area.start.column; c <= area.end.column; c++) {\n                    if (!row[c])\n                        row[c] = new _cell__WEBPACK_IMPORTED_MODULE_1__.Cell();\n                    row[c].Set(values, value_type);\n                }\n            }\n        }\n        this.rows_ = Math.max(this.rows_, area.end.row + 1);\n        this.columns_ = Math.max(this.columns_, area.end.column + 1);\n    }\n    /**\n     * iterates over all cells (using loops) and runs function per-cell.\n     * FIXME: switch to indexing on empty indexes? (...)\n     */\n    IterateAll(func) {\n        /*\n        const row_keys = Object.keys(this.data);\n        for (const row of row_keys){\n          const n_row = Number(row) || 0;\n          const column_keys = Object.keys(this.data[n_row]);\n          for (const column_key of column_keys){\n            f(this.data[n_row][Number(column_key)]);\n          }\n        }\n        */\n        for (const row of this.data) {\n            if (row) {\n                for (const cell of row) {\n                    if (cell) {\n                        func(cell);\n                    }\n                }\n            }\n        }\n    }\n    /** moved from sheet, so we can do it non-functional style (for perf) */\n    FlushCellStyles() {\n        for (const row of this.data) {\n            if (row) {\n                for (const cell of row) {\n                    if (cell) {\n                        cell.FlushStyle();\n                    }\n                }\n            }\n        }\n    }\n    /** moved from sheet, so we can do it non-functional style (for perf) */\n    FlushCachedValues() {\n        for (const row of this.data) {\n            if (row) {\n                for (const cell of row) {\n                    if (cell) {\n                        cell.FlushCache();\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://treb/./treb-base-types/src/cells.ts?");

/***/ }),

/***/ "./treb-base-types/src/color.ts":
/*!**************************************!*\
  !*** ./treb-base-types/src/color.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Color\": () => (/* binding */ Color)\n/* harmony export */ });\n/**\n * utility functions, primarily for adjusting lightness. since we generally\n * traffic in RGB (or symbolic colors) that requires translating to/from HSL.\n */\nclass ColorFunctions {\n    /** darken rgb color by amount (%), optionally relative */\n    Darken(r, g, b, amount, relative = false) {\n        // eslint-disable-next-line prefer-const\n        let { h, s, l } = this.RGBToHSL(r, g, b);\n        if (relative)\n            l -= l * amount / 100;\n        else\n            l -= amount / 100;\n        l = Math.max(0, Math.min(1, l));\n        return this.HSLToRGB(h, s, l);\n    }\n    /** lighten rgb color by amount (%), optionally relative */\n    Lighten(r, g, b, amount, relative = false) {\n        // eslint-disable-next-line prefer-const\n        let { h, s, l } = this.RGBToHSL(r, g, b);\n        if (relative)\n            l += l * amount / 100;\n        else\n            l += amount / 100;\n        l = Math.max(0, Math.min(1, l));\n        return this.HSLToRGB(h, s, l);\n    }\n    RGBToHSL(r, g, b) {\n        r /= 255;\n        g /= 255;\n        b /= 255;\n        const max = Math.max(r, g, b);\n        const min = Math.min(r, g, b);\n        let h = 0;\n        let s = 0;\n        const l = (max + min) / 2;\n        if (max === min) {\n            h = s = 0;\n        }\n        else {\n            const d = max - min;\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n            switch (max) {\n                case r:\n                    h = (g - b) / d + (g < b ? 6 : 0);\n                    break;\n                case g:\n                    h = (b - r) / d + 2;\n                    break;\n                case b:\n                    h = (r - g) / d + 4;\n                    break;\n            }\n            h /= 6;\n        }\n        return { h: h * 360, s, l };\n    }\n    HSLToRGB(h, s, l) {\n        let r;\n        let g;\n        let b;\n        if (s === 0) {\n            r = g = b = l;\n        }\n        else {\n            h = h / 360;\n            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n            const p = 2 * l - q;\n            r = this.HueToRGB(p, q, h + 1 / 3);\n            g = this.HueToRGB(p, q, h);\n            b = this.HueToRGB(p, q, h - 1 / 3);\n        }\n        return {\n            r: Math.round(r * 255),\n            g: Math.round(g * 255),\n            b: Math.round(b * 255),\n        };\n    }\n    HueToRGB(p, q, t) {\n        if (t < 0)\n            t += 1;\n        if (t > 1)\n            t -= 1;\n        if (t < 1 / 6)\n            return p + (q - p) * 6 * t;\n        if (t < 1 / 2)\n            return q;\n        if (t < 2 / 3)\n            return p + (q - p) * (2 / 3 - t) * 6;\n        return p;\n    }\n}\nconst Color = new ColorFunctions();\n\n\n//# sourceURL=webpack://treb/./treb-base-types/src/color.ts?");

/***/ }),

/***/ "./treb-base-types/src/import.ts":
/*!***************************************!*\
  !*** ./treb-base-types/src/import.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\n\n\n//# sourceURL=webpack://treb/./treb-base-types/src/import.ts?");

/***/ }),

/***/ "./treb-base-types/src/index.ts":
/*!**************************************!*\
  !*** ./treb-base-types/src/index.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Area\": () => (/* reexport safe */ _area__WEBPACK_IMPORTED_MODULE_0__.Area),\n/* harmony export */   \"IsCellAddress\": () => (/* reexport safe */ _area__WEBPACK_IMPORTED_MODULE_0__.IsCellAddress),\n/* harmony export */   \"Cell\": () => (/* reexport safe */ _cell__WEBPACK_IMPORTED_MODULE_1__.Cell),\n/* harmony export */   \"ValidationType\": () => (/* reexport safe */ _cell__WEBPACK_IMPORTED_MODULE_1__.ValidationType),\n/* harmony export */   \"Cells\": () => (/* reexport safe */ _cells__WEBPACK_IMPORTED_MODULE_2__.Cells),\n/* harmony export */   \"IsFlatData\": () => (/* reexport safe */ _cells__WEBPACK_IMPORTED_MODULE_2__.IsFlatData),\n/* harmony export */   \"IsFlatDataArray\": () => (/* reexport safe */ _cells__WEBPACK_IMPORTED_MODULE_2__.IsFlatDataArray),\n/* harmony export */   \"IsNestedRowArray\": () => (/* reexport safe */ _cells__WEBPACK_IMPORTED_MODULE_2__.IsNestedRowArray),\n/* harmony export */   \"Localization\": () => (/* reexport safe */ _localization__WEBPACK_IMPORTED_MODULE_3__.Localization),\n/* harmony export */   \"Rectangle\": () => (/* reexport safe */ _rectangle__WEBPACK_IMPORTED_MODULE_5__.Rectangle),\n/* harmony export */   \"Style\": () => (/* reexport safe */ _style__WEBPACK_IMPORTED_MODULE_6__.Style),\n/* harmony export */   \"TextPartFlag\": () => (/* reexport safe */ _text_part__WEBPACK_IMPORTED_MODULE_7__.TextPartFlag),\n/* harmony export */   \"Box\": () => (/* reexport safe */ _union__WEBPACK_IMPORTED_MODULE_9__.Box),\n/* harmony export */   \"Is2DArray\": () => (/* reexport safe */ _union__WEBPACK_IMPORTED_MODULE_9__.Is2DArray),\n/* harmony export */   \"UndefinedUnion\": () => (/* reexport safe */ _union__WEBPACK_IMPORTED_MODULE_9__.UndefinedUnion),\n/* harmony export */   \"UnionIs\": () => (/* reexport safe */ _union__WEBPACK_IMPORTED_MODULE_9__.UnionIs),\n/* harmony export */   \"GetValueType\": () => (/* reexport safe */ _value_type__WEBPACK_IMPORTED_MODULE_10__.GetValueType),\n/* harmony export */   \"ValueType\": () => (/* reexport safe */ _value_type__WEBPACK_IMPORTED_MODULE_10__.ValueType),\n/* harmony export */   \"DefaultTheme\": () => (/* reexport safe */ _theme__WEBPACK_IMPORTED_MODULE_11__.DefaultTheme),\n/* harmony export */   \"LoadThemeProperties\": () => (/* reexport safe */ _theme__WEBPACK_IMPORTED_MODULE_11__.LoadThemeProperties),\n/* harmony export */   \"ThemeColor\": () => (/* reexport safe */ _theme__WEBPACK_IMPORTED_MODULE_11__.ThemeColor),\n/* harmony export */   \"ThemeColor2\": () => (/* reexport safe */ _theme__WEBPACK_IMPORTED_MODULE_11__.ThemeColor2),\n/* harmony export */   \"Color\": () => (/* reexport safe */ _color__WEBPACK_IMPORTED_MODULE_12__.Color)\n/* harmony export */ });\n/* harmony import */ var _area__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./area */ \"./treb-base-types/src/area.ts\");\n/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cell */ \"./treb-base-types/src/cell.ts\");\n/* harmony import */ var _cells__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cells */ \"./treb-base-types/src/cells.ts\");\n/* harmony import */ var _localization__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./localization */ \"./treb-base-types/src/localization.ts\");\n/* harmony import */ var _basic_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./basic_types */ \"./treb-base-types/src/basic_types.ts\");\n/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rectangle */ \"./treb-base-types/src/rectangle.ts\");\n/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./style */ \"./treb-base-types/src/style.ts\");\n/* harmony import */ var _text_part__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./text_part */ \"./treb-base-types/src/text_part.ts\");\n/* harmony import */ var _import__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./import */ \"./treb-base-types/src/import.ts\");\n/* harmony import */ var _union__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./union */ \"./treb-base-types/src/union.ts\");\n/* harmony import */ var _value_type__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./value-type */ \"./treb-base-types/src/value-type.ts\");\n/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./theme */ \"./treb-base-types/src/theme.ts\");\n/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./color */ \"./treb-base-types/src/color.ts\");\n/* harmony import */ var _layout__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./layout */ \"./treb-base-types/src/layout.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// import * as Style from './style';\n// export { Style };\n\n\n//# sourceURL=webpack://treb/./treb-base-types/src/index.ts?");

/***/ }),

/***/ "./treb-base-types/src/layout.ts":
/*!***************************************!*\
  !*** ./treb-base-types/src/layout.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\n\n\n//# sourceURL=webpack://treb/./treb-base-types/src/layout.ts?");

/***/ }),

/***/ "./treb-base-types/src/localization.ts":
/*!*********************************************!*\
  !*** ./treb-base-types/src/localization.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Localization\": () => (/* binding */ Localization)\n/* harmony export */ });\n/**\n * the point of localization is to have a central, single source of truth\n * for the current locale. this can come from the browser, via a GET\n * parameter (mostly for testing), or explicitly from a method call.\n *\n * based on locale we report settings for decimal separator, digit grouping,\n * and argument separator.\n */\nclass Localization {\n    /**\n     * update the locale. this will be called on module load (should\n     * be just once), but can be called subsequently to update.\n     *\n     * priority:\n     * (1) function argument\n     * (2) get parameter\n     * (3) navigator.languages[0]\n     * (4) navigator.language\n     *\n     * regarding languages[0] vs language, see\n     * https://stackoverflow.com/a/33204290\n     *\n     * @param locale explicitly set locale\n     */\n    static UpdateLocale(locale) {\n        var _a;\n        if (locale) {\n            this.locale = locale; // 1\n        }\n        else if (typeof self !== 'undefined') {\n            // const location = ((typeof self === 'undefined' || typeof self.document === 'undefined') ?\n            //  undefined : self.document.location);\n            const location = (_a = self === null || self === void 0 ? void 0 : self.document) === null || _a === void 0 ? void 0 : _a.location;\n            if (location && location.search &&\n                /locale=([^?&]+?)(?:\\?|$|&)/.test(location.search)) {\n                const match = location.search.match(/locale=(.*?)(?:\\?|$|&)/);\n                if (match)\n                    this.locale = match[1];\n                console.info('override locale', this.locale);\n            }\n            else if (typeof navigator !== 'undefined') {\n                if (navigator.languages && navigator.languages[0]) {\n                    this.locale = navigator.languages[0];\n                }\n                else {\n                    this.locale = navigator.language;\n                }\n            }\n        }\n        const decimal_separator = new Intl.NumberFormat(this.locale, { minimumFractionDigits: 1 }).format(3.3).replace(/\\d/g, '');\n        this.decimal_separator = (decimal_separator === ',') ? ',' : '.';\n        if (this.decimal_separator === ',') {\n            this.argument_separator = ';';\n            // FIXME: should be half-space (char?)\n            //\n            // the appropriate character (I think) is \\u2009, \"thin space\", but\n            // it seems to be rendered as full-width space in monospace fonts --\n            // which makes sense -- and since we mostly use those it's probably \n            // immaterial.\n            //\n            // it might be useful for fonts with variable-width characters but\n            // tabular numbers, in which case we would want to use it.\n            //\n            // FIXME: does format use this field, or does it have its own? (...)\n            this.grouping_separator = ' ';\n        }\n        // moved from number format lib\n        let date = new Date(2000, 0, 2, 12, 0, 0, 0); // Sun Jan 2\n        this.UpdateDateComponent(0, 0, date);\n        date = new Date(2000, 1, 7, 12, 0, 0, 0); // Mon Feb 7\n        this.UpdateDateComponent(1, 1, date);\n        date = new Date(2000, 2, 7, 12, 0, 0, 0); // Tue Mar 7\n        this.UpdateDateComponent(2, 2, date);\n        date = new Date(2000, 3, 5, 12, 0, 0, 0); // Wed Apr 5\n        this.UpdateDateComponent(3, 3, date);\n        date = new Date(2000, 4, 4, 12, 0, 0, 0); // Thur May 4\n        this.UpdateDateComponent(4, 4, date);\n        date = new Date(2000, 5, 2, 12, 0, 0, 0); // Fri Jun 2\n        this.UpdateDateComponent(5, 5, date);\n        date = new Date(2000, 6, 1, 12, 0, 0, 0); // Sat Jul 1\n        this.UpdateDateComponent(6, 6, date);\n        date = new Date(2000, 7, 1, 12, 0, 0, 0); // Aug\n        this.UpdateDateComponent(7, -1, date);\n        date = new Date(2000, 8, 1, 12, 0, 0, 0); // Sep\n        this.UpdateDateComponent(8, -1, date);\n        date = new Date(2000, 9, 1, 12, 0, 0, 0); // Oct\n        this.UpdateDateComponent(9, -1, date);\n        date = new Date(2000, 10, 1, 12, 0, 0, 0); // Nov\n        this.UpdateDateComponent(10, -1, date);\n        date = new Date(2000, 11, 1, 12, 0, 0, 0); // Dec\n        this.UpdateDateComponent(11, -1, date);\n        /*\n        console.info('LX', this.locale, this.date_components.short_days,\n          this.date_components.long_days, this.date_components.short_months,\n          this.date_components.long_months);\n        */\n    }\n    static UpdateDateComponent(month_index, day_index, date) {\n        if (day_index >= 0) {\n            this.date_components.short_days[day_index] = date.toLocaleString(this.locale, { weekday: 'short' });\n            this.date_components.long_days[day_index] = date.toLocaleString(this.locale, { weekday: 'long' });\n        }\n        if (month_index >= 0) {\n            this.date_components.short_months[month_index] = date.toLocaleString(this.locale, { month: 'short' });\n            this.date_components.long_months[month_index] = date.toLocaleString(this.locale, { month: 'long' });\n        }\n    }\n}\nLocalization.locale = 'en-us'; // default, for node\nLocalization.decimal_separator = '.';\nLocalization.argument_separator = ',';\nLocalization.grouping_separator = ',';\nLocalization.date_components = {\n    short_days: [\n        'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat',\n    ],\n    long_days: [\n        'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday',\n    ],\n    short_months: [\n        'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec',\n    ],\n    long_months: [\n        'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August',\n        'September', 'October', 'November', 'December',\n    ],\n};\nLocalization.UpdateLocale(); // always call\n\n\n//# sourceURL=webpack://treb/./treb-base-types/src/localization.ts?");

/***/ }),

/***/ "./treb-base-types/src/rectangle.ts":
/*!******************************************!*\
  !*** ./treb-base-types/src/rectangle.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Rectangle\": () => (/* binding */ Rectangle)\n/* harmony export */ });\nclass Rectangle {\n    constructor(left = 0, top = 0, width = 0, height = 0) {\n        this.left = left;\n        this.top = top;\n        this.width = width;\n        this.height = height;\n    }\n    get right() { return this.left + this.width; }\n    get bottom() { return this.top + this.height; }\n    /**\n     * create a rectangle from an object that looks\n     * like a rectangle, probably a serialized object\n     */\n    static Create(obj) {\n        return new Rectangle(obj.left || 0, obj.top || 0, obj.width || 0, obj.height || 0);\n    }\n    static IsRectangle(obj) {\n        var _a, _b, _c, _d;\n        return (typeof obj === 'object') &&\n            (typeof ((_a = obj) === null || _a === void 0 ? void 0 : _a.left) === 'number') &&\n            (typeof ((_b = obj) === null || _b === void 0 ? void 0 : _b.top) === 'number') &&\n            (typeof ((_c = obj) === null || _c === void 0 ? void 0 : _c.width) === 'number') &&\n            (typeof ((_d = obj) === null || _d === void 0 ? void 0 : _d.height) === 'number');\n    }\n    /** returns a new rect shifted from this one by (x,y) */\n    Shift(x = 0, y = 0) {\n        return new Rectangle(this.left + x, this.top + y, this.width, this.height);\n    }\n    Scale(scale_x = 1, scale_y = scale_x) {\n        return new Rectangle(this.left * scale_x, this.top * scale_y, this.width * scale_x, this.height * scale_y);\n    }\n    /** returns a new rect expanded from this one by (x,y) */\n    Expand(x = 0, y = 0) {\n        return new Rectangle(this.left, this.top, this.width + x, this.height + y);\n    }\n    /** returns a new rectangle that combines this rectangle with the argument */\n    Combine(rect) {\n        return new Rectangle(Math.min(this.left, rect.left), Math.min(this.top, rect.top), Math.max(this.right, rect.right) - Math.min(this.left, rect.left), Math.max(this.bottom, rect.bottom) - Math.min(this.top, rect.top));\n    }\n    CheckEdges(x, y, border = 16) {\n        let edge = 0;\n        // tslint:disable-next-line:no-bitwise\n        if (x - this.left < border)\n            edge |= 1;\n        // tslint:disable-next-line:no-bitwise\n        if (this.right - x < border)\n            edge |= 2;\n        // tslint:disable-next-line:no-bitwise\n        if (y - this.top < border)\n            edge |= 4;\n        // tslint:disable-next-line:no-bitwise\n        if (this.bottom - y < border)\n            edge |= 8;\n        return edge;\n    }\n    /**\n     * check if rectangle contains the given coordinates, optionally with\n     * some added padding\n     */\n    Contains(x, y, padding = 0) {\n        return (x >= this.left - padding)\n            && (x <= (this.left + this.width + padding))\n            && (y >= this.top - padding)\n            && (y <= (this.top + this.height + padding));\n    }\n    /** convenience method for canvas */\n    ContextFill(context) {\n        context.fillRect(this.left, this.top, this.width, this.height);\n    }\n    /** convenience method for canvas */\n    ContextStroke(context) {\n        context.strokeRect(this.left, this.top, this.width, this.height);\n    }\n    /** clamp coordinate to rectangle */\n    Clamp(x, y) {\n        x = Math.min(Math.max(x, this.left), this.right);\n        y = Math.min(Math.max(y, this.top), this.bottom);\n        return { x, y };\n    }\n    /** convenience method for html element style */\n    ApplyStyle(element) {\n        element.style.top = this.top + 'px';\n        element.style.left = this.left + 'px';\n        element.style.width = this.width + 'px';\n        element.style.height = this.height + 'px';\n    }\n    toJSON() {\n        return {\n            top: this.top, left: this.left, width: this.width, height: this.height,\n        };\n    }\n}\n\n\n//# sourceURL=webpack://treb/./treb-base-types/src/rectangle.ts?");

/***/ }),

/***/ "./treb-base-types/src/style.ts":
/*!**************************************!*\
  !*** ./treb-base-types/src/style.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Style\": () => (/* binding */ Style)\n/* harmony export */ });\n// why is this a namespace? module is implicit... it's because of how\n// base types exports; we can't export * as Style, so we're stuck with\n// the namespace (or you could add an intermediate file and import ->\n// export, but that just seems like unecessary complexity and still kludgy).\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Style;\n(function (Style) {\n    const empty_json = JSON.stringify({});\n    /** horizontal align constants */\n    let HorizontalAlign;\n    (function (HorizontalAlign) {\n        HorizontalAlign[HorizontalAlign[\"None\"] = 0] = \"None\";\n        HorizontalAlign[HorizontalAlign[\"Left\"] = 1] = \"Left\";\n        HorizontalAlign[HorizontalAlign[\"Center\"] = 2] = \"Center\";\n        HorizontalAlign[HorizontalAlign[\"Right\"] = 3] = \"Right\";\n    })(HorizontalAlign = Style.HorizontalAlign || (Style.HorizontalAlign = {}));\n    /** vertical align constants */\n    let VerticalAlign;\n    (function (VerticalAlign) {\n        VerticalAlign[VerticalAlign[\"None\"] = 0] = \"None\";\n        VerticalAlign[VerticalAlign[\"Top\"] = 1] = \"Top\";\n        VerticalAlign[VerticalAlign[\"Bottom\"] = 2] = \"Bottom\";\n        VerticalAlign[VerticalAlign[\"Middle\"] = 3] = \"Middle\";\n    })(VerticalAlign = Style.VerticalAlign || (Style.VerticalAlign = {}));\n    /**\n     * note that there are no default colors; those should be set\n     * in grid when style is applied. that way the default colors for\n     * border, text and background colors will be theme-dependent and\n     * can change.\n     */\n    Style.DefaultProperties = {\n        horizontal_align: HorizontalAlign.None,\n        vertical_align: VerticalAlign.None,\n        number_format: 'General',\n        nan: 'NaN',\n        // font_size: 10,              // should have units\n        font_size_value: 10,\n        font_size_unit: 'pt',\n        font_face: 'calibri',\n        font_bold: false,\n        font_italic: false,\n        font_underline: false,\n        font_strike: false,\n        // background: 'none',\n        // text_color: 'none',\n        // text: 'theme',\n        // text_theme: 0,\n        text: { theme: 1 },\n        // border_top_color: 'none',\n        // border_left_color: 'none',\n        // border_right_color: 'none',\n        // border_bottom_color: 'none',\n        border_top: 0,\n        border_left: 0,\n        border_right: 0,\n        border_bottom: 0,\n    };\n    /* *\n     * this version of merge is used to support explicit deletes, via\n     * \"undefined\" properties. we use a trick via JSON to skip iterating\n     * properties (I believe this is faster, but have not tested).\n     * /\n    export const Merge2 = (dest: Properties, src: Properties): Properties => {\n      return JSON.parse(JSON.stringify({...dest, ...src}));\n    }\n    */\n    /**\n     * merge. returns a new object, does not update dest in place.\n     * NOTE: if it does not update dest in place, then what would be\n     * the use case for a non-delta merge? (...)\n     */\n    Style.Merge = (dest, src, delta = true) => {\n        const properties = delta ? Object.assign(Object.assign({}, dest), src) : Object.assign({}, src);\n        return JSON.parse(JSON.stringify(properties));\n    };\n    Style.Composite = (list) => {\n        return JSON.parse(JSON.stringify(list.reduce((composite, item) => (Object.assign(Object.assign({}, composite), item)), {})));\n    };\n    Style.Empty = (style) => {\n        return JSON.stringify(style) === empty_json;\n    };\n    Style.ValidColor = (color) => {\n        return !!(color && (!color.none) && (color.text || color.theme || color.theme === 0));\n    };\n    /*\n    export const Prune = (style: Properties): void => {\n  \n      // text default is theme 0, so we can remove that if we see it.\n      // same for borders, we can group\n  \n      if (style.text && !style.text.text && !style.text.theme) {\n        style.text = undefined;\n      }\n  \n      if (style.border_top_fill && !style.border_top_fill.text && !style.border_top_fill.theme) {\n        style.border_top_fill = undefined;\n      }\n  \n      if (style.border_left_fill && !style.border_left_fill.text && !style.border_left_fill.theme) {\n        style.border_left_fill = undefined;\n      }\n  \n      if (style.border_right_fill && !style.border_right_fill.text && !style.border_right_fill.theme) {\n        style.border_right_fill = undefined;\n      }\n  \n      if (style.border_bottom_fill && !style.border_bottom_fill.text && !style.border_bottom_fill.theme) {\n        style.border_bottom_fill = undefined;\n      }\n  \n      // background has no default, so check for 0\n      if (style.fill && !style.fill.text && !style.fill.theme && style.fill.theme !== 0) {\n        style.fill = undefined;\n      }\n  \n    };\n    */\n    /* *\n     * overlay. will always put defaults at the bottom.\n     * /\n    export const Composite = (list: Properties[]) => {\n      return list.reduce((composite, item) => ({...composite, ...item}),\n        {...DefaultProperties});\n    };\n  \n    / * *\n     * modify default properties. useful for theming.\n     * /\n    export const UpdateDefaultProperties = (opts: Properties) => {\n      DefaultProperties = {\n        ...DefaultProperties, ...opts,\n      };\n    };\n    */\n    /**\n     * returns a string representation suitable for canvas (or style)\n     */\n    Style.Font = (properties, scale = 1) => {\n        /*\n        let font_size = properties.font_size;\n        if (typeof font_size === 'number') {\n          font_size = (font_size * scale) + 'pt';\n        }\n        else if (font_size && scale !== 1) {\n          const font_parts = font_size.match(/^([\\d\\.]+)(\\D*)$/);\n          if (font_parts) {\n            font_size = (Number(font_parts[1]) * scale) + font_parts[2];\n          }\n        }\n        */\n        const parts = [];\n        if (properties.font_weight) {\n            parts.push(properties.font_weight.toString());\n        }\n        else if (properties.font_bold) {\n            parts.push('bold');\n        }\n        if (properties.font_italic) {\n            parts.push('italic');\n        }\n        parts.push(((properties.font_size_value || 0) * scale).toFixed(2) +\n            (properties.font_size_unit || 'pt'));\n        parts.push(properties.font_face || '');\n        return parts.join(' ');\n        /*\n        // console.info(\"FS\", font_size);\n    \n        if (properties.font_weight) {\n          return (properties.font_weight + ' ')\n            + (properties.font_italic ? 'italic ' : '')\n            + font_size + ' ' + properties.font_face;\n        }\n        else {\n          return (properties.font_bold ? 'bold ' : '')\n            + (properties.font_italic ? 'italic ' : '')\n            + font_size + ' ' + properties.font_face;\n        }\n        */\n    };\n})(Style || (Style = {}));\n\n\n//# sourceURL=webpack://treb/./treb-base-types/src/style.ts?");

/***/ }),

/***/ "./treb-base-types/src/text_part.ts":
/*!******************************************!*\
  !*** ./treb-base-types/src/text_part.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TextPartFlag\": () => (/* binding */ TextPartFlag)\n/* harmony export */ });\nvar TextPartFlag;\n(function (TextPartFlag) {\n    /** just render */\n    TextPartFlag[TextPartFlag[\"default\"] = 0] = \"default\";\n    /** not rendered, but included in layout (spacing) */\n    TextPartFlag[TextPartFlag[\"hidden\"] = 1] = \"hidden\";\n    /** takes up all available space */\n    TextPartFlag[TextPartFlag[\"padded\"] = 2] = \"padded\";\n    /** date component, needs to be filled */\n    TextPartFlag[TextPartFlag[\"date_component\"] = 3] = \"date_component\";\n    /** special flag for minutes (instead of months), which is contextual */\n    TextPartFlag[TextPartFlag[\"date_component_minutes\"] = 4] = \"date_component_minutes\";\n    /** literal (@): reflect the original */\n    TextPartFlag[TextPartFlag[\"literal\"] = 5] = \"literal\";\n    /** formatting (e.g. [red]) */\n    TextPartFlag[TextPartFlag[\"formatting\"] = 6] = \"formatting\";\n})(TextPartFlag || (TextPartFlag = {}));\n\n\n//# sourceURL=webpack://treb/./treb-base-types/src/text_part.ts?");

/***/ }),

/***/ "./treb-base-types/src/theme.ts":
/*!**************************************!*\
  !*** ./treb-base-types/src/theme.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DefaultTheme\": () => (/* binding */ DefaultTheme),\n/* harmony export */   \"ThemeColor\": () => (/* binding */ ThemeColor),\n/* harmony export */   \"ThemeColor2\": () => (/* binding */ ThemeColor2),\n/* harmony export */   \"LoadThemeProperties\": () => (/* binding */ LoadThemeProperties)\n/* harmony export */ });\n/* harmony import */ var treb_base_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! treb-base-types */ \"./treb-base-types/src/index.ts\");\n\nconst DefaultTheme = {\n    grid_color: 'red',\n    note_marker_color: '#d2c500',\n};\n/**\n * now just a wrapper, we should remove\n * @deprecated\n */\nconst ThemeColor = (theme, color) => {\n    return ThemeColor2(theme, color, 0);\n};\n/**\n * we cache values in the theme object so that we can dump it when we\n * reload or update the theme.\n */\nconst TintedColor = (theme, index, tint) => {\n    if (!theme.tint_cache) {\n        theme.tint_cache = [];\n    }\n    if (!theme.tint_cache[index]) {\n        theme.tint_cache[index] = {};\n    }\n    let color = theme.tint_cache[index][tint];\n    if (!color) {\n        const rgb = theme.theme_colors_rgb ? theme.theme_colors_rgb[index] : [0, 0, 0];\n        let tinted;\n        if (tint > 0) {\n            tinted = treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Color.Lighten(rgb[0], rgb[1], rgb[2], tint * 100, true);\n        }\n        else {\n            tinted = treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Color.Darken(rgb[0], rgb[1], rgb[2], -tint * 100, true);\n        }\n        color = `rgb(${tinted.r},${tinted.g},${tinted.b})`;\n        // console.info(index, tint, color);\n        theme.tint_cache[index][tint] = color;\n    }\n    return color;\n};\n/**\n * this includes an implicit check for valid color, if a color\n * can't be resolved it returns ''\n */\nconst ThemeColor2 = (theme, color, default_index) => {\n    // explicit color, or none\n    if (color === null || color === void 0 ? void 0 : color.text) {\n        return color.text === 'none' ? '' : color.text;\n    }\n    // theme color. we need a way to cache these lookups, especially for tinting\n    if ((color === null || color === void 0 ? void 0 : color.theme) || (color === null || color === void 0 ? void 0 : color.theme) === 0) {\n        if (color.tint) {\n            return TintedColor(theme, color.theme, color.tint);\n        }\n        return theme.theme_colors ? theme.theme_colors[color.theme] : '';\n    }\n    // default from argument\n    if (default_index || default_index === 0) {\n        return theme.theme_colors ? theme.theme_colors[default_index] : '';\n    }\n    // actual default, which is nothing\n    return '';\n};\nconst ParseFontSize = (size) => {\n    let value = 10;\n    let unit = 'pt';\n    const match = size.match(/^([\\d.]+)(\\D.*)$/); // pt, px, em, rem, %\n    if (match) {\n        value = Number(match[1]);\n        unit = match[2];\n    }\n    return { value, unit };\n};\n// testing\nconst StyleFromCSS = (css) => {\n    const { value, unit } = ParseFontSize(css.fontSize || '');\n    const style = {\n        fill: { text: css.backgroundColor },\n        text: { text: css.color },\n        font_size_unit: unit,\n        font_size_value: value,\n        font_face: css.fontFamily,\n    };\n    // not sure about this... should maybe be undefined?\n    // console.info(\"BC?\", css.borderBottomColor);\n    //style.border_bottom_color = css.borderBottomColor || ''; // 'none';\n    //style.border_top_color = css.borderTopColor || ''; // 'none';\n    //style.border_left_color = css.borderLeftColor || ''; // 'none';\n    //style.border_right_color = css.borderRightColor || ''; // 'none';\n    if (/italic/i.test(css.font)) {\n        style.font_italic = true;\n    }\n    const weight = Number(css.fontWeight);\n    if (!isNaN(weight) && weight) {\n        style.font_weight = weight;\n    }\n    return style;\n};\nconst LoadThemeProperties = (container) => {\n    var _a, _b, _c;\n    const theme = JSON.parse(JSON.stringify(DefaultTheme));\n    const Append = (parent, classes) => {\n        const node = document.createElement('div');\n        node.setAttribute('class', classes);\n        parent.appendChild(node);\n        return node;\n    };\n    const ElementCSS = (parent, classes) => {\n        return window.getComputedStyle(Append(parent, classes));\n    };\n    const node = Append(container, '');\n    const CSS = ElementCSS.bind(0, node);\n    let css = CSS('grid-cells');\n    theme.grid_cell = StyleFromCSS(css);\n    theme.grid_color = css.stroke || '';\n    css = CSS('grid-headers');\n    theme.headers = StyleFromCSS(css);\n    // this _is_ painted, but it doesn't necessarily need to be -- we\n    // could use a node. that would require moving it around, though. \n    // let's leave it for now.\n    css = CSS('note-marker');\n    theme.note_marker_color = css.backgroundColor;\n    // theme colors\n    node.style.color = 'rgba(1,2,3,.4)'; // this is an attempt at a unique identifier\n    css = CSS('');\n    const compare = css.color;\n    theme.theme_colors = [\n        ((_a = theme.grid_cell.fill) === null || _a === void 0 ? void 0 : _a.text) || 'rgb(255, 255, 255)',\n        ((_b = theme.grid_cell.text) === null || _b === void 0 ? void 0 : _b.text) || 'rgb(51, 51, 51)',\n    ];\n    for (let i = 1; i < 32; i++) {\n        css = CSS(`theme-color-${i}`);\n        if (!css.color || css.color === compare) {\n            break;\n        }\n        theme.theme_colors.push(css.color);\n    }\n    // we could just parse, we know the returned css format is going\n    // to be an rgb triple (I think?)\n    const canvas = document.createElement('canvas');\n    canvas.width = 3;\n    canvas.height = 3;\n    const context = canvas.getContext('2d');\n    if (context) {\n        theme.theme_colors_rgb = theme.theme_colors.map((color) => {\n            context.fillStyle = color;\n            context.fillRect(0, 0, 3, 3);\n            const imagedata = context.getImageData(1, 1, 1, 1);\n            return Array.from(imagedata.data);\n        });\n    }\n    // this is a little odd, since we have the check above for \"existing element\";\n    // should we switch on that? or is that never used, and we can drop it? (...)\n    (_c = node.parentElement) === null || _c === void 0 ? void 0 : _c.removeChild(node);\n    return theme;\n};\n\n\n//# sourceURL=webpack://treb/./treb-base-types/src/theme.ts?");

/***/ }),

/***/ "./treb-base-types/src/union.ts":
/*!**************************************!*\
  !*** ./treb-base-types/src/union.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Is2DArray\": () => (/* binding */ Is2DArray),\n/* harmony export */   \"UnionIs\": () => (/* binding */ UnionIs),\n/* harmony export */   \"UndefinedUnion\": () => (/* binding */ UndefinedUnion),\n/* harmony export */   \"Box\": () => (/* binding */ Box)\n/* harmony export */ });\n/* harmony import */ var _value_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value-type */ \"./treb-base-types/src/value-type.ts\");\n\n/** utility method */\nconst Is2DArray = (obj) => {\n    return !!obj && Array.isArray(obj) && Array.isArray(obj[0]);\n};\n/*\nexport const UnionIsUndef = (test: UnionValue): test is { type: ValueType.undefined, value: undefined } => {\n  return test.type === ValueType.undefined;\n}\n\nexport const UnionIsNumber = (test: UnionValue): test is { type: ValueType.number, value: number } => {\n  return test.type === ValueType.number;\n}\n\nexport const UnionIsFormula = (test: UnionValue): test is { type: ValueType.formula, value: string } => {\n  return test.type === ValueType.formula;\n}\n\nexport const UnionIsBoolean = (test: UnionValue): test is { type: ValueType.boolean, value: boolean } => {\n  return test.type === ValueType.formula;\n}\n\nexport const UnionIsString = (test: UnionValue): test is { type: ValueType.string, value: string } => {\n  return test.type === ValueType.formula;\n}\n\nexport const UnionIsError = (test: UnionValue): test is { type: ValueType.error, value: string } => {\n  return test.type === ValueType.error;\n}\n\nexport const UnionIsExtended = (test: UnionValue): test is { type: ValueType.object, value: any } => {\n  return test.type === ValueType.object;\n}\n*/\n/** composite type guard (why do all these test for type formula? is that a bug?) */\nconst UnionIs = {\n    Undefined: (test) => {\n        return test.type === _value_type__WEBPACK_IMPORTED_MODULE_0__.ValueType.undefined;\n    },\n    Number: (test) => {\n        return test.type === _value_type__WEBPACK_IMPORTED_MODULE_0__.ValueType.number;\n    },\n    Formula: (test) => {\n        return test.type === _value_type__WEBPACK_IMPORTED_MODULE_0__.ValueType.formula;\n    },\n    Boolean: (test) => {\n        return test.type === _value_type__WEBPACK_IMPORTED_MODULE_0__.ValueType.formula;\n    },\n    String: (test) => {\n        return test.type === _value_type__WEBPACK_IMPORTED_MODULE_0__.ValueType.formula;\n    },\n    Error: (test) => {\n        return test.type === _value_type__WEBPACK_IMPORTED_MODULE_0__.ValueType.error;\n    },\n    Extended: (test) => {\n        return test.type === _value_type__WEBPACK_IMPORTED_MODULE_0__.ValueType.object;\n    },\n};\n// common types\n/**\n * this is a factory instead of a constant value to prevent any accidental pollution\n */\nconst UndefinedUnion = () => {\n    return { type: _value_type__WEBPACK_IMPORTED_MODULE_0__.ValueType.undefined, value: undefined };\n};\n/** shortcut, although this is wasteful */\nconst Box = (value, type) => {\n    if (typeof type === 'undefined') {\n        type = (0,_value_type__WEBPACK_IMPORTED_MODULE_0__.GetValueType)(value);\n    }\n    return {\n        value,\n        type,\n    };\n};\n\n\n//# sourceURL=webpack://treb/./treb-base-types/src/union.ts?");

/***/ }),

/***/ "./treb-base-types/src/value-type.ts":
/*!*******************************************!*\
  !*** ./treb-base-types/src/value-type.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ValueType\": () => (/* binding */ ValueType),\n/* harmony export */   \"GetValueType\": () => (/* binding */ GetValueType)\n/* harmony export */ });\n// split from cell for separate import, \n// @see format-index.ts\n/**\n * I _think_ using enums is faster. I'm not actually sure about that, though.\n * it stands to reason that a single int compare is faster than a string\n * compare, but you never know with javascript. undefined preferred over null.\n * formula implies a string.\n *\n * undefined is 0 so we can test it as falsy.\n *\n * we're passing this type information out to calculators, so it needs\n * to have known values. DO NOT MODIFY EXISTING INDEXES, or at least be\n * aware of the implications. definitely do not change undefined => 0.\n */\nvar ValueType;\n(function (ValueType) {\n    ValueType[ValueType[\"undefined\"] = 0] = \"undefined\";\n    // formula is a string; we usually test the first character === '='\n    ValueType[ValueType[\"formula\"] = 1] = \"formula\";\n    ValueType[ValueType[\"string\"] = 2] = \"string\";\n    ValueType[ValueType[\"number\"] = 3] = \"number\";\n    ValueType[ValueType[\"boolean\"] = 4] = \"boolean\";\n    // we don't actually use this type, it's here for matching only\n    ValueType[ValueType[\"object\"] = 5] = \"object\";\n    // error is a STRING VALUE... object errors are layered on top? is that \n    // correct? (...) it sort of makes sense... since we have separate typing\n    ValueType[ValueType[\"error\"] = 6] = \"error\";\n})(ValueType || (ValueType = {}));\nconst GetValueType = (value) => {\n    switch (typeof value) {\n        case 'undefined':\n            return ValueType.undefined;\n        case 'number':\n            return ValueType.number;\n        case 'boolean':\n            return ValueType.boolean;\n        case 'object':\n            if (value === null) {\n                return ValueType.undefined;\n            }\n            return ValueType.object;\n        case 'string':\n            if (value[0] === '=') {\n                return ValueType.formula;\n            }\n            return ValueType.string;\n        default: // function or symbol\n            return ValueType.error;\n    }\n};\n\n\n//# sourceURL=webpack://treb/./treb-base-types/src/value-type.ts?");

/***/ }),

/***/ "./treb-calculator/src/calculator.ts":
/*!*******************************************!*\
  !*** ./treb-calculator/src/calculator.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Calculator\": () => (/* binding */ Calculator)\n/* harmony export */ });\n/* harmony import */ var treb_base_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! treb-base-types */ \"./treb-base-types/src/index.ts\");\n/* harmony import */ var treb_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! treb-parser */ \"./treb-parser/src/index.ts\");\n/* harmony import */ var _dag_graph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dag/graph */ \"./treb-calculator/src/dag/graph.ts\");\n/* harmony import */ var _expression_calculator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./expression-calculator */ \"./treb-calculator/src/expression-calculator.ts\");\n/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utilities */ \"./treb-calculator/src/utilities.ts\");\n/* harmony import */ var _function_library__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./function-library */ \"./treb-calculator/src/function-library.ts\");\n/* harmony import */ var _descriptors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./descriptors */ \"./treb-calculator/src/descriptors.ts\");\n/* harmony import */ var _functions_base_functions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./functions/base-functions */ \"./treb-calculator/src/functions/base-functions.ts\");\n/* harmony import */ var _functions_finance_functions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./functions/finance-functions */ \"./treb-calculator/src/functions/finance-functions.ts\");\n/* harmony import */ var _functions_text_functions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./functions/text-functions */ \"./treb-calculator/src/functions/text-functions.ts\");\n/* harmony import */ var _functions_information_functions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./functions/information-functions */ \"./treb-calculator/src/functions/information-functions.ts\");\n/* harmony import */ var _functions_statistics_functions__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./functions/statistics-functions */ \"./treb-calculator/src/functions/statistics-functions.ts\");\n/* harmony import */ var _dag_leaf_vertex__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./dag/leaf_vertex */ \"./treb-calculator/src/dag/leaf_vertex.ts\");\n/* harmony import */ var _function_error__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./function-error */ \"./treb-calculator/src/function-error.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Calculator now extends graph. there's a 1-1 relationship between the\n * two, and we wind up passing a lot of operations from one to the other.\n * this also simplifies the callback structure, as we can use local methods.\n *\n * NOTE: graph vertices hold references to cells. while that makes lookups\n * more efficient, it causes problems if you mutate the sheet (adding or\n * removing rows or columns).\n *\n * in that event, you need to flush the graph to force rebuilding references\n * (TODO: just rebuild references). after mutating the sheet, call\n * ```\n * Calculator.Reset();\n * ```\n *\n */\nclass Calculator extends _dag_graph__WEBPACK_IMPORTED_MODULE_2__.Graph {\n    constructor() {\n        super();\n        // FIXME: remove from calculator class\n        // protected readonly simulation_model = new SimulationModel();\n        this.library = new _function_library__WEBPACK_IMPORTED_MODULE_5__.FunctionLibrary();\n        this.parser = new treb_parser__WEBPACK_IMPORTED_MODULE_1__.Parser();\n        // protected graph: Graph = new Graph(); // |null = null;\n        // protected status: GraphStatus = GraphStatus.OK;\n        // FIXME: why is this a separate class? [actually is this a composition issue?]\n        this.expression_calculator = new _expression_calculator__WEBPACK_IMPORTED_MODULE_3__.ExpressionCalculator(\n        // this.simulation_model,\n        this.library, this.parser);\n        /** the next calculation must do a full rebuild -- set on reset */\n        this.full_rebuild_required = false;\n        this.UpdateLocale();\n        // base functions\n        this.library.Register(_functions_base_functions__WEBPACK_IMPORTED_MODULE_7__.BaseFunctionLibrary, _functions_text_functions__WEBPACK_IMPORTED_MODULE_9__.TextFunctionLibrary, // we split out text functions\n        _functions_statistics_functions__WEBPACK_IMPORTED_MODULE_11__.StatisticsFunctionLibrary, // also stats (wip)\n        _functions_finance_functions__WEBPACK_IMPORTED_MODULE_8__.FinanceFunctionLibrary, // also this (wip)\n        _functions_information_functions__WEBPACK_IMPORTED_MODULE_10__.InformationFunctionLibrary);\n        // aliases\n        for (const key of Object.keys(_functions_statistics_functions__WEBPACK_IMPORTED_MODULE_11__.StatisticsFunctionAliases)) {\n            this.library.Alias(key, _functions_statistics_functions__WEBPACK_IMPORTED_MODULE_11__.StatisticsFunctionAliases[key]);\n        }\n        for (const key of Object.keys(_functions_text_functions__WEBPACK_IMPORTED_MODULE_9__.TextFunctionAliases)) {\n            this.library.Alias(key, _functions_text_functions__WEBPACK_IMPORTED_MODULE_9__.TextFunctionAliases[key]);\n        }\n        // special functions... need reference to the graph (this)\n        this.library.Register({\n            /**\n             * this function is here so it has access to the parser.\n             * this is crazy expensive. is there a way to reduce cost?\n             *\n             * we could, in theory, consider that there are only a few\n             * valid operations here -- all binary. instead of using a\n             * generic call to the CalculateExpression routine, we could\n             * short-cut and call the binary method.\n             *\n             * OTOH that makes it more fragile, and might not really\n             * provide that much in the way of savings. still, it would\n             * be good if we could somehow cache some of the effort,\n             * particularly if the list data changes but not the expression.\n             *\n             */\n            CountIf: {\n                arguments: [\n                    { name: 'range', },\n                    { name: 'criteria', }\n                ],\n                fn: (range, criteria) => {\n                    const data = _utilities__WEBPACK_IMPORTED_MODULE_4__.Flatten(range);\n                    if (typeof criteria !== 'string') {\n                        criteria = '=' + (criteria || 0).toString();\n                    }\n                    else {\n                        criteria = criteria.trim();\n                        if (!/^[=<>]/.test(criteria)) {\n                            criteria = '=' + criteria;\n                        }\n                    }\n                    // switching to an array. doesn't actually seem to be any \n                    // faster... more appropriate, though.\n                    const parse_result = this.parser.Parse('{}' + criteria);\n                    const expression = parse_result.expression;\n                    if (parse_result.error || !expression) {\n                        return (0,_function_error__WEBPACK_IMPORTED_MODULE_13__.ExpressionError)();\n                    }\n                    if (expression.type !== 'binary') {\n                        // console.warn('invalid expression [1]', expression);\n                        return (0,_function_error__WEBPACK_IMPORTED_MODULE_13__.ExpressionError)();\n                    }\n                    if (expression.left.type !== 'array') {\n                        // console.warn('invalid expression [1]', expression);\n                        return (0,_function_error__WEBPACK_IMPORTED_MODULE_13__.ExpressionError)();\n                    }\n                    expression.left.values = [data];\n                    const result = this.CalculateExpression(expression);\n                    if (Array.isArray(result)) {\n                        let count = 0;\n                        for (const column of result) {\n                            for (const cell of column) {\n                                if (cell.value) {\n                                    count++;\n                                }\n                            }\n                        }\n                        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: count };\n                    }\n                    return result; // error?\n                },\n            },\n            /** like indirect, this creates dependencies at calc time */\n            Offset: {\n                arguments: [{\n                        name: 'reference', description: 'Base reference', metadata: true,\n                    }, {\n                        name: 'rows', description: 'number of rows to offset'\n                    }, {\n                        name: 'columns', description: 'number of columns to offset'\n                    },\n                ],\n                return_type: _descriptors__WEBPACK_IMPORTED_MODULE_6__.ReturnType.reference,\n                volatile: true,\n                fn: ((reference, rows = 0, columns = 0, width = 1, height = 1) => {\n                    if (!reference) {\n                        return (0,_function_error__WEBPACK_IMPORTED_MODULE_13__.ArgumentError)();\n                    }\n                    // const parse_result = this.parser.Parse(reference);\n                    // if (parse_result.error || !parse_result.expression) {\n                    //  return ReferenceError;\n                    //}\n                    // we need a proper type for this... also it might be a range\n                    if (!(0,_expression_calculator__WEBPACK_IMPORTED_MODULE_3__.UnionIsMetadata)(reference)) {\n                        return (0,_function_error__WEBPACK_IMPORTED_MODULE_13__.ReferenceError)();\n                    }\n                    const check_result = this.DynamicDependencies(reference.value.address, this.expression_calculator.context.address, true, rows, columns, width, height);\n                    if (!check_result) {\n                        return (0,_function_error__WEBPACK_IMPORTED_MODULE_13__.ReferenceError)();\n                    }\n                    if (check_result.dirty) {\n                        const current_vertex = this.GetVertex(this.expression_calculator.context.address, true);\n                        current_vertex.short_circuit = true;\n                        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.undefined, value: undefined };\n                    }\n                    if (check_result.area) {\n                        const start = Object.assign(Object.assign({ type: 'address' }, check_result.area.start), { label: '', position: 0, \n                            // id: parse_result.expression.id,\n                            id: 0 });\n                        const end = Object.assign(Object.assign({ type: 'address' }, check_result.area.end), { label: '', position: 0, \n                            // id: parse_result.expression.id,\n                            id: 0 });\n                        const expression = check_result.area.count === 1 ? start : {\n                            type: 'range', start, end,\n                            label: '', position: 0,\n                            // id: parse_result.expression.id,\n                            id: 0,\n                        };\n                        // return this.CalculateExpression(expression, undefined, true);\n                        // return expression;\n                        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.object, value: expression };\n                    }\n                    return (0,_function_error__WEBPACK_IMPORTED_MODULE_13__.ValueError)();\n                }).bind(this),\n            },\n            Indirect: {\n                arguments: [\n                    { name: 'reference', description: 'Cell reference (string)' },\n                ],\n                return_type: _descriptors__WEBPACK_IMPORTED_MODULE_6__.ReturnType.reference,\n                volatile: true,\n                fn: ((reference) => {\n                    if (!reference || (typeof reference !== 'string')) {\n                        return (0,_function_error__WEBPACK_IMPORTED_MODULE_13__.ArgumentError)();\n                    }\n                    const parse_result = this.parser.Parse(reference);\n                    if (parse_result.error || !parse_result.expression ||\n                        (parse_result.expression.type !== 'address' && parse_result.expression.type !== 'range')) {\n                        return (0,_function_error__WEBPACK_IMPORTED_MODULE_13__.ReferenceError)();\n                    }\n                    const check_result = this.DynamicDependencies(parse_result.expression, this.expression_calculator.context.address);\n                    if (!check_result) {\n                        return (0,_function_error__WEBPACK_IMPORTED_MODULE_13__.ReferenceError)();\n                    }\n                    if (check_result.dirty) {\n                        const current_vertex = this.GetVertex(this.expression_calculator.context.address, true);\n                        current_vertex.short_circuit = true;\n                        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.undefined, value: undefined };\n                    }\n                    return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.object, value: parse_result.expression };\n                }).bind(this),\n            },\n            /**\n             * this one does not have to be here, it's just here because\n             * the rest of the reference/lookup functions are here\n             */\n            Rows: {\n                arguments: [{\n                        name: 'reference', description: 'Array or reference'\n                    },\n                ],\n                volatile: false,\n                fn: (reference) => {\n                    if (!reference) {\n                        return (0,_function_error__WEBPACK_IMPORTED_MODULE_13__.ArgumentError)();\n                    }\n                    if (Array.isArray(reference)) {\n                        const column = reference[0];\n                        if (Array.isArray(column)) {\n                            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: column.length };\n                        }\n                        return (0,_function_error__WEBPACK_IMPORTED_MODULE_13__.ValueError)();\n                    }\n                    return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: 1 };\n                },\n            },\n            /**\n             * this one does not have to be here, it's just here because\n             * the rest of the reference/lookup functions are here\n             */\n            Columns: {\n                arguments: [{\n                        name: 'reference', description: 'Array or reference'\n                    },\n                ],\n                volatile: false,\n                fn: (reference) => {\n                    if (!reference) {\n                        return (0,_function_error__WEBPACK_IMPORTED_MODULE_13__.ArgumentError)();\n                    }\n                    if (Array.isArray(reference)) {\n                        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: reference.length };\n                    }\n                    return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: 1 };\n                },\n            },\n            /**\n             * this should be in the 'information' library but it needs reference\n             * to the underlying cell (unresolved)\n             */\n            IsFormula: {\n                description: 'Returns true if the reference is a formula',\n                arguments: [{\n                        name: 'Reference',\n                        metadata: true,\n                    }],\n                fn: _utilities__WEBPACK_IMPORTED_MODULE_4__.ApplyAsArray((ref) => {\n                    // this is wasteful because we know that the range will all\n                    // be in the same sheet... we don't need to look up every time\n                    var _a, _b;\n                    if ((_a = ref === null || ref === void 0 ? void 0 : ref.value) === null || _a === void 0 ? void 0 : _a.address) {\n                        for (const sheet of ((_b = this.model) === null || _b === void 0 ? void 0 : _b.sheets) || []) {\n                            if (sheet.id === ref.value.address.sheet_id) {\n                                const cell = sheet.cells.GetCell(ref.value.address, false);\n                                return {\n                                    type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.boolean,\n                                    value: (cell === null || cell === void 0 ? void 0 : cell.type) === treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.formula,\n                                };\n                            }\n                        }\n                    }\n                    return {\n                        type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.boolean, value: false,\n                    };\n                }),\n            },\n        });\n    }\n    /**\n     * this is a mess [not as bad as it used to be]\n     */\n    SpreadCallback(vertex, value) {\n        if (!vertex.address || !vertex.address.sheet_id) {\n            throw new Error('spread callback called without sheet id');\n        }\n        const cells = this.cells_map[vertex.address.sheet_id];\n        if (!cells) {\n            throw new Error('spread callback called without cells');\n        }\n        if (!vertex || !vertex.reference)\n            return;\n        const area = vertex.reference.area;\n        if (area) {\n            const rows = area.rows;\n            const columns = area.columns;\n            if (Array.isArray(value)) {\n                value = _utilities__WEBPACK_IMPORTED_MODULE_4__.Transpose2(value);\n                // FIXME: recycle [?]\n                for (let row = 0; row < rows; row++) {\n                    if (value[row]) {\n                        let column = 0;\n                        for (; column < columns && column < value[row].length; column++) {\n                            cells.data[row + area.start.row][column + area.start.column].SetCalculatedValue(value[row][column].value, value[row][column].type);\n                        }\n                        for (; column < columns; column++) {\n                            cells.data[row + area.start.row][column + area.start.column].SetCalculatedValue(undefined, treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.undefined);\n                        }\n                    }\n                    else {\n                        for (let column = 0; column < columns; column++) {\n                            cells.data[row + area.start.row][column + area.start.column].SetCalculatedValue(undefined, treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.undefined);\n                        }\n                    }\n                }\n            }\n            else {\n                // single, recycle\n                for (let row = 0; row < rows; row++) {\n                    for (let column = 0; column < columns; column++) {\n                        cells.data[row + area.start.row][column + area.start.column].SetCalculatedValue(value.value, value.type);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * FIXME: for this version, this should be synchronous; the whole thing\n     * should run in a worker. should be much faster than context switching\n     * every time.\n     */\n    CalculationCallback(vertex) {\n        // must have address [UPDATE: don't do this]\n        if (!vertex.address)\n            throw (new Error('vertex missing address'));\n        if (vertex.expression_error) {\n            return {\n                value: (0,_function_error__WEBPACK_IMPORTED_MODULE_13__.UnknownError)(),\n            };\n        }\n        return this.expression_calculator.Calculate(vertex.expression, vertex.address); // <- this one\n    }\n    /**\n     * generic function, broken out from the Indirect function. checks dynamic\n     * dependency for missing edges, and adds those edges.\n     *\n     * returns error on bad reference or circular dependency. this method\n     * does not set the \"short circuit\" flag, callers should set as appropriate.\n     */\n    DynamicDependencies(expression, context, offset = false, offset_rows = 0, offset_columns = 0, resize_rows = 1, resize_columns = 1) {\n        if (!this.model) {\n            // return UnknownError;\n            return undefined;\n        }\n        // UPDATE: use current context (passed in as argument) to resolve\n        // relative references. otherwise the reference will change depending\n        // on current/active sheet\n        let area = this.ResolveExpressionAddress(expression, context);\n        if (!area) {\n            return undefined;\n        }\n        // flag. we're going to check _all_ dependencies at once, just in\n        // case (for this function this would only happen if the argument\n        // is an array).\n        let dirty = false;\n        //    if (area) {\n        // check any dirty...\n        // THIS IS ALMOST CERTAINLY WRONG. we should not be using active_sheet\n        // here, we should use the area sheet. FIXME\n        area = this.model.active_sheet.RealArea(area);\n        const sheet_id = area.start.sheet_id;\n        if (offset) {\n            area = new treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Area({\n                column: area.start.column + offset_columns,\n                row: area.start.row + offset_rows,\n                sheet_id: area.start.sheet_id,\n            }, {\n                column: area.start.column + offset_columns + resize_rows - 1,\n                row: area.start.row + offset_rows + resize_columns - 1,\n                sheet_id: area.end.sheet_id,\n            });\n        }\n        for (let row = area.start.row; row <= area.end.row; row++) {\n            for (let column = area.start.column; column <= area.end.column; column++) {\n                const vertex = this.GetVertex({ row, column, sheet_id }, false);\n                if (vertex && vertex.dirty) {\n                    // so we know, given the structure of calculation, that there\n                    // is not an edge between these two vertices. we know that\n                    // because calculate() is never called on a vertex that has\n                    // dirty dependencies.\n                    // so if we create an edge here, the calculate method can\n                    // short-circuit, and then this cell will be re-evaluated\n                    // when that cell is calculated.\n                    // so all we have to do is add the edge. the question is,\n                    // do we need to remove that edge after the calculation?\n                    // or can we just wait for it to clean up on a rebuild?\n                    // (...) don't know for sure atm, test.\n                    // actually we have to set some flag to tell the vertex to\n                    // short-circuit...\n                    // before you set the short-circuit flag, test result so we\n                    // can error on circular ref\n                    // const edge_result = \n                    this.AddEdge({ row, column, sheet_id }, this.expression_calculator.context.address);\n                    //if (edge_result) {\n                    //  return ReferenceError;\n                    //}\n                    dirty = true;\n                }\n            }\n        }\n        //    }\n        return { dirty, area };\n    }\n    /**\n     * if locale has changed in Localization, update local resources.\n     * this is necessary because (in chrome) worker doesn't get the system\n     * locale properly (also, we might change it via parameter). we used to\n     * just drop and reconstruct calculator, but we want to stop doing that\n     * as part of supporting dynamic extension.\n     */\n    UpdateLocale() {\n        // don't assume default, always set\n        if (treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Localization.decimal_separator === ',') {\n            this.parser.decimal_mark = treb_parser__WEBPACK_IMPORTED_MODULE_1__.DecimalMarkType.Comma;\n            this.parser.argument_separator = treb_parser__WEBPACK_IMPORTED_MODULE_1__.ArgumentSeparatorType.Semicolon;\n        }\n        else {\n            this.parser.decimal_mark = treb_parser__WEBPACK_IMPORTED_MODULE_1__.DecimalMarkType.Period;\n            this.parser.argument_separator = treb_parser__WEBPACK_IMPORTED_MODULE_1__.ArgumentSeparatorType.Comma;\n        }\n        // this.expression_calculator.UpdateLocale();\n    }\n    /**\n     * lookup in function library\n     *\n     * it seems like the only place this is called is within this class,\n     * so we could probably inline and drop this function\n     *\n     * @deprecated\n     */\n    GetFunction(name) {\n        return this.library.Get(name);\n    }\n    /**\n     * returns a list of available functions, for AC/tooltips\n     * FIXME: categories?\n     * FIXME: need to separate annotation functions and sheet functions\n     */\n    SupportedFunctions() {\n        const list = this.library.List();\n        const function_list = Object.keys(list).map((key) => {\n            let name = list[key].canonical_name;\n            if (!name)\n                name = key.replace(/_/g, '.');\n            return {\n                name,\n                description: list[key].description,\n                arguments: (list[key].arguments || []).map((argument) => {\n                    return { name: argument.name || '' };\n                }),\n            };\n        });\n        if (this.model) {\n            for (const key of Object.keys(this.model.macro_functions)) {\n                const macro = this.model.macro_functions[key];\n                function_list.push({\n                    name: macro.name,\n                    description: macro.description,\n                    arguments: (macro.argument_names || []).map(argument => {\n                        return { name: argument };\n                    }),\n                });\n            }\n        }\n        return function_list;\n    }\n    /**\n     * dynamic extension\n     * TODO: support updating AC (need grid change, possibly call from EmbeddedSheet)\n     * FIXME: this is going to break in simulations (maybe not an issue?)\n     */\n    RegisterFunction(map) {\n        for (const name of Object.keys(map)) {\n            const descriptor = map[name];\n            const original_function = descriptor.fn;\n            // we don't bind to the actual context because that would allow\n            // functions to change it, and potentially break subsequent functions\n            // that rely on it. which is a pretty far-fetched scenario, but we might\n            // as well protect against it.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            descriptor.fn = (...args) => {\n                return original_function.apply({\n                    address: Object.assign({}, this.expression_calculator.context.address),\n                }, args);\n            };\n            this.library.Register({ [name]: descriptor });\n        }\n    }\n    /**\n     * wrap the attachdata function so we can update the expression calculator\n     * at the same time (we should unwind this a little bit, it's an artifact\n     * of graph being a separate class)\n     */\n    AttachModel(model) {\n        this.AttachData(model);\n        this.expression_calculator.SetModel(model);\n    }\n    /**\n     * wrapper method for calculation. this should be used for 1-time\n     * calculations (i.e. not in a simulation).\n     */\n    Calculate(model, subset) {\n        // this.AttachData(model); // for graph. FIXME\n        this.AttachModel(model);\n        // this gets checked later, now... it would be better if we could\n        // check it here are skip the later check, but that field is optional\n        // it's better to report the error here so we can trace\n        if (subset && !subset.start.sheet_id) {\n            throw new Error('CalculateInternal called with subset w/out sheet ID');\n        }\n        if (this.full_rebuild_required) {\n            subset = undefined;\n            this.UpdateAnnotations();\n            this.full_rebuild_required = false; // unset\n        }\n        // this.expression_calculator.SetModel(model);\n        this.RebuildGraph(subset);\n        try {\n            this.Recalculate();\n        }\n        catch (err) {\n            console.error(err);\n            console.info('calculation error trapped');\n        }\n    }\n    /**\n     * resets graph and graph status\n     */\n    Reset() {\n        this.FlushTree();\n        if (this.model) {\n            // this.AttachData(this.model);\n            this.AttachModel(this.model);\n        }\n        this.full_rebuild_required = true;\n    }\n    /**\n     * calculate an expression, optionally setting a fake cell address.\n     * this may have weird side-effects.\n     */\n    CalculateExpression(expression, address = { row: -1, column: -1 }, preserve_flags = false) {\n        return this.expression_calculator.Calculate(expression, address, preserve_flags).value; // dropping volatile flag\n    }\n    /**\n     * rebuild the graph, and set cells as clean. the vertices need internal\n     * references to the calculated value, so that's set via the vertex method.\n     *\n     * we also need to manage the list of volatile cells, which is normally\n     * built as a side-effect of calculation.\n     *\n     * UPDATE: optionally recalculate if there are volatile cells. that's used\n     * for loading documents.\n     */\n    RebuildClean(model, recalculate_if_volatile = false) {\n        this.full_rebuild_required = false; // unset\n        // this.AttachData(model);\n        // this.expression_calculator.SetModel(model);\n        this.AttachModel(model);\n        this.RebuildGraph();\n        // add leaf vertices for annotations\n        this.UpdateAnnotations(); // all\n        // there's a weird back-and-forth that happens here \n        // (calculator -> graph -> calculator) to check for volatile\n        // cells. it could probably be simplified.\n        this.InitializeGraph();\n        if (recalculate_if_volatile && this.volatile_list.length) {\n            this.Recalculate();\n        }\n    }\n    /**\n     * remove duplicates from list, dropping absolute\n     */\n    FlattenCellList(list) {\n        const map = {};\n        const flattened = [];\n        for (const entry of list) {\n            const address = {\n                column: entry.column,\n                row: entry.row,\n                sheet_id: entry.sheet_id,\n            };\n            const label = treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Area.CellAddressToLabel(address, true);\n            if (map[label]) {\n                continue;\n            }\n            map[label] = label;\n            flattened.push(address);\n        }\n        return flattened;\n    }\n    /**\n     * get a list of cells that need metadata. this is for passing to\n     * the simulation as additional cells\n     */\n    MetadataReferences(formula) {\n        const references = [];\n        if (!this.model) {\n            return references;\n        }\n        const parse_result = this.parser.Parse(formula);\n        if (parse_result.expression && parse_result.expression.type === 'call') {\n            const func = this.GetFunction(parse_result.expression.name);\n            if (!func || !func.arguments) {\n                return references;\n            }\n            for (let index = 0; index < func.arguments.length; index++) {\n                const descriptor = func.arguments[index];\n                if (!descriptor || !descriptor.metadata) {\n                    continue;\n                }\n                const arg = parse_result.expression.args[index];\n                if (!arg) {\n                    continue;\n                }\n                const area = this.ResolveExpressionAddress(arg);\n                if (area) {\n                    references.push(area.start);\n                }\n            }\n        }\n        return references;\n    }\n    RemoveAnnotation(annotation) {\n        const vertex = annotation.temp.vertex;\n        if (!vertex) {\n            return;\n        }\n        vertex.Reset();\n        this.RemoveLeafVertex(vertex);\n    }\n    UpdateAnnotations(list) {\n        if (!list && this.model)\n            list = this.model.active_sheet.annotations;\n        if (!list)\n            return;\n        if (typeof list !== 'undefined' && !Array.isArray(list)) {\n            list = [list];\n        }\n        for (const entry of list) {\n            if (entry.formula) {\n                if (!entry.temp.vertex) {\n                    entry.temp.vertex = new _dag_leaf_vertex__WEBPACK_IMPORTED_MODULE_12__.LeafVertex();\n                }\n                const vertex = entry.temp.vertex;\n                this.AddLeafVertex(vertex);\n                this.UpdateLeafVertex(vertex, entry.formula);\n            }\n        }\n    }\n    /**\n     * returns false if the sheet cannot be resolved, which probably\n     * means the name changed (that's the case we are working on with\n     * this fix).\n     */\n    ResolveSheetID(expr, context) {\n        if (!this.model) {\n            throw new Error('ResolveSheetID called without model');\n        }\n        const target = expr.type === 'address' ? expr : expr.start;\n        if (target.sheet_id) {\n            return true;\n        }\n        if (target.sheet) {\n            const lc = target.sheet.toLowerCase();\n            for (const sheet of this.model.sheets) {\n                if (sheet.name.toLowerCase() === lc) {\n                    target.sheet_id = sheet.id;\n                    return true;\n                }\n            }\n        }\n        else {\n            target.sheet_id = (context === null || context === void 0 ? void 0 : context.sheet_id) || this.model.active_sheet.id;\n            return true;\n        }\n        return false; // the error\n    }\n    // --- protected -------------------------------------------------------------\n    /**\n     * assuming the expression is an address, range, or named range, resolve\n     * to an address/area. returns undefined if the expression can't be resolved.\n     */\n    ResolveExpressionAddress(expr, context) {\n        switch (expr.type) {\n            case 'address':\n                if (this.ResolveSheetID(expr, context)) {\n                    return new treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Area(expr);\n                }\n                break;\n            case 'range':\n                if (this.ResolveSheetID(expr, context)) {\n                    return new treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Area(expr.start, expr.end);\n                }\n                break;\n            case 'identifier':\n                if (this.model) {\n                    const named_range = this.model.named_ranges.Get(expr.name.toUpperCase());\n                    if (named_range) {\n                        return new treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Area(named_range.start, named_range.end);\n                    }\n                }\n                break;\n        }\n        return undefined;\n    }\n    NamedRangeToAddressUnit(unit) {\n        if (!this.model)\n            return undefined;\n        const normalized = unit.name.toUpperCase();\n        const named_range = this.model.named_ranges.Get(normalized);\n        if (named_range) {\n            if (named_range.count === 1) {\n                return this.ConstructAddressUnit(named_range.start, normalized, unit.id, unit.position);\n            }\n            else {\n                return {\n                    type: 'range',\n                    start: this.ConstructAddressUnit(named_range.start, normalized, unit.id, unit.position),\n                    end: this.ConstructAddressUnit(named_range.end, normalized, unit.id, unit.position),\n                    label: normalized,\n                    id: unit.id,\n                    position: unit.position,\n                };\n            }\n        }\n        return undefined;\n    }\n    /** named range support */\n    ConstructAddressUnit(address, label, id, position) {\n        return {\n            type: 'address',\n            row: address.row,\n            column: address.column,\n            sheet_id: address.sheet_id,\n            label,\n            id,\n            position,\n        };\n    }\n    /**\n     * rebuild dependencies for a single expression (might be a cell, or an\n     * annotation/leaf node). can recurse on elements, so the return value\n     * is passed through. the first (outer) call can just leave it blank and\n     * use the return value.\n     *\n     * we're adding the sheet name so that (in mc expression calculator) we\n     * can turn address parameters into qualified labels. the normal routine\n     * will just use the ID as the name, that's fine, as long as it's unique\n     * (which it is).\n     *\n     * this might cause issues if we ever try to actually resolve from the\n     * sheet name, though, so (...)\n     */\n    RebuildDependencies(unit, relative_sheet_id, relative_sheet_name, dependencies = { addresses: {}, ranges: {} }, sheet_name_map) {\n        // does this get redone on every descent? dumb\n        if (!sheet_name_map) {\n            sheet_name_map = {};\n            if (this.model) {\n                for (const sheet of this.model.sheets) {\n                    sheet_name_map[sheet.name.toLowerCase()] = sheet.id;\n                }\n                if (!relative_sheet_name) {\n                    for (const sheet of this.model.sheets) {\n                        if (sheet.id === relative_sheet_id) {\n                            relative_sheet_name = sheet.name;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        switch (unit.type) {\n            case 'literal':\n            case 'missing':\n            case 'operator':\n                break;\n            case 'identifier':\n                {\n                    const resolved = this.NamedRangeToAddressUnit(unit);\n                    if (resolved) {\n                        if (resolved.type === 'address') {\n                            dependencies.addresses[resolved.label] = resolved;\n                        }\n                        else {\n                            dependencies.ranges[resolved.label] = resolved;\n                        }\n                    }\n                }\n                break;\n            case 'address':\n                if (!unit.sheet_id) {\n                    unit.sheet_id = unit.sheet ?\n                        (sheet_name_map[unit.sheet.toLowerCase()] || 0) :\n                        relative_sheet_id;\n                    if (!unit.sheet) {\n                        unit.sheet = relative_sheet_name;\n                    }\n                }\n                dependencies.addresses[unit.sheet_id + '!' + unit.label] = unit;\n                break; // this.AddressLabel(unit, offset);\n            case 'range':\n                if (!unit.start.sheet_id) {\n                    unit.start.sheet_id = unit.start.sheet ?\n                        (sheet_name_map[unit.start.sheet.toLowerCase()] || 0) :\n                        relative_sheet_id;\n                    if (!unit.start.sheet) {\n                        unit.start.sheet = relative_sheet_name;\n                    }\n                }\n                dependencies.ranges[unit.start.sheet_id + '!' + unit.start.label + ':' + unit.end.label] = unit;\n                break;\n            case 'unary':\n                this.RebuildDependencies(unit.operand, relative_sheet_id, relative_sheet_name, dependencies, sheet_name_map);\n                break;\n            case 'binary':\n                this.RebuildDependencies(unit.left, relative_sheet_id, relative_sheet_name, dependencies, sheet_name_map);\n                this.RebuildDependencies(unit.right, relative_sheet_id, relative_sheet_name, dependencies, sheet_name_map);\n                break;\n            case 'group':\n                unit.elements.forEach((element) => this.RebuildDependencies(element, relative_sheet_id, relative_sheet_name, dependencies, sheet_name_map));\n                break;\n            case 'call':\n                // this is where we diverge. if there's a known function that has\n                // an \"address\" parameter, we don't treat it as a dependency. this is\n                // to support our weird MV syntax (weird here, but useful in Excel).\n                // UPDATE: this is broadly useful for some other functions, like OFFSET.\n                {\n                    const args = unit.args.slice(0);\n                    const func = this.library.Get(unit.name);\n                    if (func && func.arguments) {\n                        func.arguments.forEach((descriptor, index) => {\n                            if (descriptor && descriptor.address) {\n                                // we still want to fix sheet addresses, though, even if we're\n                                // not tracking the dependency. to do that, we can recurse with\n                                // a new (empty) dependency list, and just drop the new list\n                                this.RebuildDependencies(args[index], relative_sheet_id, relative_sheet_name, undefined, sheet_name_map);\n                                args[index] = { type: 'missing', id: -1 };\n                            }\n                        });\n                    }\n                    args.forEach((arg) => this.RebuildDependencies(arg, relative_sheet_id, relative_sheet_name, dependencies, sheet_name_map));\n                }\n                break;\n        }\n        return dependencies;\n    }\n    UpdateLeafVertex(vertex, formula) {\n        if (!this.model) {\n            throw new Error('UpdateLeafVertex called without model');\n        }\n        vertex.Reset();\n        const parse_result = this.parser.Parse(formula);\n        if (parse_result.expression) {\n            const dependencies = this.RebuildDependencies(parse_result.expression, this.model.active_sheet.id, this.model.active_sheet.name);\n            for (const key of Object.keys(dependencies.ranges)) {\n                const unit = dependencies.ranges[key];\n                const range = new treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Area(unit.start, unit.end);\n                range.Iterate((address) => {\n                    this.AddLeafVertexEdge(address, vertex);\n                });\n                /*\n                for (const address of range) {\n                  this.AddLeafVertexEdge(address, vertex);\n                }\n                */\n            }\n            for (const key of Object.keys(dependencies.addresses)) {\n                const address = dependencies.addresses[key];\n                this.AddLeafVertexEdge(address, vertex);\n            }\n        }\n        vertex.expression = parse_result.expression || { type: 'missing', id: -1 };\n        vertex.expression_error = !parse_result.valid;\n        // vertex.UpdateState();\n    }\n    /**\n     * we're passing model here to skip the test on each call\n     *\n     * @param unit\n     * @param model\n     */\n    ApplyMacroFunctionInternal(unit, model, name_stack) {\n        switch (unit.type) {\n            case 'identifier':\n                if (name_stack[0]) {\n                    const value = name_stack[0][(unit.name || '').toUpperCase()];\n                    if (value) {\n                        return JSON.parse(JSON.stringify(value));\n                    }\n                }\n                break;\n            case 'binary':\n                unit.left = this.ApplyMacroFunctionInternal(unit.left, model, name_stack);\n                unit.right = this.ApplyMacroFunctionInternal(unit.right, model, name_stack);\n                break;\n            case 'unary':\n                unit.operand = this.ApplyMacroFunctionInternal(unit.operand, model, name_stack);\n                break;\n            case 'group':\n                unit.elements = unit.elements.map(element => this.ApplyMacroFunctionInternal(element, model, name_stack));\n                break;\n            case 'call':\n                {\n                    // do this first, so we can pass through directly\n                    unit.args = unit.args.map(arg => this.ApplyMacroFunctionInternal(arg, model, name_stack));\n                    const func = this.library.Get(unit.name);\n                    if (!func) {\n                        const macro = model.macro_functions[unit.name.toUpperCase()];\n                        if (macro && macro.expression) {\n                            // clone\n                            const expression = JSON.parse(JSON.stringify(macro.expression));\n                            const bound_names = {};\n                            if (macro.argument_names) {\n                                for (let i = 0; i < macro.argument_names.length; i++) {\n                                    const name = macro.argument_names[i].toUpperCase();\n                                    // temp just pass in\n                                    bound_names[name] = unit.args[i] ? unit.args[i] : { type: 'missing' };\n                                }\n                            }\n                            // replace arguments\n                            name_stack.unshift(bound_names);\n                            const replacement = this.ApplyMacroFunctionInternal(expression, model, name_stack);\n                            name_stack.shift();\n                            return replacement;\n                        }\n                    }\n                }\n                break;\n        }\n        return unit;\n    }\n    ApplyMacroFunctions(expression) {\n        if (!this.model) {\n            return;\n        }\n        const count = Object.keys(this.model.macro_functions).length;\n        if (!count) {\n            return;\n        }\n        return this.ApplyMacroFunctionInternal(expression, this.model, []);\n    }\n    /**\n     *\n     */\n    RebuildGraphCell(cell, address) {\n        // array head\n        if (cell.area && cell.area.start.column === address.column && cell.area.start.row === address.row) {\n            const { start, end } = cell.area;\n            const sheet_id = start.sheet_id || address.sheet_id; // ... should always be ===\n            if (!start.sheet_id) {\n                start.sheet_id = sheet_id;\n            }\n            for (let column = start.column; column <= end.column; column++) {\n                for (let row = start.row; row <= end.row; row++) {\n                    this.ResetInbound({ column, row, sheet_id }, true, false); // set dirty, don't create\n                }\n            }\n            this.SetDirty(address); // implicitly creates vertex for array head (if it doesn't already exist)\n            // implicit vertices from array head -> array members. this is required\n            // to correctly propagate dirtiness if a referenced cell changes state\n            // from array -> !array and vice-versa\n            for (let column = start.column; column <= end.column; column++) {\n                for (let row = start.row; row <= end.row; row++) {\n                    if (row === start.row && column === start.column) {\n                        continue;\n                    }\n                    this.AddEdge(start, Object.assign(Object.assign({}, start), { row, column }));\n                }\n            }\n        }\n        // formula?\n        if (cell.type === treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.formula) {\n            this.ResetInbound(address, true); // NOTE: sets dirty AND creates vertex if it doesn't exist\n            const parse_result = this.parser.Parse(cell.value);\n            // we have a couple of \"magic\" functions that can have loops\n            // but shouldn't trigger circular references. we need to check\n            // for those here...\n            if (parse_result.expression) {\n                // FIXME: move macro function parsing here; so that we don't\n                // need special call semantics, and dependencies work as normal.\n                // NOTE: the problem with that is you have to deep-parse every function,\n                // here, to look for macros. that might be OK, but the alternative is\n                // just to calculate them on demand, which seems a lot more efficient\n                // TEMP removing old macro handling\n                // const modified = this.ApplyMacroFunctions(parse_result.expression);\n                // if (modified) { parse_result.expression = modified; }\n                // ...\n                if (parse_result.expression.type === 'call') {\n                    const func = this.library.Get(parse_result.expression.name);\n                    // this is for sparklines and checkboxes atm\n                    if (func && (func.render || func.click)) {\n                        cell.render_function = func.render;\n                        cell.click_function = func.click;\n                    }\n                }\n                const dependencies = this.RebuildDependencies(parse_result.expression, address.sheet_id, ''); // cell.sheet_id);\n                for (const key of Object.keys(dependencies.ranges)) {\n                    const unit = dependencies.ranges[key];\n                    const range = new treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Area(unit.start, unit.end);\n                    // testing out array vertices (vertices that represent ranges).\n                    // this is an effort to reduce the number of vertices in the graph,\n                    // especially since these are generally unecessary (except for\n                    // formula cells).\n                    // if you want to drop this, go back to the non-array code below\n                    // and it should go back to the old way (but there will still be\n                    // some cruft in graph.ts, tests that will need to be removed).\n                    // actually it's probably something that could be balanced based\n                    // on the number of constants vs the number of formulae in the\n                    // range. more (or all) constants, use a range. more/all formula,\n                    // iterate.\n                    // --- array version -----------------------------------------------\n                    /*\n                    const status = this.AddArrayVertexEdge(range, cell);\n          \n                    if (status !== GraphStatus.OK) {\n                      global_status = status;\n                      if (!initial_reference) initial_reference = { ...cell };\n                    }\n                    */\n                    // --- non-array version -------------------------------------------\n                    /*\n                    range.Iterate((target: ICellAddress) => {\n                      this.AddEdge(target, address);\n                    });\n                    */\n                    // --- trying again... ---------------------------------------------\n                    if (range.entire_row || range.entire_column) {\n                        this.AddArrayEdge(range, address);\n                    }\n                    else {\n                        range.Iterate((target) => this.AddEdge(target, address));\n                    }\n                    // --- end ---------------------------------------------------------\n                }\n                for (const key of Object.keys(dependencies.addresses)) {\n                    const dependency = dependencies.addresses[key];\n                    this.AddEdge(dependency, address);\n                }\n            }\n            const vertex = this.GetVertex(address, true);\n            if (vertex) {\n                vertex.expression = parse_result.expression || { type: 'missing', id: -1 };\n                vertex.expression_error = !parse_result.valid;\n            }\n        }\n        else if (cell.value !== cell.calculated) {\n            // sets dirty and removes inbound edges (in case the cell\n            // previously contained a formula and now it contains a constant).\n            this.ResetInbound(address, true, false); // NOTE: sets dirty\n        }\n        else if (cell.type === treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.undefined) {\n            // in the new framework, we get here on any cleared cell, but\n            // the behavior is OK\n            // if we get here, it means that this cell was cleared but is not\n            // 'empty'; in practice, that means it has a merge cell. reset inbound\n            // and set dirty.\n            // is this unecessarily flagging a number of cells? (...)\n            this.ResetInbound(address, true, false, true);\n            // we should be able to remove this vertex altogether; watch\n            // out for arrays here\n            // this.RemoveVertex(address); // implicit\n        }\n        else {\n            // the reason you never get here is that the standard case is \n            // value !== calculated. if you enter a constant, we flush \n            // calculated first; so while the value doesn't change, it no \n            // longer === calculated.\n            // this is just a constant?\n            console.warn('UNHANDLED CASE', cell);\n        }\n    }\n    /**\n     * rebuild the graph; parse expressions, build a dependency map,\n     * initialize edges between nodes.\n     *\n     * FIXME: if we want to compose functions, we could do that here,\n     * which might result in some savings [?]\n     */\n    RebuildGraph(subset) {\n        var _a;\n        if (subset) {\n            if (!subset.start.sheet_id) {\n                throw new Error('subset missing sheet id');\n            }\n            const cells = this.cells_map[subset.start.sheet_id];\n            for (let row = subset.start.row; row <= subset.end.row; row++) {\n                const row_array = cells.data[row];\n                if (row_array) {\n                    for (let column = subset.start.column; column <= subset.end.column; column++) {\n                        const cell = row_array[column];\n                        if (cell) {\n                            this.RebuildGraphCell(cell, { row, column, sheet_id: subset.start.sheet_id });\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            for (const sheet of ((_a = this.model) === null || _a === void 0 ? void 0 : _a.sheets) || []) {\n                const rows = sheet.cells.data.length;\n                for (let row = 0; row < rows; row++) {\n                    const row_array = sheet.cells.data[row];\n                    if (row_array) {\n                        const columns = row_array.length;\n                        for (let column = 0; column < columns; column++) {\n                            const cell = row_array[column];\n                            if (cell) {\n                                this.RebuildGraphCell(cell, { row, column, sheet_id: sheet.id });\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    IsNativeOrTypedArray(val) {\n        return Array.isArray(val) || (val instanceof Float64Array) || (val instanceof Float32Array);\n    }\n    /**\n     * check if a cell is volatile. normally this falls out of the calculation,\n     * but if we build the graph and set values explicitly, we need to check.\n     */\n    CheckVolatile(vertex) {\n        if (!vertex.expression || vertex.expression_error)\n            return false;\n        let volatile = false;\n        this.parser.Walk(vertex.expression, (unit) => {\n            if (unit.type === 'call') {\n                const func = this.library.Get(unit.name);\n                if (func && func.volatile)\n                    volatile = true;\n            }\n            return !volatile; // short circuit\n        });\n        return volatile;\n    }\n}\n\n\n//# sourceURL=webpack://treb/./treb-calculator/src/calculator.ts?");

/***/ }),

/***/ "./treb-calculator/src/dag/array-vertex.ts":
/*!*************************************************!*\
  !*** ./treb-calculator/src/dag/array-vertex.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ArrayVertex\": () => (/* binding */ ArrayVertex)\n/* harmony export */ });\n/* harmony import */ var _spreadsheet_vertex_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./spreadsheet_vertex_base */ \"./treb-calculator/src/dag/spreadsheet_vertex_base.ts\");\n/* harmony import */ var _vertex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vertex */ \"./treb-calculator/src/dag/vertex.ts\");\n\n\n/**\n * this is a new cut at array vertices. unlike the old version, we are not\n * trying to reduce the number of vertices (and in fact we won't). this is\n * to handle the case of unbounded arrays (full rows or columns).\n *\n * standard behavior with an array is to create all vertices when the reference\n * is created (this is wasteful, but works). this does _not_ work for unbounded\n * arrays because we may add rows/columns later which will expand arrays.\n *\n * so this class is an intermediate vertex that sits between the dependent edge\n * and all the members of the array. if a new vertex is created later, we check\n * existing arrays to see if anyone will need to add it.\n *\n * the more arrays you have, the more expensive these checks are (we could\n * probably optimize this a bit), but it only happens at create time so\n * potentially it's not too bad -- only on initial create and when manually\n * modifying the spreadsheet.\n *\n * [FIXME: that initial create step could definitely be optimized to limit checks]\n *\n */\nclass ArrayVertex extends _spreadsheet_vertex_base__WEBPACK_IMPORTED_MODULE_0__.SpreadsheetVertexBase {\n    /**\n     * constructor adds the vertex to the internal list (static to this class).\n     *\n     * UPDATE: use the factory method, which can check if a reference to this\n     * area already exists.\n     */\n    constructor(range) {\n        super();\n        this.type = ArrayVertex.type; // for type guard\n        this.area = range.Clone();\n        ArrayVertex.list.push(this);\n    }\n    /* * temporary method, we should clean up explicitly * /\n    public static CheckOutbound(): void {\n      for (const vertex of this.list) {\n        if (vertex.edges_out.length === 0) {\n          console.info('no outbound edges', vertex);\n        }\n      }\n    }\n    */\n    /**\n     * factory/lookup method: creates a vertex if it does not exist, or\n     * returns existing vertex. returns the vertex and a flag indicating\n     * if this was created new (true) or not (false).\n     */\n    static GetVertex(area) {\n        for (const entry of this.list) {\n            if ((entry.area.start.sheet_id === area.start.sheet_id) && entry.area.Equals(area)) {\n                return [entry, false];\n            }\n        }\n        return [new ArrayVertex(area), true];\n    }\n    /**\n     * this seems sloppy, does this clean up properly?\n     */\n    static Clear() {\n        this.list = [];\n    }\n    /**\n     * returns a list of arrays that contain this address\n     */\n    static GetContainingArrays(address) {\n        // console.info('av2 get arrays:', address.row, address.column);\n        const list = [];\n        for (const entry of this.list) {\n            if ((entry.area.start.sheet_id === address.sheet_id) && entry.area.Contains(address)) {\n                // console.info(\"match\", entry.area.spreadsheet_label);\n                list.push(entry);\n            }\n        }\n        return list;\n    }\n    /**\n     * if any arrays contain this address, add edges\n     */\n    static CreateImplicitEdges(vertex, address) {\n        // console.info('av2 create implicit edges:', address.row, address.column);\n        for (const entry of this.list) {\n            if ((entry.area.start.sheet_id === address.sheet_id) && entry.area.Contains(address)) {\n                // console.info(\"add to\", entry.area.spreadsheet_label);\n                entry.DependsOn(vertex);\n            }\n        }\n    }\n    /**\n     * override for RemoveDependent. if there are no more dependents, it will\n     * be removed from our internal list (and hopefully GCd, but check).\n     */\n    RemoveDependent(edge) {\n        super.RemoveDependent(edge);\n        if (!this.edges_out.length) {\n            // console.info('removing dead array vertex');\n            this.Reset();\n            ArrayVertex.list = ArrayVertex.list.filter(test => test !== this);\n        }\n    }\n    Calculate(graph) {\n        // this is copied from SpreadsheetVertex, just removing the \n        // actual calculation (because we have no output). \n        if (!this.dirty) {\n            return;\n        }\n        if (this.color === _vertex__WEBPACK_IMPORTED_MODULE_1__.Color.white && this.LoopCheck()) {\n            // console.info('LC', this);\n            this.dirty = false;\n            if (this.edges_in.length) {\n                // intuitively this seems like a good idea but I'm not sure\n                // that it is actually necessary (TODO: check)\n                for (const edge of this.edges_out) {\n                    edge.Calculate(graph);\n                }\n                return;\n            }\n        }\n        for (const edge of this.edges_in) {\n            if (edge.dirty) {\n                return;\n            }\n        }\n        // console.info('setting dirty -> false');\n        this.dirty = false;\n        for (const edge of this.edges_out) {\n            edge.Calculate(graph);\n        }\n    }\n}\nArrayVertex.type = 'array-vertex';\n/**\n * this is the list of currently used array vertices. it will get cleaned\n * up when a vertex is no longer used (via the instance RemoveDependent\n * overload) and when the graph is reset (via the static Clear method).\n *\n * we could theoretically optimize this store, which might be useful if\n * we start using a lot of these: split by sheet ID, sort in start/end order,\n * and so on.\n */\nArrayVertex.list = [];\n// (self as any).AV2 = ArrayVertex2;\n\n\n//# sourceURL=webpack://treb/./treb-calculator/src/dag/array-vertex.ts?");

/***/ }),

/***/ "./treb-calculator/src/dag/graph.ts":
/*!******************************************!*\
  !*** ./treb-calculator/src/dag/graph.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GraphStatus\": () => (/* binding */ GraphStatus),\n/* harmony export */   \"Graph\": () => (/* binding */ Graph)\n/* harmony export */ });\n/* harmony import */ var _vertex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vertex */ \"./treb-calculator/src/dag/vertex.ts\");\n/* harmony import */ var _spreadsheet_vertex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./spreadsheet_vertex */ \"./treb-calculator/src/dag/spreadsheet_vertex.ts\");\n/* harmony import */ var _array_vertex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array-vertex */ \"./treb-calculator/src/dag/array-vertex.ts\");\n/* harmony import */ var treb_base_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! treb-base-types */ \"./treb-base-types/src/index.ts\");\n\n\n\n\n// FIXME: this is a bad habit if you're testing on falsy for OK.\nvar GraphStatus;\n(function (GraphStatus) {\n    GraphStatus[GraphStatus[\"OK\"] = 0] = \"OK\";\n    GraphStatus[GraphStatus[\"Loop\"] = 1] = \"Loop\";\n    GraphStatus[GraphStatus[\"CalculationError\"] = 2] = \"CalculationError\";\n})(GraphStatus || (GraphStatus = {}));\n/**\n * graph is now abstract, as we are extending it with the calculator.\n */\nclass Graph {\n    constructor() {\n        /**\n         * list of vertices, indexed by address as [sheet id][column][row]\n         */\n        this.vertices = [[]];\n        this.volatile_list = [];\n        this.calculation_list = [];\n        this.cells_map = {};\n        // special\n        this.leaf_vertices = [];\n        /** lock down access */\n        this.dirty_list = [];\n        /** flag set on add edge */\n        this.loop_check_required = false;\n    }\n    /*\n    public IsArrayVertex(vertex: Vertex): vertex is ArrayVertex {\n      return vertex.type === ArrayVertex.type;\n    }\n    */\n    IsSpreadsheetVertex(vertex) {\n        return vertex.type === _spreadsheet_vertex__WEBPACK_IMPORTED_MODULE_1__.SpreadsheetVertex.type;\n    }\n    /**\n     * attach data. normally this is done as part of a calculation, but we can\n     * do it without a calculation to support annotations that use leaf vertices\n     */\n    AttachData(model) {\n        this.model = model;\n        this.cells_map = {};\n        for (const sheet of model.sheets) {\n            this.cells_map[sheet.id] = sheet.cells;\n        }\n    }\n    /**\n     * flush the graph, calculation tree and cells reference\n     */\n    FlushTree() {\n        this.dirty_list = [];\n        this.volatile_list = [];\n        this.vertices = [[]];\n        this.leaf_vertices = [];\n        this.cells_map = {};\n        /** array vertex maintains its own list */\n        _array_vertex__WEBPACK_IMPORTED_MODULE_2__.ArrayVertex.Clear();\n    }\n    ResolveArrayHead(address) {\n        if (!address.sheet_id) {\n            throw new Error('resolve array head with no sheet id');\n        }\n        const cells = this.cells_map[address.sheet_id];\n        if (!cells) {\n            throw new Error('no cells? sheet id ' + address.sheet_id);\n        }\n        const row = cells.data[address.row];\n        if (row) {\n            const cell = row[address.column];\n            if (cell && cell.area) {\n                const resolved = { row: cell.area.start.row, column: cell.area.start.column, sheet_id: address.sheet_id };\n                console.info('array head', address, resolved);\n                return resolved;\n            }\n        }\n        return address;\n    }\n    /** returns the vertex at this address. creates it if necessary. */\n    GetVertex(address, create) {\n        if (!address.sheet_id) {\n            throw new Error('getvertex with no sheet id');\n        }\n        // if (!this.cells) return undefined;\n        const cells = this.cells_map[address.sheet_id];\n        if (!cells) {\n            throw new Error('no cells? sheet id ' + address.sheet_id);\n            return undefined;\n        }\n        if (!this.vertices[address.sheet_id]) {\n            if (!create) {\n                return undefined;\n            }\n            this.vertices[address.sheet_id] = [];\n        }\n        if (!this.vertices[address.sheet_id][address.column]) {\n            if (!create) {\n                return undefined;\n            }\n            this.vertices[address.sheet_id][address.column] = [];\n        }\n        else {\n            const existing_vertex = this.vertices[address.sheet_id][address.column][address.row];\n            if (existing_vertex) {\n                return existing_vertex;\n            }\n            if (!create)\n                return undefined;\n        }\n        const vertex = new _spreadsheet_vertex__WEBPACK_IMPORTED_MODULE_1__.SpreadsheetVertex();\n        // vertex.address = { ...address };\n        // because we are passing in something other than an address, we're \n        // collecting a lot of extraneous data here. I am worried that someone\n        // is relying on it, so we will force it to be just the address props.\n        // see if something breaks.\n        vertex.address = {\n            row: address.row,\n            column: address.column,\n            absolute_row: address.absolute_row,\n            absolute_column: address.absolute_column,\n            sheet_id: address.sheet_id,\n        };\n        // this breaks if the cell reference does not point to a cell; that\n        // happens if a formula references an empty cell, and we run through\n        // a serialize/unserialize pass.\n        // FIXME: ensuring the cell will work, but that seems like unecessary\n        // work; is there a way we can just let this reference dangle? the only\n        // thing we need to worry about is maintaining the dependency, so if the\n        // cell _is_ created later we get the update. (...)\n        // FIXME: the above is not working. recall the BSM model. we had\n        // \n        // =IF(C3, C3, C4 + x)\n        //\n        // with no value in C3. as a result if you type something in, it won't\n        // update because there's no bound reference. we can ensure the cell,\n        // but maybe there's way to get it to work without that.\n        // I think the reason is because the reference lookup is closed by\n        // the calc routine; so dirty doesn't do it. let's ensure cell, for now.\n        /*\n        // works ok, maybe a little verbose\n    \n        const row = cells.data2[address.row];\n        if (row) {\n          const cell = row[address.column];\n          if (cell) {\n            vertex.reference = cell;\n          }\n        }\n        */\n        vertex.reference = cells.EnsureCell(address);\n        this.vertices[address.sheet_id][address.column][address.row] = vertex;\n        // if there's an array that contains this cell, we need to create an edge\n        // this.CreateImplicitEdgeToArrays(vertex);\n        // this is back, in the new form\n        _array_vertex__WEBPACK_IMPORTED_MODULE_2__.ArrayVertex.CreateImplicitEdges(vertex, address);\n        return vertex;\n    }\n    /** deletes the vertex at this address. */\n    RemoveVertex(address) {\n        if (!address.sheet_id) {\n            throw new Error('removevertex with no sheet id');\n        }\n        const vertex = this.GetVertex(address, false);\n        if (!vertex)\n            return;\n        vertex.Reset();\n        this.vertices[address.sheet_id][address.column][address.row] = undefined;\n        // ArrayVertex2.CheckOutbound();\n    }\n    /** removes all edges, for rebuilding. leaves value/formula as-is. */\n    ResetVertex(address) {\n        const vertex = this.GetVertex(address, false);\n        if (vertex)\n            vertex.Reset();\n    }\n    /**\n     * resets the vertex by removing inbound edges and clearing formula flag.\n     * we have an option to set dirty because they get called together\n     * frequently, saves a lookup.\n     */\n    ResetInbound(address, set_dirty = false, create = true, remove = false) {\n        // console.info(\"RIB\", address.row, address.column, 'd?', set_dirty);\n        const vertex = this.GetVertex(address, create);\n        if (!vertex) {\n            if (set_dirty) {\n                const list = _array_vertex__WEBPACK_IMPORTED_MODULE_2__.ArrayVertex.GetContainingArrays(address);\n                for (const entry of list) {\n                    this.SetVertexDirty(entry);\n                }\n            }\n            return;\n        }\n        vertex.ClearDependencies();\n        if (set_dirty) {\n            // this.dirty_list.push(vertex);\n            // vertex.SetDirty();\n            this.SetVertexDirty(vertex);\n        }\n        // vertex.expression = { type: 'missing', id: -1 };\n        // vertex.expression_error = false;\n        if (remove) {\n            this.RemoveVertex(address);\n        }\n    }\n    /* * dev * /\n    public ForceClean() {\n      for (const l1 of this.vertices) {\n        if (l1) {\n          for (const l2 of l1) {\n            if (l2) {\n              for (const vertex of l2) {\n                if (vertex && vertex.dirty) {\n                  vertex.dirty = false;\n                }\n              }\n            }\n          }\n        }\n      }\n  \n    }\n  \n    / * * dev, check if any vertices are dirtices * /\n    public CheckDirty() {\n  \n      for (const l1 of this.vertices) {\n        if (l1) {\n          for (const l2 of l1) {\n            if (l2) {\n              for (const vertex of l2) {\n                if (vertex && vertex.dirty) {\n                  console.info(\"DIRTY\", `R${vertex.address?.row} C${vertex.address?.column}`, vertex);\n  \n  \n                }\n              }\n            }\n          }\n        }\n      }\n      \n    }\n    */\n    /**\n     * set all vertices to white, for the color algorithm. includes\n     * leaf vertices, although it's not necessary to check them -- we\n     * are including in case they show up via calc\n     *\n     * it should not be necessary to check constants or formula with\n     * no inbound edges (deps) so we can start those black\n     *\n     * actually those are immaterial as they should (theoretically) never\n     * get tested, if we are testing lazily\n     *\n     * actually you should be able to omit nodes with no edges out, as\n     * well... right? b/c there's no way they loop.\n     *\n     * actually all of that is a waste of time. if a vertex is never\n     * checked then it doesn't matter what color it is. save the test,\n     * just set everyone.\n     *\n     * that's not quite right, because you don't want loop errors to show\n     * up in cells that don't have deps, it doesn't make sense -- you want\n     * errors to show up where there are problems. not 100% sure how to\n     * solve that, yet...\n     *\n     */\n    ResetLoopState() {\n        for (const l1 of this.vertices) {\n            if (l1) {\n                for (const l2 of l1) {\n                    if (l2) {\n                        for (const vertex of l2) {\n                            if (vertex) {\n                                vertex.color = _vertex__WEBPACK_IMPORTED_MODULE_0__.Color.white;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // this is unecessary\n        for (const vertex of this.leaf_vertices) {\n            if (vertex.edges_in.length) {\n                vertex.color = _vertex__WEBPACK_IMPORTED_MODULE_0__.Color.white;\n            }\n        }\n    }\n    /**\n     * global check returns true if there is any loop. this is more efficient\n     * than detecting loops on every call to AddEdge. uses the color algorithm\n     * from CLRS.\n     *\n     */\n    LoopCheck() {\n        // this flag is only set on AddEdge, and only cleared when we successfully\n        // get through this function. so if there are no new edges, we can bypass.\n        if (!this.loop_check_required) {\n            return false;\n        }\n        // vertices is array [][][]\n        // build a list so we can simplify the second loop (waste of space?)\n        const list = [];\n        for (const l1 of this.vertices) {\n            if (l1) {\n                for (const l2 of l1) {\n                    if (l2) {\n                        for (const vertex of l2) {\n                            if (vertex) {\n                                vertex.color = _vertex__WEBPACK_IMPORTED_MODULE_0__.Color.white;\n                                list.push(vertex);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        const tail = (vertex) => {\n            vertex.color = _vertex__WEBPACK_IMPORTED_MODULE_0__.Color.gray;\n            for (const edge of vertex.edges_out) {\n                if (edge.color === _vertex__WEBPACK_IMPORTED_MODULE_0__.Color.gray) {\n                    this.loop_hint = this.RenderAddress(vertex.address);\n                    console.info('loop detected @', this.loop_hint);\n                    return true; // loop\n                }\n                else if (edge.color === _vertex__WEBPACK_IMPORTED_MODULE_0__.Color.white) {\n                    if (tail(edge)) {\n                        return true; // loop\n                    }\n                }\n            }\n            vertex.color = _vertex__WEBPACK_IMPORTED_MODULE_0__.Color.black;\n            return false;\n        };\n        for (const vertex of list) {\n            if (vertex.color === _vertex__WEBPACK_IMPORTED_MODULE_0__.Color.white && tail(vertex)) {\n                return true;\n            }\n        }\n        this.loop_check_required = false;\n        this.loop_hint = undefined;\n        return false;\n    }\n    /**\n     * render address as string; this is for reporting loops\n     */\n    RenderAddress(address) {\n        if (!address) {\n            return 'undefined';\n        }\n        let sheet_name = '';\n        if (address.sheet_id && this.model) {\n            for (const sheet of this.model.sheets) {\n                if (address.sheet_id === sheet.id) {\n                    sheet_name = sheet.name + '!';\n                    break;\n                }\n            }\n        }\n        const area = new treb_base_types__WEBPACK_IMPORTED_MODULE_3__.Area(address);\n        return sheet_name + area.spreadsheet_label;\n    }\n    /**\n     * new array vertices\n     */\n    AddArrayEdge(u, v) {\n        // console.info('add array edge', u, v);\n        if (!u.start.sheet_id) {\n            throw new Error('AddArrayEdge called without sheet ID');\n        }\n        // this should have already been added...\n        const v_v = this.GetVertex(v, true);\n        // create or use existing\n        const [array_vertex, created] = _array_vertex__WEBPACK_IMPORTED_MODULE_2__.ArrayVertex.GetVertex(u);\n        // add an edge\n        v_v.DependsOn(array_vertex);\n        // force a check on next calculation pass\n        this.loop_check_required = true;\n        if (!created) {\n            // console.info('reusing, so not adding edges');\n            return;\n        }\n        // now add edges from/to nodes THAT ALREADY EXIST\n        // range can't span sheets, so we only need one set to look up\n        const map = this.vertices[u.start.sheet_id];\n        // this might happen on create, we can let it go because the \n        // references will be added when the relevant sheet is added\n        if (!map) {\n            return;\n        }\n        // ...\n        if (u.entire_row) {\n            // console.group('entire row(s)')\n            for (let column = 0; column < map.length; column++) {\n                if (map[column]) {\n                    for (let row = u.start.row; row <= u.end.row; row++) {\n                        const vertex = map[column][row];\n                        if (vertex) {\n                            // console.info('add', column, row);\n                            array_vertex.DependsOn(vertex);\n                        }\n                    }\n                }\n            }\n            console.groupEnd();\n        }\n        else if (u.entire_column) {\n            // console.group('entire column(s)');\n            for (let column = u.start.column; column <= u.end.column; column++) {\n                if (map[column]) {\n                    for (const vertex of map[column]) {\n                        if (vertex === null || vertex === void 0 ? void 0 : vertex.address) {\n                            // console.info('add', vertex.address);\n                            array_vertex.DependsOn(vertex);\n                        }\n                    }\n                }\n            }\n            console.groupEnd();\n        }\n        else {\n            for (let row = u.start.row; row <= u.end.row; row++) {\n                for (let column = u.start.column; column <= u.end.column; column++) {\n                    const vertex = map[column][row];\n                    if (vertex) {\n                        array_vertex.DependsOn(vertex);\n                    }\n                }\n            }\n        }\n    }\n    /** adds an edge from u -> v */\n    AddEdge(u, v) {\n        const v_u = this.GetVertex(u, true);\n        const v_v = this.GetVertex(v, true);\n        // seems pretty uncommon, not sure it's a useful optimization\n        // const already_connected = v_u.edges_out.includes(v_v);\n        // if (already_connected) \n        //  console.info('add edge', u.sheet_id, u.row, u.column, '->', v.sheet_id, v.row, v.column, already_connected ? '***' : '')\n        // const status = this.LoopCheck(v_v, v_u);\n        // if (status === GraphStatus.Loop) { return status; }\n        v_v.DependsOn(v_u);\n        // add implicit edge to array head. this is required at start\n        // because the array isn't set implicitly (why not?)\n        // watch out for missing sheet ID!\n        if (v_u.reference && v_u.reference.area && !v_u.array_head) {\n            // console.info('add implicit edge -> array head (?), u', u, ', v', v);\n            // the old version added an implicit edge from array head -> array\n            // member, not sure why that was a good idea (or why it doesn't work);\n            // add an implicit edge -> v instead... \n            // \n            // maybe we thought it was a good idea because it would consolidate \n            // all the edges through the member? you still get edges, though...\n            this.AddEdge(Object.assign(Object.assign({}, u), { row: v_u.reference.area.start.row, column: v_u.reference.area.start.column }), v);\n        }\n        this.loop_check_required = true; // because new edges\n    }\n    /** removes edge from u -> v */\n    RemoveEdge(u, v) {\n        const v_u = this.GetVertex(u, false);\n        const v_v = this.GetVertex(v, false);\n        if (!v_u || !v_v)\n            return;\n        v_u.RemoveDependent(v_v);\n        v_v.RemoveDependency(v_u);\n    }\n    /**\n     * not used? remove\n     * @deprecated\n     */\n    SetAreaDirty(area) {\n        if (area.start.column === Infinity\n            || area.end.column === Infinity\n            || area.start.row === Infinity\n            || area.end.row === Infinity) {\n            throw new Error('don\\'t iterate over infinite area');\n        }\n        const sheet_id = area.start.sheet_id;\n        if (!sheet_id) {\n            throw new Error('invalid area, missing sheet id');\n        }\n        for (let column = area.start.column; column <= area.end.column; column++) {\n            for (let row = area.start.row; row <= area.end.row; row++) {\n                const address = { row, column, sheet_id };\n                const vertex = this.GetVertex(address, false);\n                if (vertex) {\n                    this.SetDirty(address);\n                }\n                // this.SetArraysDirty(address);\n            }\n        }\n    }\n    SetVertexDirty(vertex) {\n        // see below re: concern about relying on this\n        if (vertex.dirty) {\n            return;\n        }\n        this.dirty_list.push(vertex);\n        vertex.dirty = true;\n        for (const edge of vertex.edges_out) {\n            this.SetVertexDirty(edge);\n        }\n    }\n    /** sets dirty */\n    SetDirty(address) {\n        const vertex = this.GetVertex(address, true);\n        this.SetVertexDirty(vertex);\n    }\n    // --- leaf vertex api ---\n    /**\n     * adds a leaf vertex to the graph. this implies that someone else is\n     * managing and maintaining these vertices: we only need references.\n     */\n    AddLeafVertex(vertex) {\n        // ... don't add more than once. this is expensive but\n        // the list should (generally speaking) be short, so not\n        // a serious problem atm\n        /*\n        if (this.leaf_vertices.some((test) => test === vertex)) {\n          return;\n        }\n        */\n        for (const test of this.leaf_vertices) {\n            if (test === vertex) {\n                return;\n            }\n        }\n        this.leaf_vertices.push(vertex);\n    }\n    /** removes vertex, by match */\n    RemoveLeafVertex(vertex) {\n        this.leaf_vertices = this.leaf_vertices.filter((test) => test !== vertex);\n    }\n    /**\n     * adds an edge from u -> v where v is a leaf vertex. this doesn't use\n     * the normal semantics, and you must pass in the actual vertex instead\n     * of an address.\n     *\n     * there is no loop check (leaves are not allowed to have outbound\n     * edges).\n     */\n    AddLeafVertexEdge(u, v) {\n        const v_u = this.GetVertex(u, true);\n        v.DependsOn(v_u);\n        return GraphStatus.OK;\n    }\n    /** removes edge from u -> v */\n    RemoveLeafVertexEdge(u, v) {\n        const v_u = this.GetVertex(u, false);\n        if (!v_u)\n            return;\n        v_u.RemoveDependent(v);\n        v.RemoveDependency(v_u);\n    }\n    // --- for initial load ---\n    InitializeGraph() {\n        for (const vertex of this.dirty_list) {\n            // take reference values for spreadsheet vertices\n            if (this.IsSpreadsheetVertex(vertex)) {\n                vertex.TakeReferenceValue();\n                if (this.CheckVolatile(vertex)) {\n                    this.volatile_list.push(vertex);\n                }\n            }\n            // clear dirty flag on _all_ vertices\n            vertex.dirty = false;\n        }\n        // reset, essentially saying we're clean\n        this.dirty_list = [];\n    }\n    // --- calculation ---\n    /** runs calculation */\n    Recalculate() {\n        /*\n        if (this.GlobalLoopCheck()) {\n          return GraphStatus.Loop;\n        }\n        */\n        // FIXME: volatiles should proabbly be caclucated first,\n        // not last, because they're probably primary.\n        // for (const vertex of this.volatile_list) {\n        //  vertex.SetDirty();\n        // }\n        // const calculation_list = this.volatile_list.slice(0).concat(this.dirty_list);\n        // we do this using the local function so we can trace back arrays\n        for (const vertex of this.volatile_list) {\n            this.SetVertexDirty(vertex);\n        }\n        // const calculation_list = this.dirty_list.slice(0);\n        this.calculation_list = this.dirty_list.slice(0);\n        this.volatile_list = [];\n        this.dirty_list = [];\n        if (this.loop_check_required) {\n            // console.info('reset loop state');\n            this.ResetLoopState();\n            this.loop_check_required = false;\n        }\n        // console.info(\"CL\", calculation_list)\n        // recalculate everything that's dirty. FIXME: optimize path\n        // so we do fewer wasted checks of \"are all my deps clean\"?\n        // for (const vertex of calculation_list) {\n        //  vertex.Calculate(this);\n        //}\n        for (let i = 0; i < this.calculation_list.length; i++) {\n            this.calculation_list[i].Calculate(this);\n        }\n        this.calculation_list = [];\n    }\n}\n\n\n//# sourceURL=webpack://treb/./treb-calculator/src/dag/graph.ts?");

/***/ }),

/***/ "./treb-calculator/src/dag/leaf_vertex.ts":
/*!************************************************!*\
  !*** ./treb-calculator/src/dag/leaf_vertex.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LeafVertex\": () => (/* binding */ LeafVertex)\n/* harmony export */ });\n/* harmony import */ var _spreadsheet_vertex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./spreadsheet_vertex */ \"./treb-calculator/src/dag/spreadsheet_vertex.ts\");\n\n/**\n * second specialization of vertex: this class is for non-cell elements\n * that are dependent on cells: specifically, charts.\n *\n * we want leaf vertices to participate in the normal dirty/calculate\n * cycle, but they don't need to do any calculation other than checking\n * if the underlying data has changed. we should maintain some state so\n * this is a simple check for observers.\n *\n * leaves specifically do not have addresses. we can represent the chart\n * as a calculation, however. (...)\n *\n * FIXME: it might be better to have an intermediate class/interface and\n * have both leaf- and spreadsheet-vertex extend that.\n *\n */\nclass LeafVertex extends _spreadsheet_vertex__WEBPACK_IMPORTED_MODULE_0__.SpreadsheetVertex {\n    constructor() {\n        super(...arguments);\n        this.state_id = 0;\n        this.type = LeafVertex.type; // for type guard\n        this.state_representation = '';\n    }\n    /**\n     * construct the state, compare, and increment the state id if\n     * it changes. this is expected to be called from Calculate(), but\n     * we can also call it on init if we already know the state.\n     *\n     * FIXME: what's more expensive, generating this state field or\n     * re-rendering a chart with the same data? (...?)\n     * especially since it's only called on dirty...\n     *\n     * what is the case where the depenendency is dirty but state\n     * does not change? you type in the same value? (...) or maybe\n     * there's a volatile function that doesn't change value (e.g. Today())\n     *\n     * still, it seems like a waste here. let's test without the state.\n     * (meaning just update the flag anytime it's dirty)\n     *\n     * Actually I think the case is manual recalc, when values don't change\n     * (especially true for MC charts).\n     *\n     * TODO: perf\n     */\n    UpdateState() {\n        // FIXME: hash!\n        const state = JSON.stringify(this.edges_in.map((edge) => edge.result));\n        if (state !== this.state_representation) {\n            this.state_representation = state;\n            this.state_id++;\n        }\n    }\n    /** overrides calculate function */\n    Calculate(graph) {\n        // if we are not dirty, nothing to do\n        if (!this.dirty)\n            return;\n        // check deps\n        for (const edge of this.edges_in) {\n            if (edge.dirty) {\n                return;\n            }\n        }\n        // ok, we can evaluate... all we are doing here is checking state consistency\n        this.UpdateState();\n        this.dirty = false;\n        // we are not allowed to have edges out, so nothing to do\n    }\n    AddDependent(edge) {\n        throw (new Error('leaf vertex cannot have dependents'));\n    }\n}\nLeafVertex.type = 'leaf-vertex';\n\n\n//# sourceURL=webpack://treb/./treb-calculator/src/dag/leaf_vertex.ts?");

/***/ }),

/***/ "./treb-calculator/src/dag/spreadsheet_vertex.ts":
/*!*******************************************************!*\
  !*** ./treb-calculator/src/dag/spreadsheet_vertex.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SpreadsheetError\": () => (/* binding */ SpreadsheetError),\n/* harmony export */   \"SpreadsheetVertex\": () => (/* binding */ SpreadsheetVertex)\n/* harmony export */ });\n/* harmony import */ var _spreadsheet_vertex_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./spreadsheet_vertex_base */ \"./treb-calculator/src/dag/spreadsheet_vertex_base.ts\");\n/* harmony import */ var treb_base_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! treb-base-types */ \"./treb-base-types/src/index.ts\");\n/* harmony import */ var _vertex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vertex */ \"./treb-calculator/src/dag/vertex.ts\");\n\n\n\nvar SpreadsheetError;\n(function (SpreadsheetError) {\n    SpreadsheetError[SpreadsheetError[\"None\"] = 0] = \"None\";\n    SpreadsheetError[SpreadsheetError[\"CalculationError\"] = 1] = \"CalculationError\";\n})(SpreadsheetError || (SpreadsheetError = {}));\n/**\n * specialization of vertex with attached data and calculation metadata\n */\nclass SpreadsheetVertex extends _spreadsheet_vertex_base__WEBPACK_IMPORTED_MODULE_0__.SpreadsheetVertexBase {\n    constructor() {\n        super(...arguments);\n        this.error = SpreadsheetError.None;\n        this.result = (0,treb_base_types__WEBPACK_IMPORTED_MODULE_1__.UndefinedUnion)();\n        this.expression = { type: 'missing', id: -1 };\n        this.expression_error = false;\n        this.short_circuit = false;\n        this.type = SpreadsheetVertex.type; // for type guard\n    }\n    /**\n     * it seems like this could be cached, if it gets checked a lot\n     * also what's with the crazy return signature? [fixed]\n     */\n    get array_head() {\n        if (!this.address)\n            return false;\n        return (!!this.reference)\n            && (!!this.reference.area)\n            && (this.reference.area.start.column === this.address.column)\n            && (this.reference.area.start.row === this.address.row);\n    }\n    /**\n     * to support restoring cached values (from file), we need a way to get\n     * the value from the reference (cell). normally this is done during\n     * calculation, and in reverse (we set the value).\n     *\n     * some additional implications of this:\n     *\n     * - does not set volatile/nonvolatile, which is usually managed as a\n     *   side-effect of the calculation.\n     *\n     * - does not remove the entry from the dirty list\n     *\n     * - does not clear the internal dirty flag. it used to do that, but we\n     *   took it out because we are now managing multple vertex types, and\n     *   we don't want to attach that behavior to a type-specific method.\n     *\n     * so the caller needs to explicitly address the dirty and volatile lists\n     * for this vertex.\n     */\n    TakeReferenceValue() {\n        if (this.reference) {\n            this.result = (0,treb_base_types__WEBPACK_IMPORTED_MODULE_1__.Box)(this.reference.GetValue());\n        }\n    }\n    /**\n     * calculates the function, but only if all dependencies are clean.\n     * if one or more dependencies are dirty, just exit. this should work out\n     * so that when the last dependency is satisfied, the propagation will\n     * succeed. FIXME: optimize order.\n     *\n     * FIXME: why is this in vertex, instead of graph? [a: dirty check?]\n     * A: for overloading. leaf extends this class, and has a separate\n     * calculation routine.\n     */\n    Calculate(graph) {\n        if (!this.dirty)\n            return;\n        // it would be nice if we could get this out of the calculate routine,\n        // but that's a problem because we can't calculate in the right order.\n        // one solution might be to have two methods, one which includes it\n        // and one which doesn't, and call the checked method only when necessary.\n        // OTOH that means maintaining the internal calculation part twice (or\n        // adding a method call).\n        // especially for simulation, where we can determine ahead of time if\n        // there are any loops\n        if (this.color === _vertex__WEBPACK_IMPORTED_MODULE_2__.Color.white && this.LoopCheck()) {\n            // console.info('LC', `R${this.address?.row} C${this.address?.column}`, this);\n            // if (this.LoopCheck()) {\n            // throw new Error('loop loop 2')\n            this.dirty = false;\n            if (this.edges_in.length) {\n                // console.info('set loop err', `R${this.address?.row} C${this.address?.column}`, this);\n                // this should alwys be true, because it has edges so\n                // it must be a formula (right?)\n                // we don't have to do that test because now we only set\n                // vertices -> white if they match\n                if (this.reference && (this.array_head || this.reference.type === treb_base_types__WEBPACK_IMPORTED_MODULE_1__.ValueType.formula)) {\n                    this.reference.SetCalculationError('LOOP');\n                }\n                //this.reference?.SetCalculationError('LOOP');\n                // intuitively this seems like a good idea but I'm not sure\n                // that it is actually necessary (TODO: check)\n                for (const edge of this.edges_out) {\n                    edge.Calculate(graph);\n                }\n                return;\n            }\n            /*\n            else {\n              console.info('SKIP loop err', `R${this.address?.row} C${this.address?.column}`, this);\n            }\n            */\n            // }\n        }\n        // this is done before checking if it's a formula for the case of\n        // arrays: arrays are not formulae but they are dependent on the\n        // array head. if the head is dirty we need to calculate that before\n        // any dependents of _this_ cell are calculated.\n        // the head calculation should take care of setting this value, that is,\n        // we don't need to do the actual lookup.\n        // this prevents a runaway if there's a loop (and we are not catching it),\n        // but there's a side-effect: the dirty flag never gets cleared. if we want\n        // to fix this we need to clean the dirty flag on vertices before a full \n        // recalc, I guess...\n        // that's also why page reload \"fixes\" the issue: because there's a global\n        // cleaning of dirty flags. or maybe they don't survive serialization, I don't know.\n        for (const edge of this.edges_in) {\n            if (edge.dirty) {\n                // console.info('exiting on dirty deps', `R${this.address?.row} C${this.address?.column}`, this);\n                return;\n            }\n        }\n        // console.info('OK calc', `R${this.address?.row} C${this.address?.column}`, this);\n        // we won't have a reference if the reference is to an empty cell,\n        // so check that. [Q: what?]\n        if (this.reference) {\n            if (this.reference.type === treb_base_types__WEBPACK_IMPORTED_MODULE_1__.ValueType.formula) {\n                this.short_circuit = false;\n                const result = graph.CalculationCallback.call(graph, this);\n                // console.info(\"RX\", result);\n                this.result = result.value;\n                // this test is a waste for 99% of calls \n                //\n                // [FYI it has to do with dynamic dependencies, needs to be documented]\n                //\n                if (this.short_circuit) {\n                    return;\n                } // what about setting dirty flag? (...)\n                // and this one for ~75%?\n                if (result.volatile)\n                    graph.volatile_list.push(this);\n            }\n            else\n                this.result = this.reference.GetValue4();\n            // is this going to work properly if it's an error? (...)\n            if (this.array_head) {\n                graph.SpreadCallback.call(graph, this, this.result);\n            }\n            else if (this.reference.type === treb_base_types__WEBPACK_IMPORTED_MODULE_1__.ValueType.formula) {\n                const single = Array.isArray(this.result) ? this.result[0][0] : this.result;\n                // error is implicit\n                this.reference.SetCalculatedValue(single.value, single.type);\n                /*\n                if (typeof this.result === 'object' && this.result.error) {\n                  this.reference.SetCalculationError(this.result.error);\n                }\n                else {\n                  this.reference.SetCalculatedValue(this.result);\n                }\n                */\n            }\n        }\n        else {\n            console.info('skip dirty constant? [or dangling...]');\n        }\n        this.dirty = false;\n        // so this is causing problems in long chains. we need\n        // to do this !recursively. there's a slight problem in \n        // that we do it in the loop check as well... not sure\n        // how this will play out.\n        // some options:\n        // (1) push (dirty) edges onto a global list (or list contained in graph)\n        // (2) return boolean, with one state indicating our dependencies need calculating\n        // (3) return a list of dirty dependencies, caller can push onto their list\n        //\n        // (4) because dirty vertices are on the list, you could just loop until\n        //     the list is clean (i.e. restart and exit if there are no dirty \n        //     vertices left)... that's kind of the same as pushing onto the back of \n        //     the list but it avoids extending the list (not sure if that that is \n        //     a useful optimization or not)\n        // \n        for (const edge of this.edges_out) {\n            // (edge as SpreadsheetVertex).Calculate(graph);\n            if (edge.dirty) {\n                graph.calculation_list.push(edge);\n            }\n        }\n    }\n}\nSpreadsheetVertex.type = 'spreadsheet-vertex';\n\n\n//# sourceURL=webpack://treb/./treb-calculator/src/dag/spreadsheet_vertex.ts?");

/***/ }),

/***/ "./treb-calculator/src/dag/spreadsheet_vertex_base.ts":
/*!************************************************************!*\
  !*** ./treb-calculator/src/dag/spreadsheet_vertex_base.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SpreadsheetVertexBase\": () => (/* binding */ SpreadsheetVertexBase)\n/* harmony export */ });\n/* harmony import */ var _vertex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vertex */ \"./treb-calculator/src/dag/vertex.ts\");\n\nclass SpreadsheetVertexBase extends _vertex__WEBPACK_IMPORTED_MODULE_0__.Vertex {\n    constructor() {\n        super(...arguments);\n        this.dirty = false;\n    }\n}\n\n\n//# sourceURL=webpack://treb/./treb-calculator/src/dag/spreadsheet_vertex_base.ts?");

/***/ }),

/***/ "./treb-calculator/src/dag/vertex.ts":
/*!*******************************************!*\
  !*** ./treb-calculator/src/dag/vertex.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Color\": () => (/* binding */ Color),\n/* harmony export */   \"Vertex\": () => (/* binding */ Vertex)\n/* harmony export */ });\nvar Color;\n(function (Color) {\n    Color[Color[\"white\"] = 0] = \"white\";\n    Color[Color[\"gray\"] = 1] = \"gray\";\n    Color[Color[\"black\"] = 2] = \"black\";\n})(Color || (Color = {}));\nclass Vertex {\n    constructor() {\n        // --- members ---\n        this.type = Vertex.type; // for type guard\n        this.color = Color.white; // for loop check\n        /** dependencies */\n        this.edges_in = [];\n        /** dependents */\n        this.edges_out = [];\n        /*\n        public LoopCheck2(compare: Vertex = this): boolean {\n          this.color = Color.gray;\n      \n          for (const edge of this.edges_out) {\n            if (edge.color === Color.gray || (edge.color === Color.white && edge.LoopCheck2(compare))) {\n              this.color = Color.white; // someone else can test\n              return edge === compare; // loop\n            }\n          }\n      \n          this.color = Color.black;\n          return false;\n          \n        }\n        */\n    }\n    // --- accessors ---\n    get has_inbound_edges() { return this.edges_in.length > 0; }\n    get has_outbound_edges() { return this.edges_out.length > 0; }\n    // --- cleanup operations ---\n    /** reset this node */\n    Reset() {\n        for (const edge of this.edges_out) {\n            edge.RemoveDependency(this);\n        }\n        for (const edge of this.edges_in) {\n            edge.RemoveDependent(this);\n        }\n        this.edges_out = [];\n        this.edges_in = [];\n    }\n    /** removes all inbound edges (dependencies) */\n    ClearDependencies() {\n        for (const edge of this.edges_in) {\n            edge.RemoveDependent(this);\n        }\n        this.edges_in = [];\n    }\n    // --- basic node operations ---\n    /** add a dependent. doesn't add if already in the list */\n    AddDependent(edge) {\n        if (edge === this)\n            return; // circular\n        for (const check of this.edges_out) {\n            if (check === edge) {\n                return;\n            }\n        }\n        this.edges_out.push(edge);\n    }\n    /** remove a dependent */\n    RemoveDependent(edge) {\n        this.edges_out = this.edges_out.filter((check) => check !== edge);\n    }\n    /** add a dependency. doesn't add if already in the list */\n    AddDependency(edge) {\n        if (edge === this)\n            return; // circular\n        for (const check of this.edges_in) {\n            if (check === edge) {\n                return;\n            }\n        }\n        this.edges_in.push(edge);\n    }\n    /** remove a dependency */\n    RemoveDependency(edge) {\n        this.edges_in = this.edges_in.filter((check) => check !== edge);\n    }\n    /**\n     * this is a composite operation, because the operations are always called\n     * in pairs. this means create a pair of links such that _edge_ depends on\n     * _this_.\n     */\n    LinkTo(edge) {\n        this.AddDependent(edge);\n        edge.AddDependency(this);\n    }\n    /**\n     * this is an alteranate formulation that may make more intuitive sense.\n     * it creates a pair of forward/backward links, such that _this_ depends\n     * on _edge_.\n     */\n    DependsOn(edge) {\n        this.AddDependency(edge);\n        edge.AddDependent(this);\n    }\n    /**\n     * this is called during calculation (if necessary). on a hit (loop), we\n     * reset the color of this, the test node, to white. there are two reasons\n     * for this:\n     *\n     * one, we want subsequent tests to also find the hit. in some cases we may\n     * not be marking the node as a loop (if it precedes the backref in the graph),\n     * so we want subsequent nodes to also hit the loop. [Q: this makes no sense,\n     * because this would still hit if the node were marked grey, assuming you\n     * test for that].\n     *\n     * two, if you fix the loop, on a subsequent call we want to force a re-check,\n     * which we can do if the vertex is marked white. [Q: could also be done on\n     * gray?]\n     *\n     * [A: logically you are correct, but this works, and matching grey does not].\n     */\n    LoopCheck() {\n        this.color = Color.gray;\n        for (const edge of this.edges_out) {\n            if (edge.color === Color.gray || (edge.color === Color.white && edge.LoopCheck())) {\n                this.color = Color.white; // someone else can test\n                return true; // loop\n            }\n        }\n        this.color = Color.black;\n        return false;\n    }\n}\n/**\n * vertex and its subclasses have a type parameter for type\n * guards/reflection; each instance has a type that is set\n * to the static class type.\n */\nVertex.type = 'vertex';\n\n\n//# sourceURL=webpack://treb/./treb-calculator/src/dag/vertex.ts?");

/***/ }),

/***/ "./treb-calculator/src/descriptors.ts":
/*!********************************************!*\
  !*** ./treb-calculator/src/descriptors.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ReturnType\": () => (/* binding */ ReturnType)\n/* harmony export */ });\n// FIXME: at least some of this could move to base types\nvar ReturnType;\n(function (ReturnType) {\n    ReturnType[ReturnType[\"value\"] = 0] = \"value\";\n    ReturnType[ReturnType[\"reference\"] = 1] = \"reference\";\n})(ReturnType || (ReturnType = {}));\n\n\n//# sourceURL=webpack://treb/./treb-calculator/src/descriptors.ts?");

/***/ }),

/***/ "./treb-calculator/src/expression-calculator.ts":
/*!******************************************************!*\
  !*** ./treb-calculator/src/expression-calculator.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UnionIsExpressionUnit\": () => (/* binding */ UnionIsExpressionUnit),\n/* harmony export */   \"UnionIsMetadata\": () => (/* binding */ UnionIsMetadata),\n/* harmony export */   \"ExpressionCalculator\": () => (/* binding */ ExpressionCalculator)\n/* harmony export */ });\n/* harmony import */ var treb_base_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! treb-base-types */ \"./treb-base-types/src/index.ts\");\n/* harmony import */ var _function_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./function-error */ \"./treb-calculator/src/function-error.ts\");\n/* harmony import */ var _descriptors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./descriptors */ \"./treb-calculator/src/descriptors.ts\");\n/* harmony import */ var _primitives__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./primitives */ \"./treb-calculator/src/primitives.ts\");\n\n\n\n\n// FIXME: move\nconst UnionIsExpressionUnit = (test) => {\n    return !Array.isArray(test)\n        && test.type === treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.object\n        && (!!test.value.type);\n};\n// FIXME: move\nconst UnionIsMetadata = (test) => {\n    return !Array.isArray(test)\n        && test.type === treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.object\n        && (test.value.type === 'metadata');\n};\nclass ExpressionCalculator {\n    // --- public API -----------------------------------------------------------\n    constructor(\n    // protected readonly simulation_model: SimulationModel,\n    library, parser) {\n        this.library = library;\n        this.parser = parser;\n        this.context = {\n            address: { row: -1, column: -1 },\n            volatile: false,\n            call_index: 0,\n            // name_stack: [],\n        };\n        /**\n         * this refers to the number of function call within a single cell.\n         * so if you have a function like\n         *\n         * =A(B())\n         *\n         * then when calculating A call index should be set to 1; and when\n         * calculating B, call index is 2. and so on. this is used for keeping\n         * track of data in the simulation model, where we may have per-distribution\n         * data (generally LHS fields or correlation blocks).\n         */\n        this.call_index = 0;\n        // local reference\n        // protected cells: Cells = new Cells();\n        this.cells_map = {};\n        this.sheet_name_map = {};\n        // local reference\n        this.named_range_map = {};\n    }\n    SetModel(model) {\n        this.cells_map = {};\n        this.sheet_name_map = {};\n        for (const sheet of model.sheets) {\n            this.cells_map[sheet.id] = sheet.cells;\n            this.sheet_name_map[sheet.name.toLowerCase()] = sheet.id;\n        }\n        this.data_model = model;\n        this.named_range_map = model.named_ranges.Map();\n        this.context.model = model;\n    }\n    /**\n     * there's a case where we are calling this from within a function\n     * (which is weird, but hey) and to do that we need to preserve flags.\n     */\n    Calculate(expr, addr, preserve_flags = false) {\n        if (!preserve_flags) {\n            this.context.address = addr;\n            this.context.volatile = false;\n            this.context.call_index = 0;\n            // reset for this cell\n            this.call_index = 0; // why not in model? A: timing (nested)\n        }\n        return {\n            value: this.CalculateExpression(expr),\n            volatile: this.context.volatile,\n        };\n    }\n    // --- /public API ----------------------------------------------------------\n    /**\n     * resolve value from cell. returns a function bound to specific cell.\n     */\n    CellFunction2(expr) {\n        if (!expr.sheet_id) {\n            if (expr.sheet) {\n                expr.sheet_id = this.sheet_name_map[expr.sheet.toLowerCase()];\n            }\n            else {\n                return () => (0,_function_error__WEBPACK_IMPORTED_MODULE_1__.ReferenceError)();\n            }\n        }\n        const cells = this.cells_map[expr.sheet_id];\n        if (!cells) {\n            console.warn('missing cells reference @ ' + expr.sheet_id);\n            return () => (0,_function_error__WEBPACK_IMPORTED_MODULE_1__.ReferenceError)();\n        }\n        // reference\n        const cell = cells.GetCell(expr);\n        // this is not an error, just a reference to an empty cell\n        if (!cell) {\n            return () => {\n                return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.undefined, value: undefined };\n            };\n        }\n        // close\n        return () => cell.GetValue4();\n    }\n    /**\n     * returns range as union type. returns a single value for a single cell,\n     * or a 2d array (never a 1d array)\n     */\n    CellFunction4(start, end) {\n        if (!start.sheet_id) {\n            throw new Error('missing sheet id in CellFunction4');\n        }\n        const cells = this.cells_map[start.sheet_id];\n        return cells.GetRange4(start, end, true);\n    }\n    /** breaking this out to de-dupe */\n    GetMetadata(arg, map_result) {\n        // FIXME: we used to restrict this to non-cell functions, now\n        // we are using it for the cell function (we used to use address,\n        // which just returns the label)\n        let address;\n        let range;\n        switch (arg.type) {\n            case 'address':\n                address = arg;\n                break;\n            case 'range':\n                range = arg;\n                break;\n            case 'identifier':\n                {\n                    const named_range = this.named_range_map[arg.name.toUpperCase()];\n                    if (named_range) {\n                        if (named_range.count === 1) {\n                            address = named_range.start; // FIXME: range?\n                        }\n                        else {\n                            range = named_range;\n                        }\n                    }\n                }\n                break;\n            case 'call':\n                // we need a way to cascade the 'metadata' flag down \n                // through calls so we can use indirect/offset addressing...\n                // at the same time you don't want to cascade down indefinitely,\n                // otherwise the function call itself won't work properly...\n                // [how to resolve?]\n                {\n                    const result = this.CalculateExpression(arg, true);\n                    if (UnionIsExpressionUnit(result)) {\n                        if (result.value.type === 'address') {\n                            address = result.value;\n                        }\n                        else if (result.value.type === 'range') {\n                            range = result.value;\n                        }\n                        else {\n                            return result;\n                        }\n                    }\n                    else\n                        return result;\n                }\n                break;\n            default:\n                return this.CalculateExpression(arg);\n        }\n        if (address) {\n            // don't we have a map? [...] only for names?\n            let sheet = this.data_model.active_sheet;\n            if (address.sheet_id && address.sheet_id !== sheet.id) {\n                for (const test of this.data_model.sheets) {\n                    if (test.id === address.sheet_id) {\n                        sheet = test;\n                        break;\n                    }\n                }\n            }\n            const cell_data = sheet.CellData(address);\n            const value = // (cell_data.type === ValueType.formula) ? cell_data.calculated : cell_data.value;\n             cell_data.calculated_type ? cell_data.calculated : cell_data.value;\n            const metadata = Object.assign({ type: 'metadata', address: Object.assign({}, address), value, format: cell_data.style ? cell_data.style.number_format : undefined }, map_result(cell_data, address));\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.object, value: metadata };\n        }\n        else if (range) {\n            if (range.start.row === Infinity || range.start.column === Infinity) {\n                return (0,_function_error__WEBPACK_IMPORTED_MODULE_1__.ReferenceError)();\n            }\n            let sheet = this.data_model.active_sheet;\n            if (range.start.sheet_id && range.start.sheet_id !== sheet.id) {\n                for (const test of this.data_model.sheets) {\n                    if (test.id === range.start.sheet_id) {\n                        sheet = test;\n                        break;\n                    }\n                }\n            }\n            const range_result = [];\n            for (let column = range.start.column; column <= range.end.column; column++) {\n                const column_result = [];\n                for (let row = range.start.row; row <= range.end.row; row++) {\n                    const cell_data = sheet.CellData({ row, column });\n                    address = Object.assign(Object.assign({}, range.start), { row, column });\n                    const value = // (cell_data.type === ValueType.formula) ? cell_data.calculated : cell_data.value;\n                     cell_data.calculated_type ? cell_data.calculated : cell_data.value;\n                    const metadata = Object.assign({ type: 'metadata', address,\n                        value, format: cell_data.style ? cell_data.style.number_format : undefined }, map_result(cell_data, address));\n                    column_result.push({\n                        type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.object,\n                        value: metadata,\n                    });\n                }\n                range_result.push(column_result);\n            }\n            return range_result;\n        }\n        return this.CalculateExpression(arg);\n    }\n    RewriteMacro(unit, names) {\n        let expr;\n        switch (unit.type) {\n            case 'identifier':\n                expr = names[unit.name.toUpperCase()];\n                if (expr) {\n                    return JSON.parse(JSON.stringify(expr));\n                }\n                break;\n            case 'binary':\n                unit.left = this.RewriteMacro(unit.left, names);\n                unit.right = this.RewriteMacro(unit.right, names);\n                break;\n            case 'unary':\n                unit.operand = this.RewriteMacro(unit.operand, names);\n                break;\n            case 'group':\n                unit.elements = unit.elements.map(element => this.RewriteMacro(element, names));\n                break;\n            case 'call':\n                unit.args = unit.args.map(arg => this.RewriteMacro(arg, names));\n                break;\n        }\n        return unit;\n    }\n    CallMacro(outer, macro) {\n        var _a;\n        if (!macro.expression) {\n            return () => (0,_function_error__WEBPACK_IMPORTED_MODULE_1__.ExpressionError)();\n        }\n        const text_expr = JSON.stringify(macro.expression);\n        const names = {};\n        const upper_case_names = ((_a = macro.argument_names) === null || _a === void 0 ? void 0 : _a.map(name => name.toUpperCase())) || [];\n        return (expr) => {\n            const clone = JSON.parse(text_expr);\n            for (let i = 0; i < upper_case_names.length; i++) {\n                names[upper_case_names[i]] = expr.args[i] || { type: 'missing' };\n            }\n            return this.CalculateExpression(this.RewriteMacro(clone, names));\n        };\n    }\n    /**\n     * excutes a function call\n     *\n     * the return type of functions has never been locked down, and as a result\n     * there are a couple of things we need to handle.\n     *\n     * return type can be any value, essentially, or array, error object, or\n     * (in the case of some of the reference/lookup functions) an address or\n     * range expression. array must be 2d, I think? not sure that that is true.\n     *\n     * this wrapper function returns a function which returns one of those\n     * things, i.e. it returns (expr) => return type\n     *\n     * it will only return address/range if the parameter flag is set, so we\n     * could in theory lock it down a bit with overloads.\n     */\n    CallExpression(outer, return_reference = false) {\n        // get the function descriptor, which won't change.\n        // we can bind in closure (also short-circuit check for \n        // invalid name)\n        const func = this.library.Get(outer.name);\n        if (!func) {\n            return () => (0,_function_error__WEBPACK_IMPORTED_MODULE_1__.NameError)();\n        }\n        return (expr) => {\n            // get an index we can use for this call (we may recurse when\n            // calculating arguments), then increment for the next call.\n            const call_index = this.call_index++;\n            // yeah so this is clear. just checking volatile.\n            // FIXME: should this be set later, at the same time as the\n            // calculation index? I think it should, since we may recurse.\n            // BEFORE YOU DO THAT, track down all references that read this field\n            // from what I can tell, the only place this is read is after the\n            // external (outer) Calculate() call. so we should move this assignment,\n            // and we should also be able to get it to fail:\n            //\n            // RandBetween() should be volatile, but if we have a nonvolatile function\n            // as an argument that should unset it, and remove the volatile flag.\n            // Check?\n            // actually this works, because it only sets the flag (does not unset).\n            // volatile applies to the _cell_, not just the function -- so as long\n            // as the outer function sets the flag, it's not material if an inner\n            // function is nonvolatile. similarly an inner volatile function will\n            // make the outer function volatile.\n            // this does mean that the nonvolatile function will be treated differently\n            // if it's an argument to a volatile function, but I think that's reasonable\n            // behavior; also it's symmetric with the opposite case (inner volatile.)\n            // so leave this as-is, or you can move it -- should be immaterial\n            this.context.volatile = this.context.volatile || (!!func.volatile);\n            // NOTE: the argument logic is (possibly) calculating unecessary operations,\n            // if there's a conditional (like an IF function). although that is the\n            // exception rather than the rule...\n            // ok we can handle IF functions, at the expense of some tests... \n            // is it worth it? \n            const if_function = outer.name.toLowerCase() === 'if';\n            let skip_argument_index = -1;\n            let argument_error;\n            const argument_descriptors = func.arguments || []; // map\n            const mapped_args = expr.args.map((arg, arg_index) => {\n                // short circuit\n                if (argument_error) {\n                    return undefined;\n                }\n                // get descriptor. if the number of arguments exceeds \n                // the number of descriptors, recycle the last one\n                const descriptor = argument_descriptors[Math.min(arg_index, argument_descriptors.length - 1)] || {};\n                // if function, wrong branch\n                if (arg_index === skip_argument_index) {\n                    return descriptor.boxed ? (0,treb_base_types__WEBPACK_IMPORTED_MODULE_0__.UndefinedUnion)() : undefined;\n                }\n                // note on type here: we're iterating over the arguments \n                // described by the parse expression, not the values. although\n                // in this case, wouldn't this be a missing type? (...)\n                if (typeof arg === 'undefined') {\n                    if (if_function && arg_index === 0) {\n                        skip_argument_index = 1;\n                    }\n                    return descriptor.boxed ? (0,treb_base_types__WEBPACK_IMPORTED_MODULE_0__.UndefinedUnion)() : undefined;\n                }\n                // FIXME (address): what about named ranges (actually those will work),\n                // constructed references (we don't support them atm)?\n                // NOTE: named ranges will _not_ work, because the address will be an\n                // object, not a string. so FIXME.\n                if (descriptor.address) {\n                    return descriptor.boxed ? {\n                        type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.string,\n                        value: this.parser.Render(arg).replace(/\\$/g, ''),\n                    } : this.parser.Render(arg).replace(/\\$/g, '');\n                }\n                else if (descriptor.metadata) {\n                    return this.GetMetadata(arg, () => { return {}; }); // type is UnionOrArray\n                }\n                else {\n                    const result = this.CalculateExpression(arg);\n                    if (!Array.isArray(result) && result.type === treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.error) {\n                        if (descriptor.allow_error) {\n                            return result; // always boxed\n                        }\n                        argument_error = result;\n                        return undefined; // argument not used, so don't bother boxing\n                    }\n                    // can't shortcut if you have an array (or we need to test all the values)\n                    if (if_function && arg_index === 0 && !Array.isArray(result)) {\n                        let result_truthy = false;\n                        // if (Array.isArray(result)) { result_truthy = true; }\n                        if (result.type === treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.string) {\n                            const lowercase = result.value.toLowerCase().trim();\n                            result_truthy = lowercase !== 'false' && lowercase !== 'f';\n                        }\n                        else {\n                            result_truthy = !!result.value;\n                        }\n                        skip_argument_index = result_truthy ? 2 : 1;\n                    }\n                    if (descriptor.boxed) {\n                        return result;\n                    }\n                    if (Array.isArray(result)) {\n                        return result.map(row => row.map(value => value.value));\n                    }\n                    else {\n                        return result.value; // unboxing\n                    }\n                }\n            });\n            if (argument_error) {\n                return argument_error;\n            }\n            // if we have any nested calls, they may have updated the index so\n            // we use the captured value here.\n            this.context.call_index = call_index;\n            // I thought we were passing the model as this (...) ? actually\n            // now we bind functions that need this, so maybe we should pass\n            // null here.\n            // return func.fn.apply(null, mapped_args);\n            if (func.return_type === _descriptors__WEBPACK_IMPORTED_MODULE_2__.ReturnType.reference) {\n                const result = func.fn.apply(null, mapped_args);\n                if (return_reference) {\n                    return result;\n                }\n                if (UnionIsExpressionUnit(result)) {\n                    if (result.value.type === 'address') {\n                        return this.CellFunction2(result.value)();\n                    }\n                    else if (result.value.type === 'range') {\n                        return this.CellFunction4(result.value.start, result.value.end);\n                    }\n                }\n                return result; // error?\n            }\n            return func.fn.apply(null, mapped_args);\n        };\n    }\n    UnaryExpression(x) {\n        // there are basically three code paths here: negate, identity, and error.\n        // they have very different semantics so we're going to do them completely\n        // separately.\n        switch (x.operator) {\n            case '+':\n                return (expr) => {\n                    return this.CalculateExpression(expr.operand);\n                };\n            case '-':\n                {\n                    const func = _primitives__WEBPACK_IMPORTED_MODULE_3__.Subtract;\n                    const zero = { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: 0 };\n                    return (expr) => {\n                        const operand = this.CalculateExpression(expr.operand);\n                        if (Array.isArray(operand)) {\n                            return operand.map(column => column.map(value => func(zero, value)));\n                        }\n                        return func(zero, operand);\n                    };\n                }\n            default:\n                return () => {\n                    console.warn('unexpected unary operator:', x.operator);\n                    return (0,_function_error__WEBPACK_IMPORTED_MODULE_1__.ExpressionError)();\n                };\n        }\n    }\n    /**\n     * expands the size of an array by recycling values in columns and rows\n     *\n     * FIXME: seems like this is more a generic thing, -> utils lib\n     *\n     * @param arr 2d array\n     * @param columns target columns\n     * @param rows target rows\n     */\n    RecycleArray(arr, columns, rows) {\n        // NOTE: recycle rows first, more efficient. do it in place?\n        if (arr[0].length < rows) {\n            const len = arr[0].length;\n            for (const column of arr) {\n                for (let r = len; r < rows; r++) {\n                    column[r] = column[r % len];\n                }\n            }\n        }\n        if (arr.length < columns) {\n            const len = arr.length;\n            for (let c = len; c < columns; c++)\n                arr[c] = arr[c % len].slice(0);\n        }\n        return arr;\n    }\n    ElementwiseBinaryExpression(fn, left, right) {\n        const columns = Math.max(left.length, right.length);\n        const rows = Math.max(left[0].length, right[0].length);\n        left = this.RecycleArray(left, columns, rows);\n        right = this.RecycleArray(right, columns, rows);\n        const result = [];\n        for (let c = 0; c < columns; c++) {\n            const col = [];\n            for (let r = 0; r < rows; r++) {\n                col[r] = fn(left[c][r], right[c][r]);\n            }\n            result.push(col);\n        }\n        return result;\n    }\n    BinaryExpression(x) {\n        // we are constructing and caching functions for binary expressions.\n        // this should simplify calls when parameters change. eventually I'd\n        // like to do this for other dynamic calls as well...\n        // the idea is that we can start composing compound expressions. still\n        // not sure if that will work (or if it's a good idea).\n        // NOTE (for the future?) if one or both of the operands is a literal,\n        // we can bind that directly. literals in the expression won't change\n        // unless the expression changes, which will discard the generated\n        // function (along with the expression itself).\n        const fn = _primitives__WEBPACK_IMPORTED_MODULE_3__.MapOperator(x.operator);\n        if (!fn) {\n            return () => {\n                console.info(`(unexpected binary operator: ${x.operator})`);\n                return (0,_function_error__WEBPACK_IMPORTED_MODULE_1__.ExpressionError)();\n            };\n        }\n        else {\n            return (expr) => {\n                // sloppy typing, to support operators? (...)\n                const left = this.CalculateExpression(expr.left);\n                const right = this.CalculateExpression(expr.right);\n                // check for arrays. do elementwise operations.\n                if (Array.isArray(left)) {\n                    if (Array.isArray(right)) {\n                        return this.ElementwiseBinaryExpression(fn, left, right);\n                    }\n                    else {\n                        return this.ElementwiseBinaryExpression(fn, left, [[right]]);\n                    }\n                }\n                else if (Array.isArray(right)) {\n                    return this.ElementwiseBinaryExpression(fn, [[left]], right);\n                }\n                return fn(left, right);\n            };\n        }\n    }\n    Identifier(expr) {\n        // NOTE: TRUE and FALSE don't get here -- they are converted\n        // to literals by the parser? (...)\n        // the function we create here binds the name because\n        // this is a literal identifier. if the value were to change,\n        // the expression would be discarded.\n        // however we have to do the lookup dynamically because the\n        // underlying reference (in the named range map) might change.\n        // although it's worth noting that, atm at least, that wouldn't\n        // trigger an update because it's not considered a value change.\n        // you'd have to recalc, which would rebuild the expression anyway.\n        // call that a FIXME? (...)\n        const identifier = expr.name;\n        const upper_case = identifier.toUpperCase();\n        switch (upper_case) {\n            case 'FALSE':\n            case 'F':\n                return () => { return { value: false, type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.boolean }; };\n            case 'TRUE':\n            case 'T':\n                return () => { return { value: true, type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.boolean }; };\n            case 'UNDEFINED':\n                return () => { return { value: undefined, type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.undefined }; }; // why do we support this?\n        }\n        return () => {\n            /*\n            if (this.bound_name_stack[0]) {\n              const expr = this.bound_name_stack[0][upper_case];\n              if (expr) {\n                console.info(\"BOUND\", upper_case, expr);\n                return this.CalculateExpression(expr as ExtendedExpressionUnit);\n              }\n            }\n            */\n            const named_range = this.named_range_map[upper_case];\n            if (named_range) {\n                if (named_range.count === 1) {\n                    return this.CellFunction4(named_range.start, named_range.start);\n                }\n                else {\n                    return this.CellFunction4(named_range.start, named_range.end);\n                }\n            }\n            /*\n            const bound_names = this.context.name_stack[0];\n      \n            if (bound_names && bound_names[upper_case]) {\n              const bound_expression = bound_names[upper_case];\n              return this.CalculateExpression(bound_expression);\n            }\n            */\n            console.info('** identifier', identifier);\n            return (0,_function_error__WEBPACK_IMPORTED_MODULE_1__.NameError)();\n        };\n    }\n    GroupExpression(x) {\n        // a group is an expression in parentheses, either explicit\n        // (from the user) or implicit (created to manage operation\n        // priority, order of operations, or similar).\n        // expressions nest, so there's no case where a group should\n        // have length !== 1 -- consider that an error.\n        if (!x.elements || x.elements.length !== 1) {\n            console.warn(`Can't handle group !== 1`);\n            return () => (0,_function_error__WEBPACK_IMPORTED_MODULE_1__.ExpressionError)();\n        }\n        return (expr) => this.CalculateExpression(expr.elements[0]);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    CalculateExpression(expr, return_reference = false) {\n        // user data is a generated function for the expression, at least\n        // for the simple ones (atm). see BinaryExpression for more. the\n        // aim is to remove as many tests and lookups as possible.\n        // may be over-optimizing here.\n        if (expr.user_data) {\n            return expr.user_data(expr);\n        }\n        switch (expr.type) {\n            case 'call':\n                {\n                    const macro = this.data_model.macro_functions[expr.name.toUpperCase()];\n                    if (macro) {\n                        return (expr.user_data = this.CallMacro(expr, macro))(expr);\n                    }\n                    return (expr.user_data = this.CallExpression(expr, return_reference))(expr);\n                }\n            case 'address':\n                return (expr.user_data = this.CellFunction2(expr))(); // check\n            case 'range':\n                return (expr.user_data = (x) => this.CellFunction4(x.start, x.end))(expr); // check\n            case 'binary':\n                return (expr.user_data = this.BinaryExpression(expr))(expr); // check\n            case 'unary':\n                return (expr.user_data = this.UnaryExpression(expr))(expr); // check\n            case 'identifier':\n                return (expr.user_data = this.Identifier(expr))(); // check\n            case 'missing':\n                return (expr.user_data = () => { return { value: undefined, type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.undefined }; })(); // check\n            case 'literal':\n                {\n                    const literal = { value: expr.value, type: (0,treb_base_types__WEBPACK_IMPORTED_MODULE_0__.GetValueType)(expr.value) };\n                    return (expr.user_data = () => literal)(); // check\n                }\n            case 'group':\n                return (expr.user_data = this.GroupExpression(expr))(expr); // check\n            case 'array':\n                {\n                    return (expr.user_data = () => expr.values.map(row => (Array.isArray(row) ? row : [row]).map(value => {\n                        return { value, type: (0,treb_base_types__WEBPACK_IMPORTED_MODULE_0__.GetValueType)(value) };\n                    })))(); // check\n                }\n            default:\n                console.warn('Unhandled parse expr:', expr);\n                return (0,_function_error__WEBPACK_IMPORTED_MODULE_1__.UnknownError)();\n        }\n    }\n}\n\n\n//# sourceURL=webpack://treb/./treb-calculator/src/expression-calculator.ts?");

/***/ }),

/***/ "./treb-calculator/src/function-error.ts":
/*!***********************************************!*\
  !*** ./treb-calculator/src/function-error.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ErrorType\": () => (/* binding */ ErrorType),\n/* harmony export */   \"NotImplError\": () => (/* binding */ NotImplError),\n/* harmony export */   \"NAError\": () => (/* binding */ NAError),\n/* harmony export */   \"ExpressionError\": () => (/* binding */ ExpressionError),\n/* harmony export */   \"DataError\": () => (/* binding */ DataError),\n/* harmony export */   \"DivideByZeroError\": () => (/* binding */ DivideByZeroError),\n/* harmony export */   \"ArgumentError\": () => (/* binding */ ArgumentError),\n/* harmony export */   \"ValueError\": () => (/* binding */ ValueError),\n/* harmony export */   \"ReferenceError\": () => (/* binding */ ReferenceError),\n/* harmony export */   \"NameError\": () => (/* binding */ NameError),\n/* harmony export */   \"UnknownError\": () => (/* binding */ UnknownError),\n/* harmony export */   \"IsError\": () => (/* binding */ IsError)\n/* harmony export */ });\n/* harmony import */ var treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! treb-base-types/src */ \"./treb-base-types/src/index.ts\");\n\nvar ErrorType;\n(function (ErrorType) {\n    ErrorType[\"Argument\"] = \"ARG\";\n    ErrorType[\"Data\"] = \"DATA\";\n    ErrorType[\"Reference\"] = \"REF\";\n    ErrorType[\"Name\"] = \"NAME\";\n    ErrorType[\"Expression\"] = \"EXPR\";\n    ErrorType[\"Value\"] = \"VALUE\";\n    ErrorType[\"Unknown\"] = \"UNK\";\n    ErrorType[\"NotImpl\"] = \"NOTIMPL\";\n    ErrorType[\"Div0\"] = \"DIV/0\";\n    ErrorType[\"NA\"] = \"N/A\";\n})(ErrorType || (ErrorType = {}));\n// export const ArgumentError: FunctionError = { error: ErrorType.Argument };\n// export const ReferenceError: FunctionError = { error: ErrorType.Reference };\n//export const ExpressionError: FunctionError = { error: ErrorType.Expression };\n// export const NameError: FunctionError = { error: ErrorType.Name };\n// export const ValueError: FunctionError = { error: ErrorType.Value };\n// export const DataError: FunctionError = { error: ErrorType.Data };\n// export const DivideByZeroError: FunctionError = { error: ErrorType.Div0 };\n// export const UnknownError: FunctionError = { error: ErrorType.Unknown };\nconst NotImplError = { error: ErrorType.NotImpl };\nconst NAError = () => {\n    return { type: treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.error, value: ErrorType.NA };\n};\nconst ExpressionError = () => {\n    return { type: treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.error, value: ErrorType.Expression };\n};\nconst DataError = () => {\n    return { type: treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.error, value: ErrorType.Data };\n};\nconst DivideByZeroError = () => {\n    return { type: treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.error, value: ErrorType.Div0 };\n};\nconst ArgumentError = () => {\n    return { type: treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.error, value: ErrorType.Argument };\n};\nconst ValueError = () => {\n    return { type: treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.error, value: ErrorType.Value };\n};\nconst ReferenceError = () => {\n    return { type: treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.error, value: ErrorType.Reference };\n};\nconst NameError = () => {\n    return { type: treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.error, value: ErrorType.Name };\n};\nconst UnknownError = () => {\n    return { type: treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.error, value: ErrorType.Unknown };\n};\n/** type guard function */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst IsError = (test) => {\n    return test && typeof test.error && (test.error === ErrorType.Argument ||\n        test.error === ErrorType.Reference ||\n        test.error === ErrorType.Name ||\n        test.error === ErrorType.Expression ||\n        test.error === ErrorType.Data ||\n        test.error === ErrorType.Unknown ||\n        test.error === ErrorType.NotImpl ||\n        test.error === ErrorType.Value ||\n        test.error === ErrorType.Div0);\n};\n\n\n//# sourceURL=webpack://treb/./treb-calculator/src/function-error.ts?");

/***/ }),

/***/ "./treb-calculator/src/function-library.ts":
/*!*************************************************!*\
  !*** ./treb-calculator/src/function-library.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FunctionLibrary\": () => (/* binding */ FunctionLibrary)\n/* harmony export */ });\n/**\n * singleton (static instance) of function library; includes utility methods\n */\nclass FunctionLibrary {\n    constructor() {\n        /** the actual functions */\n        this.functions = {};\n    }\n    /**\n     * register one or more functions. keys in the passed object are\n     * considered the canonical function names, and must be (icase) unique.\n     */\n    Register(...maps) {\n        for (const map of maps) {\n            for (const name of Object.keys(map)) {\n                // some rules for names. the length thing is arbitrary, but come on.\n                // leading ascii-letter is also kind of arbitrary, but it can't be\n                // a number. the legal characters thing is probably broken: we should\n                // allow extended characters.\n                if (/[^a-zA-Z0-9._]/.test(name)) {\n                    throw new Error('invalid function name (invalid character)');\n                }\n                if (name.length > 255) {\n                    throw new Error('invalid function name (too long, > 255)');\n                }\n                if (/^[^a-zA-Z]/.test(name)) {\n                    throw new Error('invalid function name (start with an ascii letter)');\n                }\n                const normalized = name.toLowerCase();\n                if (this.functions[normalized]) {\n                    throw new Error(`function name (${normalized}) is already in use`);\n                }\n                const descriptor = map[name];\n                descriptor.canonical_name = name;\n                this.functions[normalized] = descriptor;\n            }\n        }\n    }\n    /** lookup function (actual map is protected) */\n    Get(name) {\n        const normalized = name.toLowerCase();\n        return this.functions[normalized];\n    }\n    /** get a list, for AC services */\n    List() {\n        const list = {};\n        for (const key of Object.keys(this.functions)) {\n            list[key] = this.functions[key];\n        }\n        return list;\n    }\n    /**\n     * create an alias. we clone the descriptor and use the alias as the\n     * canonical name, so should work better than just a pointer.\n     */\n    Alias(name, reference) {\n        const ref = this.Get(reference);\n        if (!ref) {\n            throw new Error(`referenced function ${reference} does not exist`);\n        }\n        this.Register({ [name]: Object.assign({}, ref) });\n    }\n}\n\n\n//# sourceURL=webpack://treb/./treb-calculator/src/function-library.ts?");

/***/ }),

/***/ "./treb-calculator/src/functions/base-functions.ts":
/*!*********************************************************!*\
  !*** ./treb-calculator/src/functions/base-functions.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BaseFunctionLibrary\": () => (/* binding */ BaseFunctionLibrary)\n/* harmony export */ });\n/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities */ \"./treb-calculator/src/utilities.ts\");\n/* harmony import */ var _function_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function-error */ \"./treb-calculator/src/function-error.ts\");\n/* harmony import */ var treb_base_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! treb-base-types */ \"./treb-base-types/src/index.ts\");\n/* harmony import */ var _sparkline__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sparkline */ \"./treb-calculator/src/functions/sparkline.ts\");\n/* harmony import */ var treb_format__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! treb-format */ \"./treb-format/src/index.ts\");\n/* harmony import */ var _checkbox__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./checkbox */ \"./treb-calculator/src/functions/checkbox.ts\");\n/* harmony import */ var _expression_calculator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../expression-calculator */ \"./treb-calculator/src/expression-calculator.ts\");\n\n\n\n\n\n\n\n/**\n * BaseFunctionLibrary is a static object that has basic spreadsheet\n * functions and associated metadata (there's also a list of aliases).\n *\n * Calculator should register this one first, followed by any other\n * application-specific libraries.\n *\n * FIXME: there's no reason this has to be a single, monolithic library.\n * we could split up by category or something.\n *\n * ALSO: add category to descriptor.\n */\n/** milliseconds in one day, used in time functions */\n// const DAY_MS = 1000 * 60 * 60 * 24;\n// some functions have semantics that can't be represented inline,\n// or we may want to refer to them from other functions.\n// OK, just one.\n/** error function (for gaussian distribution) */\nconst erf = (x) => {\n    const a1 = 0.254829592;\n    const a2 = -0.284496736;\n    const a3 = 1.421413741;\n    const a4 = -1.453152027;\n    const a5 = 1.061405429;\n    const p = 0.3275911;\n    x = Math.abs(x);\n    const t = 1 / (1 + p * x);\n    return 1 - ((((((a5 * t + a4) * t) + a3) * t + a2) * t) + a1) * t * Math.exp(-1 * x * x);\n};\n/** imprecise but reasonably fast normsinv function */\nconst inverse_normal = (q) => {\n    if (q === 0.50) {\n        return 0;\n    }\n    const p = (q < 1.0 && q > 0.5) ? (1 - q) : q;\n    const t = Math.sqrt(Math.log(1.0 / Math.pow(p, 2.0)));\n    const x = t - (2.515517 + 0.802853 * t + 0.010328 * Math.pow(t, 2.0)) /\n        (1.0 + 1.432788 * t + 0.189269 * Math.pow(t, 2.0) + 0.001308 * Math.pow(t, 3.0));\n    return (q > 0.5 ? x : -x);\n};\nconst UnionTrue = { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.boolean, value: true };\nconst UnionFalse = { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.boolean, value: false };\n// use a single, static object for base functions\nconst BaseFunctionLibrary = {\n    Rand: {\n        volatile: true,\n        fn: () => { return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number, value: Math.random() }; },\n    },\n    RandBetween: {\n        arguments: [{ name: 'min' }, { name: 'max' }],\n        volatile: true,\n        fn: (min = 0, max = 1) => {\n            if (min > max) {\n                const tmp = min;\n                min = max;\n                max = tmp;\n            }\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number, value: Math.random() * (max - min) + min };\n        },\n    },\n    Sum: {\n        description: 'Adds arguments and ranges',\n        arguments: [{ boxed: true, name: 'values or ranges' }],\n        fn: (...args) => {\n            let sum = 0;\n            const values = _utilities__WEBPACK_IMPORTED_MODULE_0__.Flatten(args);\n            for (const value of values) {\n                switch (value.type) {\n                    case treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number:\n                        sum += value.value;\n                        break;\n                    case treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.boolean:\n                        sum += (value.value ? 1 : 0);\n                        break;\n                    case treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.error: return value;\n                }\n            }\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number, value: sum };\n        },\n    },\n    Now: {\n        description: 'Returns current time',\n        volatile: true,\n        fn: () => {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number, value: (0,treb_format__WEBPACK_IMPORTED_MODULE_4__.UnlotusDate)(new Date().getTime()) };\n        },\n    },\n    Today: {\n        description: 'Returns current day',\n        volatile: true,\n        fn: () => {\n            const date = new Date();\n            date.setMilliseconds(0);\n            date.setSeconds(0);\n            date.setMinutes(0);\n            date.setHours(12);\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number, value: (0,treb_format__WEBPACK_IMPORTED_MODULE_4__.UnlotusDate)(date.getTime()) };\n        },\n    },\n    IfError: {\n        description: 'Returns the original value, or the alternate value if the original value contains an error',\n        arguments: [{ name: 'original value', allow_error: true, boxed: true }, { name: 'alternate value' }],\n        fn: (ref, value_if_error = 0) => {\n            if (ref && ref.type === treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.error) {\n                return { value: value_if_error, type: (0,treb_base_types__WEBPACK_IMPORTED_MODULE_2__.GetValueType)(value_if_error) };\n            }\n            return ref;\n        },\n    },\n    IsError: {\n        description: 'Checks if another cell contains an error',\n        arguments: [{ name: 'reference', allow_error: true, boxed: true }],\n        fn: (ref) => {\n            if (Array.isArray(ref)) {\n                const values = _utilities__WEBPACK_IMPORTED_MODULE_0__.Flatten(ref);\n                for (const value of values) {\n                    if (value.type === treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.error) {\n                        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.boolean, value: true };\n                    }\n                }\n            }\n            else if (ref) {\n                return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.boolean, value: ref.type === treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.error };\n            }\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.boolean, value: false };\n        },\n    },\n    Cell: {\n        description: 'Returns data about a cell',\n        arguments: [\n            { name: 'type', description: 'Type of data to return' },\n            { name: 'reference', description: 'Cell reference', metadata: true },\n        ],\n        // there's no concept of \"structure volatile\", and structure events\n        // don't trigger recalc, so this is not helpful -- we may need to \n        // think about both of those things\n        // volatile: true, \n        fn: (type, reference) => {\n            if (!(0,_expression_calculator__WEBPACK_IMPORTED_MODULE_6__.UnionIsMetadata)(reference)) {\n                return (0,_function_error__WEBPACK_IMPORTED_MODULE_1__.ReferenceError)();\n            }\n            if (type) {\n                switch (type.toString().toLowerCase()) {\n                    case 'format':\n                        return reference.value.format ? // || ReferenceError;\n                            { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.string, value: reference.value.format } : (0,_function_error__WEBPACK_IMPORTED_MODULE_1__.ReferenceError)();\n                    case 'address':\n                        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.string, value: reference.value.address.label.replace(/\\$/g, '') };\n                }\n            }\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.error, value: _function_error__WEBPACK_IMPORTED_MODULE_1__.NotImplError.error };\n        },\n    },\n    Year: {\n        description: 'Returns year from date',\n        arguments: [{\n                name: 'date',\n            }],\n        fn: (source) => {\n            return (0,treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Box)(new Date((0,treb_format__WEBPACK_IMPORTED_MODULE_4__.LotusDate)(source)).getUTCFullYear());\n        },\n    },\n    Month: {\n        description: 'Returns month from date',\n        arguments: [{\n                name: 'date',\n            }],\n        fn: (source) => {\n            return (0,treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Box)(new Date((0,treb_format__WEBPACK_IMPORTED_MODULE_4__.LotusDate)(source)).getUTCMonth() + 1); // 0-based\n        },\n    },\n    Day: {\n        description: 'Returns day of month from date',\n        arguments: [{\n                name: 'date',\n            }],\n        fn: (source) => {\n            return (0,treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Box)(new Date((0,treb_format__WEBPACK_IMPORTED_MODULE_4__.LotusDate)(source)).getUTCDate());\n        },\n    },\n    Radians: {\n        description: 'Converts degrees to radians',\n        arguments: [{ name: 'Degrees', description: 'Angle in degrees' }],\n        fn: _utilities__WEBPACK_IMPORTED_MODULE_0__.ApplyAsArray((degrees) => {\n            return (0,treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Box)(degrees * Math.PI / 180);\n        }),\n    },\n    Degrees: {\n        description: 'Converts radians to degrees',\n        arguments: [{ name: 'Radians', description: 'Angle in radians' }],\n        fn: _utilities__WEBPACK_IMPORTED_MODULE_0__.ApplyAsArray((radians) => {\n            return (0,treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Box)(radians / Math.PI * 180);\n        }),\n    },\n    CountA: {\n        description: 'Counts cells that are not empty',\n        fn: (...args) => {\n            return (0,treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Box)(_utilities__WEBPACK_IMPORTED_MODULE_0__.Flatten(args).reduce((a, b) => {\n                if (typeof b === 'undefined')\n                    return a;\n                return a + 1;\n            }, 0));\n        },\n    },\n    Count: {\n        description: 'Counts cells that contain numbers',\n        fn: (...args) => {\n            return (0,treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Box)(_utilities__WEBPACK_IMPORTED_MODULE_0__.Flatten(args).reduce((a, b) => {\n                if (typeof b === 'number')\n                    return a + 1;\n                return a;\n            }, 0));\n        },\n    },\n    Or: {\n        fn: (...args) => {\n            let result = false;\n            args = _utilities__WEBPACK_IMPORTED_MODULE_0__.Flatten(args);\n            for (const arg of args) {\n                result = result || !!arg;\n            }\n            return (0,treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Box)(result);\n        },\n    },\n    And: {\n        fn: (...args) => {\n            let result = true;\n            args = _utilities__WEBPACK_IMPORTED_MODULE_0__.Flatten(args);\n            for (const arg of args) {\n                result = result && !!arg;\n            }\n            return (0,treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Box)(result);\n        },\n    },\n    Not: {\n        fn: (...args) => {\n            if (args.length === 0) {\n                return (0,_function_error__WEBPACK_IMPORTED_MODULE_1__.ArgumentError)();\n            }\n            if (args.length === 1) {\n                return (0,treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Box)(!args[0]);\n            }\n            return (0,treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Box)(true);\n        }\n    },\n    If: {\n        arguments: [\n            { name: 'test value', boxed: true },\n            { name: 'value if true', boxed: true, allow_error: true },\n            { name: 'value if false', boxed: true, allow_error: true },\n        ],\n        fn: (a, b = UnionTrue, c = UnionFalse) => {\n            if (Array.isArray(a)) {\n                return a.map((row, x) => row.map((cell, y) => {\n                    const value = treb_base_types__WEBPACK_IMPORTED_MODULE_2__.UnionIs.String(cell) ?\n                        (cell.value.toLowerCase() !== 'false' && cell.value.toLowerCase() !== 'f') : !!cell.value;\n                    return value ? (Array.isArray(b) ? b[x][y] : b) : (Array.isArray(c) ? c[x][y] : c);\n                }));\n            }\n            const value = treb_base_types__WEBPACK_IMPORTED_MODULE_2__.UnionIs.String(a) ?\n                (a.value.toLowerCase() !== 'false' && a.value.toLowerCase() !== 'f') : !!a.value;\n            return value ? b : c;\n        },\n    },\n    Fact: {\n        description: 'Returns the factorial of a number',\n        arguments: [\n            { name: 'number' },\n        ],\n        fn: _utilities__WEBPACK_IMPORTED_MODULE_0__.ApplyAsArray((number) => {\n            number = Math.floor(number);\n            let value = 1;\n            while (number > 1) {\n                value *= number;\n                number--;\n            }\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number,\n                value,\n            };\n        }),\n    },\n    Power: {\n        fn: _utilities__WEBPACK_IMPORTED_MODULE_0__.ApplyAsArray2((base, exponent) => (0,treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Box)(Math.pow(base, exponent))),\n    },\n    Mod: {\n        fn: _utilities__WEBPACK_IMPORTED_MODULE_0__.ApplyAsArray2((num, divisor) => {\n            if (!divisor) {\n                return (0,_function_error__WEBPACK_IMPORTED_MODULE_1__.DivideByZeroError)();\n            }\n            return (0,treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Box)(num % divisor);\n        })\n    },\n    /**\n     * sort arguments, but ensure we return empty strings to\n     * fill up the result array\n     */\n    Sort: {\n        arguments: [\n            { name: 'values' }\n        ],\n        fn: (...args) => {\n            args = _utilities__WEBPACK_IMPORTED_MODULE_0__.Flatten(args);\n            if (args.every(test => typeof test === 'number')) {\n                args.sort((a, b) => a - b);\n            }\n            else {\n                args.sort(); // lexical\n            }\n            return [args.map(value => (0,treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Box)(value))];\n        },\n    },\n    Transpose: {\n        description: 'Returns transpose of input matrix',\n        arguments: [{ name: 'matrix', boxed: true }],\n        fn: (mat) => {\n            if (Array.isArray(mat)) {\n                return _utilities__WEBPACK_IMPORTED_MODULE_0__.Transpose2(mat);\n            }\n            return mat;\n        }\n    },\n    Max: {\n        fn: (...args) => {\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number,\n                value: Math.max.apply(0, _utilities__WEBPACK_IMPORTED_MODULE_0__.Flatten(args).filter(x => typeof x === 'number')),\n            };\n        },\n    },\n    Min: {\n        fn: (...args) => {\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number,\n                value: Math.min.apply(0, _utilities__WEBPACK_IMPORTED_MODULE_0__.Flatten(args).filter(x => typeof x === 'number')),\n            };\n        },\n    },\n    /*\n    MMult: {\n      description: 'Multiplies two matrices',\n      arguments: [{ name: 'Matrix 1'}, { name: 'Matrix 2'}],\n      fn: (a, b) => {\n        if (!a || !b) return ArgumentError;\n\n        const a_cols = a.length || 0;\n        const a_rows = a[0]?.length || 0;\n\n        const b_cols = b.length || 0;\n        const b_rows = b[0]?.length || 0;\n\n        if (!a_rows || !b_rows || !a_cols || !b_cols\n           || a_rows !== b_cols || a_cols !== b_rows) return ValueError;\n\n        const result: number[][] = [];\n\n        // slightly confusing because we're column-major\n\n        for (let c = 0; c < b_cols; c++) {\n          result[c] = [];\n          for (let r = 0; r < a_rows; r++) {\n            result[c][r] = 0;\n            for (let x = 0; x < a_cols; x++) {\n              result[c][r] += a[x][r] * b[c][x];\n            }\n          }\n        }\n        return result;\n\n      }\n    },\n    */\n    SumProduct: {\n        description: 'Returns the sum of pairwise products of two or more ranges',\n        fn: (...args) => {\n            const flattened = args.map(arg => _utilities__WEBPACK_IMPORTED_MODULE_0__.Flatten(arg));\n            const len = Math.max.apply(0, flattened.map(x => x.length));\n            let sum = 0;\n            for (let i = 0; i < len; i++) {\n                sum += flattened.reduce((a, arg) => {\n                    return a * (arg[i] || 0);\n                }, 1);\n            }\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number, value: sum };\n        },\n    },\n    /**\n     * FIXME: does not implement inexact matching (what's the algo for\n     * that, anyway? nearest? price is right style? what about ties?)\n     */\n    VLookup: {\n        fn: (value, table, col, inexact = true) => {\n            col = Math.max(0, col - 1);\n            if (inexact) {\n                let min = Math.abs(value - table[0][0]);\n                let result = table[col][0];\n                for (let i = 1; i < table[0].length; i++) {\n                    const abs = Math.abs(table[0][i] - value);\n                    if (abs < min) { // implies first match\n                        min = abs;\n                        result = table[col][i];\n                    }\n                }\n                return (0,treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Box)(result);\n            }\n            else {\n                for (let i = 1; i < table[0].length; i++) {\n                    if (table[0][i] == value) { // ==\n                        return table[col][i];\n                    }\n                }\n                return (0,_function_error__WEBPACK_IMPORTED_MODULE_1__.NAError)();\n            }\n        },\n    },\n    Product: {\n        fn: (...args) => {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number, value: _utilities__WEBPACK_IMPORTED_MODULE_0__.Flatten(args).reduce((a, b) => {\n                    if (typeof b === 'undefined')\n                        return a;\n                    return a * Number(b);\n                }, 1) };\n        },\n    },\n    Log: {\n        /** default is base 10; allow specific base */\n        fn: _utilities__WEBPACK_IMPORTED_MODULE_0__.ApplyAsArray2((a, base = 10) => {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number, value: Math.log(a) / Math.log(base) };\n        }),\n    },\n    Log10: {\n        fn: _utilities__WEBPACK_IMPORTED_MODULE_0__.ApplyAsArray((a) => {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number, value: Math.log(a) / Math.log(10) };\n        }),\n    },\n    Ln: {\n        fn: _utilities__WEBPACK_IMPORTED_MODULE_0__.ApplyAsArray((a) => {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number, value: Math.log(a) };\n        }),\n    },\n    Round: {\n        fn: _utilities__WEBPACK_IMPORTED_MODULE_0__.ApplyAsArray2((a, digits = 0) => {\n            const m = Math.pow(10, digits);\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number,\n                value: Math.round(m * a) / m,\n            };\n        }),\n    },\n    RoundDown: {\n        fn: _utilities__WEBPACK_IMPORTED_MODULE_0__.ApplyAsArray2((a, digits = 0) => {\n            const m = Math.pow(10, digits);\n            const positive = a >= 0;\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number,\n                value: positive ? Math.floor(m * a) / m : Math.ceil(m * a) / m,\n            };\n        }),\n    },\n    /*\n\n    Round: {\n      description: 'Round to a specified number of digits',\n\n      / ** round with variable digits * /\n      fn: (value: number, digits = 0) => {\n        const m = Math.pow(10, digits);\n        return Math.round(m * value) / m;\n      },\n    },\n\n    RoundDown: {\n      / ** round down with variable digits * /\n      fn: (value: number, digits = 0) => {\n        digits = Math.max(0, digits);\n        const m = Math.pow(10, digits);\n        return Math.floor(m * value) / m;\n      },\n    },\n\n\n    */\n    Reverse: {\n        arguments: [\n            { boxed: true },\n        ],\n        fn: (a) => {\n            if (Array.isArray(a)) {\n                if (a.length === 1)\n                    return [a[0].reverse()];\n                return a.reverse();\n            }\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.string,\n                value: a.value.toString().split('').reverse().join(''),\n            };\n        },\n    },\n    Abs: {\n        fn: _utilities__WEBPACK_IMPORTED_MODULE_0__.ApplyAsArray((a) => {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number, value: Math.abs(a) };\n        }),\n    },\n    Simplify: {\n        fn: _utilities__WEBPACK_IMPORTED_MODULE_0__.ApplyAsArray2((value, significant_digits = 2) => {\n            significant_digits = significant_digits || 2;\n            if (value === 0) {\n                return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number, value };\n            }\n            const negative = value < 0 ? -1 : 1;\n            value *= negative;\n            const x = Math.pow(10, Math.floor(Math.log10(value)) + 1 - significant_digits);\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number,\n                value: Math.round(value / x) * x * negative\n            };\n        }),\n    },\n    Erf: {\n        fn: (a) => {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number, value: erf(a) };\n        },\n    },\n    'NormsInv': {\n        description: 'Inverse of the normal cumulative distribution',\n        arguments: [\n            { name: 'probability' },\n        ],\n        fn: (q) => {\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number,\n                value: inverse_normal(q),\n            };\n        }\n    },\n    'Norm.Inv': {\n        description: 'Inverse of the normal cumulative distribution',\n        arguments: [\n            { name: 'probability' },\n            { name: 'mean', default: 0 },\n            { name: 'standard deviation', default: 1 },\n        ],\n        fn: (q, mean = 0, stdev = 1) => {\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number,\n                value: inverse_normal(q) * stdev + mean,\n            };\n        }\n    },\n    'Norm.Dist': {\n        description: 'Cumulative normal distribution',\n        arguments: [\n            { name: 'value' },\n            { name: 'mean', default: 0 },\n            { name: 'standard deviation', default: 1 },\n        ],\n        fn: (x, mean = 0, stdev = 1) => {\n            // generalized\n            const sign = (x < mean) ? -1 : 1;\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number,\n                value: 0.5 * (1.0 + sign * erf((Math.abs(x - mean)) / (stdev * Math.sqrt(2)))),\n            };\n        },\n    },\n    HexToDec: {\n        arguments: [{ description: 'hexadecimal string' }],\n        fn: (hex) => {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number, value: parseInt(hex, 16) };\n        },\n    },\n    DecToHex: {\n        arguments: [{ description: 'number' }],\n        fn: (num) => {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.string, value: num.toString(16) };\n        },\n    },\n    Checkbox: {\n        arguments: [\n            { name: 'checked' },\n        ],\n        click: _checkbox__WEBPACK_IMPORTED_MODULE_5__.ClickCheckbox,\n        render: _checkbox__WEBPACK_IMPORTED_MODULE_5__.RenderCheckbox,\n        fn: (checked) => {\n            return { value: !!checked, type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.boolean, };\n        },\n    },\n    'Sparkline.Column': {\n        arguments: [\n            { name: 'data' },\n            { name: 'color' },\n            { name: 'negative color' }\n        ],\n        render: (options) => {\n            _sparkline__WEBPACK_IMPORTED_MODULE_3__.Sparkline.RenderColumn(options.width, options.height, options.context, options.cell, options.style);\n            return { handled: true }; // painted\n        },\n        fn: (...args) => {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.object, value: args };\n        },\n    },\n    'Sparkline.Line': {\n        arguments: [\n            { name: 'data' },\n            { name: 'color' },\n            { name: 'line width' },\n        ],\n        render: (options) => {\n            _sparkline__WEBPACK_IMPORTED_MODULE_3__.Sparkline.RenderLine(options.width, options.height, options.context, options.cell, options.style);\n            return { handled: true }; // painted\n        },\n        fn: (...args) => {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.object, value: args };\n        },\n    }\n};\n// alias\n// add functions from Math (intrinsic), unless the name overlaps\n// with something already in there\n// we need to construct a separate map to match icase (this is now\n// even more useful since we have a separate section for aliases)\nconst name_map = {};\nfor (const key of Object.keys(BaseFunctionLibrary)) {\n    name_map[key.toLowerCase()] = key;\n}\nfor (const name of Object.getOwnPropertyNames(Math)) {\n    // check if it exists (we have already registered something\n    // with the same name) -- don't override existing\n    if (name_map[name.toLowerCase()]) {\n        continue;\n    }\n    const descriptor = Object.getOwnPropertyDescriptor(Math, name);\n    if (!descriptor) {\n        continue;\n    }\n    const value = descriptor.value;\n    const type = typeof (value);\n    switch (type) {\n        case 'number':\n            // console.info(\"MATH CONSTANT\", name);\n            BaseFunctionLibrary[name] = {\n                fn: () => {\n                    return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number, value };\n                },\n                category: ['Math Functions'],\n            };\n            break;\n        case 'function':\n            // console.info(\"MATH FUNC\", name);\n            BaseFunctionLibrary[name] = {\n                fn: (...args) => {\n                    return (0,treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Box)(value(...args));\n                },\n                category: ['Math Functions'],\n            };\n            break;\n        default:\n            console.info('unexpected type:', type, name);\n            break;\n    }\n}\n// IE11: patch log10 function // FIXME: is this necessary anymore?\nif (!Math.log10) {\n    Math.log10 = (a) => Math.log(a) / Math.log(10);\n    /*\n    BaseFunctionLibrary.log10 = {\n      fn: (x) => Math.log(x) / Math.log(10),\n      category: ['Math Functions'],\n    };\n    */\n}\n\n\n//# sourceURL=webpack://treb/./treb-calculator/src/functions/base-functions.ts?");

/***/ }),

/***/ "./treb-calculator/src/functions/checkbox.ts":
/*!***************************************************!*\
  !*** ./treb-calculator/src/functions/checkbox.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ClickCheckbox\": () => (/* binding */ ClickCheckbox),\n/* harmony export */   \"RenderCheckbox\": () => (/* binding */ RenderCheckbox)\n/* harmony export */ });\n/* harmony import */ var treb_base_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! treb-base-types */ \"./treb-base-types/src/index.ts\");\n\nconst ClickCheckbox = (options) => {\n    const { x, y, width, height, cell } = options;\n    const result = {};\n    const offset = 3;\n    if (cell && width && height && x && y) {\n        const box = {\n            x: offset,\n            y: height - offset - 16, //  Math.round(height / 2 - 8);\n        };\n        if (cell.style) {\n            switch (cell.style.vertical_align) {\n                case treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Style.VerticalAlign.Top:\n                    box.y = offset;\n                    break;\n                case treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Style.VerticalAlign.Middle:\n                    box.y = Math.round(height / 2 - 8);\n                    break;\n            }\n            switch (cell.style.horizontal_align) {\n                case treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Style.HorizontalAlign.Right:\n                    box.x = Math.round(width - offset - 16);\n                    break;\n                case treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Style.HorizontalAlign.Center:\n                    box.x = Math.round(width / 2 - 8);\n                    break;\n            }\n        }\n        /*\n        const box = {\n          x: Math.round(width / 2 - 8),\n          y: Math.round(height / 2 - 8),\n        };\n        */\n        if (x >= box.x && x <= box.x + 16 && y >= box.y && y <= box.y + 16) {\n            result.value = `=Checkbox(${cell.calculated ? 'FALSE' : 'TRUE'})`;\n            result.block_selection = true;\n        }\n    }\n    return result;\n};\nconst RenderCheckbox = (options) => {\n    const { context, width, height, cell } = options;\n    const scale = options.scale || 1;\n    context.lineJoin = 'round';\n    context.lineCap = 'round';\n    const offset = 3 * scale;\n    let x = offset; // Math.round(width / 2 - 8);\n    let y = height - offset - 16 * scale; //  Math.round(height / 2 - 8);\n    if (cell.style) {\n        switch (cell.style.vertical_align) {\n            case treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Style.VerticalAlign.Top:\n                y = offset;\n                break;\n            case treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Style.VerticalAlign.Middle:\n                y = Math.round(height / 2 - 8 * scale);\n                break;\n        }\n        switch (cell.style.horizontal_align) {\n            case treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Style.HorizontalAlign.Right:\n                x = Math.round(width - offset - 16 * scale);\n                break;\n            case treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Style.HorizontalAlign.Center:\n                x = Math.round(width / 2 - 8 * scale);\n                break;\n        }\n    }\n    if (cell && cell.calculated) {\n        context.lineWidth = .5;\n        context.fillStyle = context.strokeStyle;\n        context.beginPath();\n        context.moveTo(x, y);\n        context.lineTo(x + 16 * scale, y);\n        context.lineTo(x + 16 * scale, y + 16 * scale);\n        context.lineTo(x, y + 16 * scale);\n        context.closePath();\n        context.moveTo(x + 15 * scale, y + 4 * scale);\n        for (const point of [\n            [13.59, 2.58],\n            [6, 10.17],\n            [2.41, 6.59],\n            [1, 8],\n            [6, 13],\n        ]) {\n            context.lineTo(x + point[0] * scale, y + point[1] * scale);\n        }\n        context.closePath();\n        context.fill();\n    }\n    else {\n        context.lineWidth = Math.max(2, 2 * scale);\n        context.strokeRect(x, y, 16 * scale, 16 * scale);\n    }\n    return { handled: true }; // painted\n};\n\n\n//# sourceURL=webpack://treb/./treb-calculator/src/functions/checkbox.ts?");

/***/ }),

/***/ "./treb-calculator/src/functions/finance-functions.ts":
/*!************************************************************!*\
  !*** ./treb-calculator/src/functions/finance-functions.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FinanceFunctionLibrary\": () => (/* binding */ FinanceFunctionLibrary)\n/* harmony export */ });\n/* harmony import */ var treb_base_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! treb-base-types */ \"./treb-base-types/src/index.ts\");\n/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilities */ \"./treb-calculator/src/utilities.ts\");\n\n\n// use a single, static object for base functions\n/**\n * some random web resources, more or less helpful:\n *\n * http://www.ultimatecalculators.com/future_value_annuity_calculator.html\n * https://financeformulas.net/Annuity-Due-Payment-from-Present-Value.html\n * http://www.tvmcalcs.com/tvm/formulas/regular_annuity_formulas\n */\n/**\n * this function is broken out because we use it in the rate function\n * (to search). we could reasonably use any of them (we probably should\n * use the one most likely to be zero -- FV maybe?)\n *\n * this is now used in a couple of functions, so it makes sense to leave\n * it broken out irrespective of what we use for Rate.\n *\n */\nconst payment_function = (rate, periods, pv = 0, fv = 0, type = 0) => {\n    if (type) {\n        return -(pv * (rate / (1 - Math.pow(1 + rate, -periods)))) / (1 + rate)\n            - (fv * (1 / ((1 + rate) * ((Math.pow(1 + rate, periods) - 1) / rate))));\n    }\n    return -(pv * rate * Math.pow(1 + rate, periods) + fv * rate) / (Math.pow(1 + rate, periods) - 1);\n};\n/** broken out for use in ipmt, ppmt functions */\nconst fv_function = (rate, periods, payment, pv = 0, type = 0) => {\n    if (type) {\n        return (1 + rate) * -payment / rate * (Math.pow(1 + rate, periods) - 1) - pv * Math.pow(1 + rate, periods);\n    }\n    return -payment / rate * (Math.pow(1 + rate, periods) - 1) - pv * Math.pow(1 + rate, periods);\n};\n/** ppmt is calculated as payment less interest payment */\nconst ipmt_function = (rate, period, periods, pv = 0, fv = 0, type = 0) => {\n    // invalid\n    if (period < 1) {\n        return NaN;\n    }\n    // if payment is at the start of the period, there's no interest in payment 1\n    if (period === 1 && type) {\n        return 0;\n    }\n    const total_payment = payment_function(rate, periods, pv, fv, type);\n    const interest = fv_function(rate, period - 1, total_payment, pv, type) * rate;\n    // for payments at start of period, after period 1, we need to discount\n    return type ? interest / (1 + rate) : interest;\n};\nconst ppmt_function = (rate, period, periods, pv = 0, fv = 0, type = 0) => {\n    return payment_function(rate, periods, pv, fv, type) -\n        ipmt_function(rate, period, periods, pv, fv, type);\n};\nconst FinanceFunctionLibrary = {\n    /**\n     * Excel's NPV function is somewhat broken because it assumes the first\n     * (usually negative) cashflow is in year 1, not year 0. so the thing to\n     * do is just use it on the future cashflows and add the initial outlay\n     * as a scalar value.\n     */\n    NPV: {\n        description: 'Returns the present value of a series of future cashflows',\n        arguments: [\n            { name: 'Rate' },\n            { name: 'Cashflow' },\n        ],\n        fn: (rate = 0, ...args) => {\n            let result = 0;\n            const flat = (0,_utilities__WEBPACK_IMPORTED_MODULE_1__.Flatten)(args);\n            for (let i = 0; i < flat.length; i++) {\n                const arg = flat[i];\n                if (typeof arg === 'number') {\n                    result += Math.pow(1 + rate, -(i + 1)) * arg;\n                }\n            }\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: result,\n            };\n        }\n    },\n    IRR: {\n        description: 'Calculates the internal rate of return of a series of cashflows',\n        arguments: [\n            { name: 'Cashflows' },\n            { name: 'Guess', default: .1 },\n        ],\n        fn: (args, guess = .1) => {\n            const flat = (0,_utilities__WEBPACK_IMPORTED_MODULE_1__.Flatten)(args).map(value => typeof value === 'number' ? value : 0);\n            const step = .1; // initial step\n            const bounds = [\n                { found: false, value: 0 },\n                { found: false, value: 0 },\n            ];\n            // FIXME: parameterize max step count, resolution?\n            for (let i = 0; i < 50; i++) {\n                // calculate npv\n                let npv = 0;\n                for (let j = 0; j < flat.length; j++) {\n                    npv += Math.pow(1 + guess, -(j + 1)) * flat[j];\n                }\n                if (Math.abs(npv) <= 0.00125) { // resolution\n                    // console.info(`** found in ${i + 1} steps`)\n                    return {\n                        type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                        value: guess,\n                    };\n                }\n                // search space is unbounded, unfortunately. we can expand exponentially\n                // until we have bounds, at which point it's a standard bounded binary search\n                // ...or we can expand linearly, using a reasonable initial step size?\n                if (npv > 0) {\n                    bounds[0].value = bounds[0].found ? Math.max(bounds[0].value, guess) : guess;\n                    bounds[0].found = true;\n                    if (!bounds[1].found) {\n                        guess += step;\n                        continue;\n                    }\n                }\n                else {\n                    bounds[1].value = bounds[1].found ? Math.min(bounds[1].value, guess) : guess;\n                    bounds[1].found = true;\n                    if (!bounds[0].found) {\n                        guess -= step;\n                        continue;\n                    }\n                }\n                guess = bounds[0].value + (bounds[1].value - bounds[0].value) / 2;\n            }\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.error,\n                value: 'NUM',\n            };\n        },\n    },\n    CUMPRINC: {\n        description: 'Returns cumulative principal paid on a loan between two periods',\n        arguments: [\n            { name: 'Rate', },\n            { name: 'Periods', },\n            { name: 'Present Value' },\n            { name: 'Start Period' },\n            { name: 'End Period' },\n            { name: 'Type', default: 0 },\n        ],\n        fn: (rate, periods, pv, start, end, type = 0) => {\n            let accum = 0;\n            for (let i = start; i <= end; i++) {\n                accum += ppmt_function(rate, i, periods, pv, 0, type);\n            }\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: accum };\n        },\n    },\n    CUMIPMT: {\n        description: 'Returns cumulative interest paid on a loan between two periods',\n        arguments: [\n            { name: 'Rate', },\n            { name: 'Periods', },\n            { name: 'Present Value' },\n            { name: 'Start Period' },\n            { name: 'End Period' },\n            { name: 'Type', default: 0 },\n        ],\n        fn: (rate, periods, pv, start, end, type = 0) => {\n            let accum = 0;\n            for (let i = start; i <= end; i++) {\n                accum += ipmt_function(rate, i, periods, pv, 0, type);\n            }\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: accum };\n        },\n    },\n    IPMT: {\n        description: 'Returns the interest portion of a payment',\n        arguments: [\n            { name: 'Rate', },\n            { name: 'Period', },\n            { name: 'Periods', },\n            { name: 'Present Value', default: 0 },\n            { name: 'Future Value', default: 0 },\n            { name: 'Type', default: 0 },\n        ],\n        fn: (rate, period, periods, pv = 0, fv = 0, type = 0) => {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: ipmt_function(rate, period, periods, pv, fv, type) };\n        }\n    },\n    PPMT: {\n        description: 'Returns the principal portion of a payment',\n        arguments: [\n            { name: 'Rate', },\n            { name: 'Period', },\n            { name: 'Periods', },\n            { name: 'Present Value', default: 0 },\n            { name: 'Future Value', default: 0 },\n            { name: 'Type', default: 0 },\n        ],\n        fn: (rate, period, periods, pv = 0, fv = 0, type = 0) => {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: ppmt_function(rate, period, periods, pv, fv, type) };\n        }\n    },\n    Rate: {\n        description: 'Returns the interest rate of a loan',\n        arguments: [\n            { name: 'Periods', },\n            { name: 'Payment', },\n            { name: 'Present Value', default: 0 },\n            { name: 'Future Value', default: 0 },\n            { name: 'Type', default: 0 },\n        ],\n        fn: (periods, payment, pv = 0, fv = 0, type = 0) => {\n            let rate = .25; // guess\n            const bounds = [-1, 1];\n            const steps = 32; // max iterations\n            const epsilon = 1e-6;\n            for (let i = 0; i < steps; i++) {\n                const a = payment_function(rate, periods, pv, fv, type);\n                if (Math.abs(a - payment) <= epsilon) {\n                    return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: rate };\n                }\n                const b = payment_function(bounds[1], periods, pv, fv, type);\n                if ((payment >= a && payment <= b) || (payment >= b && payment <= a)) {\n                    bounds[0] = rate;\n                }\n                else {\n                    bounds[1] = rate;\n                }\n                rate = bounds[0] + (bounds[1] - bounds[0]) / 2;\n                /*\n                const test = payment_function(rate, periods, pv, fv, type);\n                console.info(\"R\", rate, \"TP\", test, payment, \"d\", Math.abs(payment-test), bounds);\n        \n                if (Math.abs(payment - test) < epsilon) {\n                  return { type: ValueType.number, value: rate };\n                }\n        \n                if ((test < payment && payment > 0) || (test > payment && payment < 0)) { // reduce rate\n                  console.info(\"T<P\");\n                  const next_rate = (bounds[0] + rate) / 2;\n                  bounds = [bounds[0], rate];\n                  rate = next_rate;\n                }\n                else { // increase rate\n                  console.info(\"T>=P\");\n                  const next_rate = (bounds[1] + rate) / 2;\n                  bounds = [rate, bounds[1]];\n                  rate = next_rate;\n                }\n                */\n            }\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: rate };\n        },\n    },\n    FV: {\n        description: 'Returns the future value of an investment',\n        arguments: [\n            { name: 'Rate', },\n            { name: 'Periods', },\n            { name: 'Payment', },\n            { name: 'Present Value', default: 0 },\n            { name: 'Type', default: 0 },\n        ],\n        fn: (rate, periods, payment, pv = 0, type = 0) => {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: fv_function(rate, periods, payment, pv, type) };\n        },\n    },\n    PV: {\n        description: 'Returns the present value of an investment',\n        arguments: [\n            { name: 'Rate', },\n            { name: 'Periods', },\n            { name: 'Payment', },\n            { name: 'Future Value', default: 0 },\n            { name: 'Type', default: 0 },\n        ],\n        fn: (rate, periods, payment, fv = 0, type = 0) => {\n            if (type) {\n                payment += (fv * (1 / ((1 + rate) * ((Math.pow(1 + rate, periods) - 1) / rate))));\n                return {\n                    type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                    value: -(payment + payment / rate * (1 - Math.pow(1 + rate, -(periods - 1))))\n                };\n            }\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                value: -(fv + (payment / rate * (Math.pow(1 + rate, periods) - 1))) / Math.pow(1 + rate, periods)\n            };\n        },\n    },\n    NPER: {\n        description: 'Returns the number of periods of an investment',\n        arguments: [\n            { name: 'Rate', },\n            { name: 'Payment', },\n            { name: 'Present Value', },\n            { name: 'Future Value', default: 0 },\n            { name: 'Type', default: 0 },\n        ],\n        fn: (rate, payment, pv = 0, fv = 0, type = 0) => {\n            if (type) {\n                return {\n                    type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                    value: 1 + (-Math.log(1 + rate * (1 - pv / -payment)) + Math.log(1 + fv * rate / (-payment * (1 + rate)))) / Math.log(1 + rate)\n                };\n            }\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                value: (Math.log(Math.pow(1 - pv * rate / -payment, -1)) + Math.log(1 + fv * rate / -payment)) / Math.log(1 + rate)\n            };\n        },\n    },\n    PMT: {\n        description: 'Returns the periodic payment of a loan',\n        arguments: [\n            { name: 'Rate', },\n            { name: 'Periods', },\n            { name: 'Present Value', },\n            { name: 'Future Value', default: 0 },\n            { name: 'Type', default: 0 },\n        ],\n        fn: (rate, periods, pv, fv = 0, type = 0) => {\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                value: payment_function(rate, periods, pv, fv, type),\n            };\n        },\n    }\n};\n\n\n//# sourceURL=webpack://treb/./treb-calculator/src/functions/finance-functions.ts?");

/***/ }),

/***/ "./treb-calculator/src/functions/information-functions.ts":
/*!****************************************************************!*\
  !*** ./treb-calculator/src/functions/information-functions.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"InformationFunctionLibrary\": () => (/* binding */ InformationFunctionLibrary)\n/* harmony export */ });\n/* harmony import */ var treb_base_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! treb-base-types */ \"./treb-base-types/src/index.ts\");\n/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilities */ \"./treb-calculator/src/utilities.ts\");\n\n\nconst InformationFunctionLibrary = {\n    IsBlank: {\n        description: 'Returns true if the reference is blank',\n        arguments: [{\n                name: 'Reference',\n                metadata: true,\n            }],\n        fn: _utilities__WEBPACK_IMPORTED_MODULE_1__.ApplyAsArray((ref) => {\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.boolean,\n                value: !(ref === null || ref === void 0 ? void 0 : ref.value) || typeof ref.value.value === 'undefined',\n            };\n        }),\n    },\n    IsNumber: {\n        description: 'Returns true if the reference is a number',\n        arguments: [{\n                name: 'Reference',\n                metadata: true,\n            }],\n        fn: _utilities__WEBPACK_IMPORTED_MODULE_1__.ApplyAsArray((ref) => {\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.boolean,\n                value: (ref === null || ref === void 0 ? void 0 : ref.value) && typeof ref.value.value === 'number',\n            };\n        }),\n    },\n    IsLogical: {\n        description: 'Returns true if the reference is a logical TRUE or FALSE',\n        arguments: [{\n                name: 'Reference',\n                metadata: true,\n            }],\n        fn: _utilities__WEBPACK_IMPORTED_MODULE_1__.ApplyAsArray((ref) => {\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.boolean,\n                value: (ref === null || ref === void 0 ? void 0 : ref.value) && typeof ref.value.value === 'boolean',\n            };\n        }),\n    },\n    IsText: {\n        description: 'Returns true if the reference is text',\n        arguments: [{\n                name: 'Reference',\n                metadata: true,\n            }],\n        fn: _utilities__WEBPACK_IMPORTED_MODULE_1__.ApplyAsArray((ref) => {\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.boolean,\n                value: (ref === null || ref === void 0 ? void 0 : ref.value) && typeof ref.value.value === 'string'\n            };\n        }),\n    },\n    /* needs more data\n    ISFORMULA: {\n      description: 'Returns true if the reference is a formula',\n      arguments: [{\n        name: 'Reference',\n        metadata: true,\n      }],\n      fn: (ref: UnionValue): UnionValue => {\n        console.info(\"RR\", ref);\n        return {\n          type: ValueType.boolean,\n          value: ref?.value && typeof ref.value.value === 'string' && ref.value.value[0] === '=',\n        };\n      },\n    },\n    */\n};\n\n\n//# sourceURL=webpack://treb/./treb-calculator/src/functions/information-functions.ts?");

/***/ }),

/***/ "./treb-calculator/src/functions/sparkline.ts":
/*!****************************************************!*\
  !*** ./treb-calculator/src/functions/sparkline.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Sparkline\": () => (/* binding */ Sparkline)\n/* harmony export */ });\n/**\n * moved from sparkline module -- not sure why this needed a separate\n * module. although on reflection it might be better placed in the charts\n * module? (...)\n *\n * perhaps not because we use that module elsewhere and this one is only\n * ever used in spreadsheets.\n *\n */\nvar LineOperation;\n(function (LineOperation) {\n    LineOperation[LineOperation[\"move\"] = 0] = \"move\";\n    LineOperation[LineOperation[\"line\"] = 1] = \"line\";\n})(LineOperation || (LineOperation = {}));\nclass Sparkline {\n    /**\n     * three possible cases:\n     *\n     * (1) array of numbers, possibly including missing values\n     * (2) typed array\n     * (3) nested array, so we need to recurse and concatenate\n     *\n     * there's actually one more case, where data comes in from serialized\n     * representation (loading file); in that case it's an object with numeric\n     * indexes (sadly)\n     */\n    static UnpackValues(underlying) {\n        if (Array.isArray(underlying)) {\n            const test = underlying[0];\n            if (Array.isArray(test) || test instanceof Float64Array || test instanceof Float32Array) {\n                return underlying.reduce((a, subset) => a.concat(this.UnpackValues(subset)), []);\n            }\n            else {\n                return underlying.map(test => isNaN(test) ? undefined : test);\n            }\n        }\n        else if (underlying instanceof Float32Array || underlying instanceof Float64Array) {\n            return Array.prototype.slice.call(underlying);\n        }\n        else if (underlying && typeof underlying === 'object') {\n            const keys = Object.keys(underlying);\n            const len = keys.length;\n            // this is maybe overdoing it? (...) there's probably a smarter test\n            // if (keys.every(key => !isNaN(Number(key)))) {\n            // check first, last\n            if (typeof underlying['0'] !== 'undefined' && typeof underlying[(len - 1).toString()] !== 'undefined') {\n                const data = [];\n                // we probably don't have to explicitly use strings -- although it's not\n                // clear that it would be any faster because someone still has to do the\n                // conversion\n                for (let i = 0; i < len; i++) {\n                    data[i] = underlying[i.toString()];\n                }\n                return data;\n            }\n        }\n        return [];\n    }\n    static SparklineCommon(cell, style) {\n        // the cell function echoes back arguments. the first argument\n        // should be an array, but it will be 2D...\n        var _a;\n        let values = [];\n        // use text color, or default. because this is called from renderer,\n        // theme default _should_ always be passed in, so we should (theoretically)\n        // never need our default.\n        const text_color = ((_a = style.text) === null || _a === void 0 ? void 0 : _a.text) || this.default_color;\n        const colors = [text_color, text_color];\n        if (Array.isArray(cell.calculated)) {\n            values = this.UnpackValues(cell.calculated[0]);\n            if (typeof cell.calculated[1] === 'string') {\n                colors[0] = cell.calculated[1];\n            }\n            if (typeof cell.calculated[2] === 'string') {\n                colors[1] = cell.calculated[2];\n            }\n        }\n        return { values, colors };\n    }\n    static RenderLine(width, height, context, cell, style) {\n        const { values, colors } = this.SparklineCommon(cell, style);\n        const x_margin = 0.05; // FIXME: parameterize? (...)\n        const y_margin = 0.10;\n        let line_width = 1;\n        if (Array.isArray(cell.calculated) && typeof cell.calculated[2] === 'number') {\n            line_width = cell.calculated[2];\n        }\n        let min = 0;\n        let max = 0;\n        let first_index = -1;\n        for (let i = 0; i < values.length; i++) {\n            const value = values[i];\n            if (typeof value === 'number') {\n                if (first_index >= 0) {\n                    min = Math.min(min, value);\n                    max = Math.max(max, value);\n                }\n                else {\n                    first_index = i;\n                    min = max = value;\n                }\n            }\n        }\n        if (min !== max) {\n            const step = (width * (1 - 2 * x_margin)) / (values.length - 1);\n            const range = max - min;\n            const pixel_range = height * (1 - 2 * y_margin); // ?\n            const base = height * y_margin;\n            context.strokeStyle = colors[0];\n            context.lineWidth = line_width;\n            context.lineCap = 'round';\n            context.lineJoin = 'round';\n            // let x = width * x_margin + step * first_index;\n            // let y = height - ((values[first_index] as number) - min) * pixel_range / range - base;\n            context.beginPath();\n            let op = LineOperation.move;\n            for (let i = first_index; i < values.length; i++) {\n                const value = values[i];\n                if (typeof value === 'number') {\n                    const x = width * x_margin + step * i;\n                    const y = height - (value - min) * pixel_range / range - base;\n                    if (op === LineOperation.move) {\n                        context.moveTo(x, y);\n                        op = LineOperation.line;\n                    }\n                    else {\n                        context.lineTo(x, y);\n                    }\n                }\n                else {\n                    op = LineOperation.move;\n                }\n            }\n            context.stroke();\n        }\n    }\n    static RenderColumn(width, height, context, cell, style) {\n        const { values, colors } = this.SparklineCommon(cell, style);\n        // const x_margin = 0.05; // FIXME: parameterize? (...)\n        // const y_margin = 0.10;\n        // const y_margin = Math.max(1, Math.min(0.10 * height, 2));\n        const x_margin = 3;\n        const y_margin = 2.5;\n        let min = 0;\n        let max = 0;\n        let first_value = false;\n        for (const value of values) {\n            if (typeof value === 'number') {\n                if (first_value) {\n                    min = Math.min(min, value);\n                    max = Math.max(max, value);\n                }\n                else {\n                    first_value = true;\n                    min = max = value;\n                }\n            }\n        }\n        if (values.length) {\n            // const step = (width - 2 * x_margin - 2) / (values.length-1);\n            const step = (width - 2 * x_margin - 2) / (values.length - 0);\n            const pixel_range = (height - 2 * y_margin); // ?\n            const base = y_margin;\n            // let x = Math.round(width * x_margin);\n            if (min !== max) {\n                if (min < 0 && max > 0) {\n                    const range = max - min;\n                    const zero = base + max / range * pixel_range;\n                    // use an indexed loop so we can multiply to get x instead of adding\n                    for (let i = 0; i < values.length; i++) {\n                        const value = values[i];\n                        if (typeof value === 'number') {\n                            const x = (x_margin + i * step);\n                            const bar_height = (Math.abs(value) / range) * pixel_range;\n                            if (value >= 0) {\n                                context.fillStyle = colors[0];\n                                const top = zero - bar_height;\n                                context.fillRect(x + 2, top, step - 2, bar_height);\n                            }\n                            else {\n                                context.fillStyle = colors[1];\n                                const top = zero;\n                                context.fillRect(x + 2, top, step - 2, bar_height);\n                            }\n                        }\n                    }\n                }\n                else if (max > 0) {\n                    // all positive\n                    context.fillStyle = colors[0];\n                    const range = max - min;\n                    // use an indexed loop so we can multiply to get x instead of adding\n                    for (let i = 0; i < values.length; i++) {\n                        const value = values[i];\n                        if (typeof value === 'number') {\n                            const x = (x_margin + i * step);\n                            const bar_height = Math.max(1, ((value - min) / range) * pixel_range);\n                            const top = height - base - bar_height;\n                            context.fillRect(x + 2, top, step - 2, bar_height);\n                        }\n                    }\n                }\n                else {\n                    // all negative\n                    context.fillStyle = colors[1];\n                    const range = max - min;\n                    // use an indexed loop so we can multiply to get x instead of adding\n                    for (let i = 0; i < values.length; i++) {\n                        const value = values[i];\n                        if (typeof value === 'number') {\n                            const x = (x_margin + i * step);\n                            const bar_height = Math.max(1, (Math.abs(max - value) / range) * pixel_range);\n                            const top = base;\n                            context.fillRect(x + 2, top, step - 2, bar_height);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n// public static SingleColor = ['#333'];\n// public static TwoColors = ['green', 'red'];\nSparkline.default_color = '#888'; // should never be used, but jic\n\n\n//# sourceURL=webpack://treb/./treb-calculator/src/functions/sparkline.ts?");

/***/ }),

/***/ "./treb-calculator/src/functions/statistics-functions.ts":
/*!***************************************************************!*\
  !*** ./treb-calculator/src/functions/statistics-functions.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"StatisticsFunctionLibrary\": () => (/* binding */ StatisticsFunctionLibrary),\n/* harmony export */   \"StatisticsFunctionAliases\": () => (/* binding */ StatisticsFunctionAliases)\n/* harmony export */ });\n/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities */ \"./treb-calculator/src/utilities.ts\");\n/* harmony import */ var _function_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function-error */ \"./treb-calculator/src/function-error.ts\");\n/* harmony import */ var treb_base_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! treb-base-types */ \"./treb-base-types/src/index.ts\");\n\n\n\nconst Variance = (data, sample = false) => {\n    const len = data.length;\n    let m = 0;\n    let v = 0;\n    // let k = 0;\n    // let s = 0;\n    for (let i = 0; i < len; i++)\n        m += data[i];\n    m /= len;\n    // const mean = m;\n    for (let i = 0; i < len; i++) {\n        const d = data[i] - m;\n        v += (d * d);\n        // s += (d * d * d);\n        // k += (d * d * d * d);\n    }\n    // const N = len;\n    // const variance = v / len;\n    // const stdev = Math.sqrt(v / len);\n    return sample ? (v / (len - 1)) : (v / len);\n};\nconst StatisticsFunctionLibrary = {\n    StDev: {\n        description: 'Returns the standard deviation of a set of values, corresponding to a population',\n        arguments: [{ name: 'data', }],\n        fn: (...args) => {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number, value: Math.sqrt(Variance(_utilities__WEBPACK_IMPORTED_MODULE_0__.Flatten(args), false)) };\n        },\n    },\n    'StDev.S': {\n        description: 'Returns the standard deviation of a set of values, corresponding to a sample of a population',\n        arguments: [{ name: 'data', }],\n        fn: (...args) => {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number, value: Math.sqrt(Variance(_utilities__WEBPACK_IMPORTED_MODULE_0__.Flatten(args), true)) };\n        },\n    },\n    Var: {\n        description: 'Returns the variance of a set of values, corresponding to a population',\n        arguments: [{ name: 'data', }],\n        fn: (...args) => {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number, value: Variance(_utilities__WEBPACK_IMPORTED_MODULE_0__.Flatten(args), false) };\n        },\n    },\n    'Var.S': {\n        description: 'Returns the variance of a set of values, corresponding to a sample of a population',\n        arguments: [{ name: 'data', }],\n        fn: (...args) => {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number, value: Variance(_utilities__WEBPACK_IMPORTED_MODULE_0__.Flatten(args), true) };\n        },\n    },\n    Correl: {\n        description: 'Returns the correlation between two ranges of values',\n        arguments: [{\n                name: 'A',\n            }, {\n                name: 'B',\n            }],\n        fn: (x, y) => {\n            // both must be 2d arrays, we're assuming the same or mostly similar shape\n            if (!Array.isArray(x) || !Array.isArray(y)) {\n                return (0,_function_error__WEBPACK_IMPORTED_MODULE_1__.ValueError)();\n            }\n            if (!Array.isArray(x[0]) || !Array.isArray(y[0])) {\n                return (0,_function_error__WEBPACK_IMPORTED_MODULE_1__.ValueError)();\n            }\n            let rslt = 0;\n            let sumProduct = 0;\n            let sumX = 0;\n            let sumY = 0;\n            let sumSquaredX = 0;\n            let sumSquaredY = 0;\n            let count = 0;\n            for (let j = 0; j < x.length; j++) {\n                if (!x[j] || !y[j]) {\n                    continue;\n                }\n                const len = x[j].length;\n                for (let i = 0; i < len; i++) {\n                    const a = Number(x[j][i]);\n                    const b = Number(y[j][i]);\n                    if (isNaN(a) || isNaN(b)) {\n                        continue;\n                    }\n                    sumProduct += (a * b);\n                    sumX += a;\n                    sumY += b;\n                    sumSquaredX += (a * a);\n                    sumSquaredY += (b * b);\n                    count++;\n                }\n            }\n            rslt = ((count * sumProduct) - (sumX * sumY));\n            if (rslt) {\n                rslt /= Math.sqrt(((count * sumSquaredX) - (sumX * sumX)) * ((count * sumSquaredY) - (sumY * sumY)));\n            }\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number, value: rslt };\n        },\n    },\n    GeoMean: {\n        fn: (...args) => {\n            args = _utilities__WEBPACK_IMPORTED_MODULE_0__.Flatten(args);\n            let count = 0;\n            let product = 1;\n            for (const arg of args) {\n                if (typeof arg === 'undefined') {\n                    continue;\n                }\n                const value = Number(arg);\n                if (value < 0) {\n                    return (0,_function_error__WEBPACK_IMPORTED_MODULE_1__.ValueError)();\n                }\n                count++;\n                product *= value;\n            }\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number, value: Math.pow(product, 1 / count) };\n        },\n    },\n    Average: {\n        fn: (...args) => {\n            args = _utilities__WEBPACK_IMPORTED_MODULE_0__.Flatten(args);\n            const value = args.reduce((a, b) => {\n                if (typeof b === 'undefined')\n                    return a;\n                return a + Number(b);\n            }, 0) / args.length;\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number, value };\n        },\n    },\n    Percentile: {\n        description: 'Returns the kth percentile value from the range of data',\n        arguments: [\n            { name: 'range' },\n            { name: 'percentile' },\n        ],\n        fn: (range, percentile) => {\n            const flat = _utilities__WEBPACK_IMPORTED_MODULE_0__.Flatten(range).filter((test) => typeof test === 'number');\n            flat.sort((a, b) => a - b);\n            const n = flat.length;\n            // try to stabilize this number\n            const factor = Math.pow(10, 8);\n            const x = Math.round((1 + (n - 1) * percentile) * factor) / factor;\n            const lo = Math.floor(x);\n            const hi = Math.ceil(x);\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number, value: (flat[lo - 1] + flat[hi - 1]) / 2 };\n        },\n    },\n    Median: {\n        description: 'Returns the median value of the range of data',\n        arguments: [\n            { name: 'range' },\n        ],\n        fn: (...args) => {\n            const flat = _utilities__WEBPACK_IMPORTED_MODULE_0__.Flatten(args).filter((test) => typeof test === 'number');\n            flat.sort((a, b) => a - b);\n            const n = flat.length;\n            const x = 1 + (n - 1) * .5;\n            const lo = Math.floor(x);\n            const hi = Math.ceil(x);\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.ValueType.number, value: (flat[lo - 1] + flat[hi - 1]) / 2 };\n        },\n    }\n};\nconst StatisticsFunctionAliases = {\n    Mean: 'Average',\n    'StDev.P': 'StDev',\n    'Var.P': 'Var',\n};\n\n\n//# sourceURL=webpack://treb/./treb-calculator/src/functions/statistics-functions.ts?");

/***/ }),

/***/ "./treb-calculator/src/functions/text-functions.ts":
/*!*********************************************************!*\
  !*** ./treb-calculator/src/functions/text-functions.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TextFunctionLibrary\": () => (/* binding */ TextFunctionLibrary),\n/* harmony export */   \"TextFunctionAliases\": () => (/* binding */ TextFunctionAliases)\n/* harmony export */ });\n/* harmony import */ var treb_format__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! treb-format */ \"./treb-format/src/index.ts\");\n/* harmony import */ var treb_base_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! treb-base-types */ \"./treb-base-types/src/index.ts\");\n/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utilities */ \"./treb-calculator/src/utilities.ts\");\n/* harmony import */ var _function_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../function-error */ \"./treb-calculator/src/function-error.ts\");\n\n\n\n\n/**\n * parse a string with wildcards into a regex pattern\n *\n * from\n * https://exceljet.net/glossary/wildcard\n *\n * Excel has 3 wildcards you can use in your formulas:\n *\n * Asterisk (*) - zero or more characters\n * Question mark (?) - any one character\n * Tilde (~) - escape for literal character (~*) a literal question mark (~?), or a literal tilde (~~)\n *\n * they're pretty liberal with escaping, nothing is an error, just roll with it\n *\n */\nconst ParseWildcards = (text) => {\n    const result = [];\n    const length = text.length;\n    const escaped_chars = '[\\\\^$.|?*+()';\n    for (let i = 0; i < length; i++) {\n        let char = text[i];\n        switch (char) {\n            case '*':\n                result.push('.', '*');\n                break;\n            case '?':\n                result.push('.');\n                break;\n            case '~':\n                char = text[++i] || '';\n            // eslint-disable-next-line no-fallthrough\n            default:\n                for (let j = 0; j < escaped_chars.length; j++) {\n                    if (char === escaped_chars[j]) {\n                        result.push('\\\\');\n                        break;\n                    }\n                }\n                result.push(char);\n                break;\n        }\n    }\n    return result.join('');\n};\nconst TextFunctionLibrary = {\n    Char: {\n        arguments: [{\n                name: 'number',\n            }],\n        fn: (num) => {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_1__.ValueType.string, value: String.fromCodePoint(num || 32) };\n        },\n        category: ['text'],\n    },\n    Code: {\n        arguments: [{\n                name: 'string',\n            }],\n        fn: (str) => {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_1__.ValueType.number, value: str.codePointAt(0) };\n        },\n        category: ['text'],\n    },\n    Text: {\n        arguments: [\n            { name: 'value' },\n            { name: 'number format' },\n        ],\n        fn: (value, format = '0.00####') => {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_1__.ValueType.string, value: treb_format__WEBPACK_IMPORTED_MODULE_0__.NumberFormatCache.Get(format).Format(value || 0) };\n        },\n        category: ['text'],\n    },\n    Left: {\n        arguments: [\n            { name: 'string' },\n            { name: 'count' },\n        ],\n        fn: (str, count = 1) => {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_1__.ValueType.string, value: str.substr(0, count) };\n        },\n        category: ['text'],\n    },\n    Right: {\n        arguments: [\n            { name: 'string' },\n            { name: 'count' },\n        ],\n        fn: (str, count = 1) => {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_1__.ValueType.string, value: str.slice(-count) };\n        },\n        category: ['text'],\n    },\n    Mid: {\n        arguments: [\n            { name: 'string' },\n            { name: 'left' },\n            { name: 'count' },\n        ],\n        fn: (str, left = 0, count = 1) => {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_1__.ValueType.string, value: str.substr(Math.max(0, left - 1), count) };\n        },\n        category: ['text'],\n    },\n    /*\n    \n      Concatenate: {\n        description: 'Pastes strings together',\n        fn: (...args: any[]) => {\n          return args.map((arg) => {\n    \n            // this is used when concatenating cells that contain numbers\n            // FIXME: get cell number format?\n    \n            const string_arg = (typeof arg === 'undefined') ? '' : arg.toString();\n    \n            if (typeof arg === 'number' && Localization.decimal_separator === ',') {\n              return string_arg.replace(/\\./, ',');\n            }\n    \n            return string_arg;\n          }).join('');\n        },\n      },\n    \n      */\n    /**\n     * shame we can't write a proper search function, but we need to be\n     * consistent. some notes:\n     *\n     * FIND is case-sensitive and does not support wildcards\n     * SEARCH is icase and supports wildcards\n     *\n     * re: wildcards, from\n     * https://exceljet.net/glossary/wildcard\n     *\n     * Excel has 3 wildcards you can use in your formulas:\n     *\n     * Asterisk (*) - zero or more characters\n     * Question mark (?) - any one character\n     * Tilde (~) - escape for literal character (~*) a literal question mark (~?), or a literal tilde (~~)\n     *\n     * start index is 1-based, and defaults to 1; < 1 is an error. if the string\n     * is not found, that's an error. if needle is empty, return start.\n     *\n     */\n    Search: {\n        description: 'Find a string (needle) in another string (haystack). Case-insensitive.',\n        arguments: [\n            { name: 'Needle', },\n            { name: 'Haystack', },\n            { name: 'Start', default: 1, },\n        ],\n        fn: (needle, haystack, start = 1) => {\n            if (start >= 1) {\n                if (!needle) {\n                    return {\n                        type: treb_base_types__WEBPACK_IMPORTED_MODULE_1__.ValueType.number, value: start,\n                    };\n                }\n                // translate into regex. do we need an actual parser for this, or \n                // can we get by with regexes? should we have some sort of cache\n                // for common patterns?\n                const pattern = ParseWildcards(needle);\n                // console.info('n', needle, 'p', pattern);\n                const match = new RegExp(pattern, 'i').exec(haystack.substr(start - 1));\n                if (match) {\n                    return {\n                        type: treb_base_types__WEBPACK_IMPORTED_MODULE_1__.ValueType.number, value: match.index + start,\n                    };\n                }\n            }\n            return (0,_function_error__WEBPACK_IMPORTED_MODULE_3__.ValueError)();\n        },\n    },\n    Find: {\n        description: 'Find a string (needle) in another string (haystack). Case-sensitive.',\n        arguments: [\n            { name: 'Needle', },\n            { name: 'Haystack', },\n            { name: 'Start', default: 1, },\n        ],\n        fn: (needle, haystack, start = 1) => {\n            if (start >= 1) {\n                if (!needle) {\n                    return {\n                        type: treb_base_types__WEBPACK_IMPORTED_MODULE_1__.ValueType.number, value: start,\n                    };\n                }\n                const match = new RegExp(needle).exec(haystack.substr(start - 1));\n                if (match) {\n                    return {\n                        type: treb_base_types__WEBPACK_IMPORTED_MODULE_1__.ValueType.number, value: match.index + start,\n                    };\n                }\n            }\n            return (0,_function_error__WEBPACK_IMPORTED_MODULE_3__.ValueError)();\n        },\n    },\n    /** canonical should be CONCAT; concatenate can be an alias */\n    Concat: {\n        description: 'Pastes strings together',\n        fn: (...args) => {\n            const values = _utilities__WEBPACK_IMPORTED_MODULE_2__.Flatten(args);\n            const value = values.map((arg) => {\n                // this is used when concatenating cells that contain numbers\n                // FIXME: get cell number format? we'd need to use metadata\n                var _a;\n                const string_arg = ((_a = arg) === null || _a === void 0 ? void 0 : _a.toString()) || '';\n                if (typeof arg === 'number' && treb_base_types__WEBPACK_IMPORTED_MODULE_1__.Localization.decimal_separator === ',') {\n                    return string_arg.replace(/\\./, ',');\n                }\n                return string_arg;\n            }).join('');\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_1__.ValueType.string, value };\n        },\n    },\n};\nconst TextFunctionAliases = {\n    Concatenate: 'Concat',\n};\n\n\n//# sourceURL=webpack://treb/./treb-calculator/src/functions/text-functions.ts?");

/***/ }),

/***/ "./treb-calculator/src/index.ts":
/*!**************************************!*\
  !*** ./treb-calculator/src/index.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Calculator\": () => (/* reexport safe */ _calculator__WEBPACK_IMPORTED_MODULE_0__.Calculator),\n/* harmony export */   \"LeafVertex\": () => (/* reexport safe */ _dag_leaf_vertex__WEBPACK_IMPORTED_MODULE_1__.LeafVertex)\n/* harmony export */ });\n/* harmony import */ var _calculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./calculator */ \"./treb-calculator/src/calculator.ts\");\n/* harmony import */ var _dag_leaf_vertex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dag/leaf_vertex */ \"./treb-calculator/src/dag/leaf_vertex.ts\");\n\n// export * from './pack-results';\n// for annotations that have dependencies\n\n\n\n//# sourceURL=webpack://treb/./treb-calculator/src/index.ts?");

/***/ }),

/***/ "./treb-calculator/src/primitives.ts":
/*!*******************************************!*\
  !*** ./treb-calculator/src/primitives.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Add\": () => (/* binding */ Add),\n/* harmony export */   \"Subtract\": () => (/* binding */ Subtract),\n/* harmony export */   \"Power\": () => (/* binding */ Power),\n/* harmony export */   \"Multiply\": () => (/* binding */ Multiply),\n/* harmony export */   \"Divide\": () => (/* binding */ Divide),\n/* harmony export */   \"Modulo\": () => (/* binding */ Modulo),\n/* harmony export */   \"Concatenate\": () => (/* binding */ Concatenate),\n/* harmony export */   \"Equals\": () => (/* binding */ Equals),\n/* harmony export */   \"NotEquals\": () => (/* binding */ NotEquals),\n/* harmony export */   \"GreaterThan\": () => (/* binding */ GreaterThan),\n/* harmony export */   \"GreaterThanEqual\": () => (/* binding */ GreaterThanEqual),\n/* harmony export */   \"LessThan\": () => (/* binding */ LessThan),\n/* harmony export */   \"LessThanEqual\": () => (/* binding */ LessThanEqual),\n/* harmony export */   \"MapOperator\": () => (/* binding */ MapOperator)\n/* harmony export */ });\n/* harmony import */ var treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! treb-base-types/src */ \"./treb-base-types/src/index.ts\");\n/* harmony import */ var _function_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./function-error */ \"./treb-calculator/src/function-error.ts\");\n\n\nconst NumericTypes = (a, b) => {\n    if (a.type === treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.error) {\n        return [0, 0, a];\n    }\n    if (b.type === treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.error) {\n        return [0, 0, b];\n    }\n    const result = [0, 0];\n    // FIXME: what about empty string? should === 0?\n    switch (a.type) {\n        case treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.number:\n            result[0] = a.value;\n            break;\n        case treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.boolean:\n            result[0] = a.value ? 1 : 0;\n            break;\n        case treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.undefined: break;\n        default: return [0, 0, (0,_function_error__WEBPACK_IMPORTED_MODULE_1__.ValueError)()]; // FIXME\n    }\n    switch (b.type) {\n        case treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.number:\n            result[1] = b.value;\n            break;\n        case treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.boolean:\n            result[1] = b.value ? 1 : 0;\n            break;\n        case treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.undefined: break;\n        default: return [0, 0, (0,_function_error__WEBPACK_IMPORTED_MODULE_1__.ValueError)()]; // FIXME\n    }\n    return result;\n};\nconst Add = (a, b) => {\n    const [x, y, z] = NumericTypes(a, b);\n    if (z) {\n        return z;\n    }\n    return { value: x + y, type: treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.number };\n};\nconst Subtract = (a, b) => {\n    const [x, y, z] = NumericTypes(a, b);\n    if (z) {\n        return z;\n    }\n    return { value: x - y, type: treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.number };\n};\nconst Power = (a, b) => {\n    const [x, y, z] = NumericTypes(a, b);\n    if (z) {\n        return z;\n    }\n    return { value: Math.pow(x, y), type: treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.number };\n};\nconst Multiply = (a, b) => {\n    const [x, y, z] = NumericTypes(a, b);\n    if (z) {\n        return z;\n    }\n    return { value: x * y, type: treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.number };\n};\nconst Divide = (a, b) => {\n    const [x, y, z] = NumericTypes(a, b);\n    if (z) {\n        return z;\n    }\n    if (y === 0) {\n        return (0,_function_error__WEBPACK_IMPORTED_MODULE_1__.DivideByZeroError)();\n    }\n    return { value: x / y, type: treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.number };\n};\nconst Modulo = (a, b) => {\n    const [x, y, z] = NumericTypes(a, b);\n    if (z) {\n        return z;\n    }\n    if (y === 0) {\n        return (0,_function_error__WEBPACK_IMPORTED_MODULE_1__.DivideByZeroError)();\n    }\n    return { value: x % y, type: treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.number };\n};\nconst Concatenate = (a, b) => {\n    if (a.type === treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.error) {\n        return a;\n    }\n    if (b.type === treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.error) {\n        return b;\n    }\n    return {\n        type: treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.string,\n        value: `${a.type === treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.undefined ? '' : a.value}${b.type === treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.undefined ? '' : b.value}`,\n    };\n};\nconst Equals = (a, b) => {\n    if (a.type === treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.error) {\n        return a;\n    }\n    if (b.type === treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.error) {\n        return b;\n    }\n    // empty cells equal 0 and \"\"\n    if ((a.type === treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.undefined && (b.value === '' || b.value === 0))\n        || (b.type === treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.undefined && (a.value === '' || a.value === 0))) {\n        return { type: treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.boolean, value: true, };\n    }\n    return { type: treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.boolean, value: a.value == b.value }; // note ==\n};\n/**\n * this is duplicative, but it seems better than another function call.\n * not sure if that is over-optimization (it is).\n */\nconst NotEquals = (a, b) => {\n    if (a.type === treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.error) {\n        return a;\n    }\n    if (b.type === treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.error) {\n        return b;\n    }\n    // empty cells equal 0 and \"\"\n    if ((a.type === treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.undefined && (b.value === '' || b.value === 0))\n        || (b.type === treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.undefined && (a.value === '' || a.value === 0))) {\n        return { type: treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.boolean, value: false, };\n    }\n    return { type: treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.boolean, value: a.value != b.value }; // note ==\n};\n// NOTE: our comparisons don't match Excel with different types -- we could\n// probably figure out what Excel is doing, but I'm not sure it's useful or\n// worthwhile\nconst GreaterThan = (a, b) => {\n    if (a.type === treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.error) {\n        return a;\n    }\n    if (b.type === treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.error) {\n        return b;\n    }\n    return { type: treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.boolean, value: (a.value || 0) > (b.value || 0) };\n};\nconst GreaterThanEqual = (a, b) => {\n    if (a.type === treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.error) {\n        return a;\n    }\n    if (b.type === treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.error) {\n        return b;\n    }\n    return { type: treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.boolean, value: a.value >= b.value };\n};\nconst LessThan = (a, b) => {\n    if (a.type === treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.error) {\n        return a;\n    }\n    if (b.type === treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.error) {\n        return b;\n    }\n    return { type: treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.boolean, value: a.value < b.value };\n};\nconst LessThanEqual = (a, b) => {\n    if (a.type === treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.error) {\n        return a;\n    }\n    if (b.type === treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.error) {\n        return b;\n    }\n    return { type: treb_base_types_src__WEBPACK_IMPORTED_MODULE_0__.ValueType.boolean, value: a.value <= b.value };\n};\nconst MapOperator = (operator) => {\n    switch (operator) {\n        case '&': return Concatenate;\n        case '+': return Add;\n        case '-': return Subtract;\n        case '*': return Multiply;\n        case '/': return Divide;\n        case '^': return Power;\n        case '**': return Power;\n        case '%': return Modulo; // NOTE: not an excel operator\n        case '=': return Equals;\n        case '==': return Equals;\n        case '!=': return NotEquals;\n        case '<>': return NotEquals;\n        case '>': return GreaterThan;\n        case '>=': return GreaterThanEqual;\n        case '<': return LessThan;\n        case '<=': return LessThanEqual;\n    }\n    return undefined;\n};\n\n\n//# sourceURL=webpack://treb/./treb-calculator/src/primitives.ts?");

/***/ }),

/***/ "./treb-calculator/src/utilities.ts":
/*!******************************************!*\
  !*** ./treb-calculator/src/utilities.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DAY_MS\": () => (/* binding */ DAY_MS),\n/* harmony export */   \"IsArrayOrTypedArray\": () => (/* binding */ IsArrayOrTypedArray),\n/* harmony export */   \"Transpose2\": () => (/* binding */ Transpose2),\n/* harmony export */   \"TransposeArray\": () => (/* binding */ TransposeArray),\n/* harmony export */   \"StringToColumn\": () => (/* binding */ StringToColumn),\n/* harmony export */   \"ColumnToString\": () => (/* binding */ ColumnToString),\n/* harmony export */   \"OffsetFormula\": () => (/* binding */ OffsetFormula),\n/* harmony export */   \"Flatten\": () => (/* binding */ Flatten),\n/* harmony export */   \"UndefinedToEmptyString\": () => (/* binding */ UndefinedToEmptyString),\n/* harmony export */   \"ApplyArrayFunc\": () => (/* binding */ ApplyArrayFunc),\n/* harmony export */   \"ApplyAsArray\": () => (/* binding */ ApplyAsArray),\n/* harmony export */   \"ApplyAsArray2\": () => (/* binding */ ApplyAsArray2)\n/* harmony export */ });\nconst DAY_MS = 1000 * 60 * 60 * 24;\nconst IsArrayOrTypedArray = (test) => {\n    return Array.isArray(test) || (test instanceof Float64Array) || (test instanceof Float64Array);\n};\nconst Transpose2 = (arr) => {\n    const result = [];\n    const cols = arr.length;\n    const rows = arr[0].length;\n    for (let r = 0; r < rows; r++) {\n        result[r] = [];\n        for (let c = 0; c < cols; c++) {\n            result[r][c] = arr[c][r];\n        }\n    }\n    return result;\n};\nconst TransposeArray = (arr) => {\n    if (!arr)\n        return [];\n    if (typeof arr[0] === 'undefined')\n        return [];\n    if (!IsArrayOrTypedArray(arr[0])) {\n        if (arr instanceof Float32Array || arr instanceof Float64Array) {\n            return Array.prototype.slice.call(arr).map((x) => [x]);\n        }\n        return arr.map((x) => [x]);\n    }\n    const tmp = [];\n    const cols = arr.length;\n    const rows = arr[0].length;\n    for (let r = 0; r < rows; r++) {\n        tmp[r] = [];\n        for (let c = 0; c < cols; c++) {\n            tmp[r][c] = arr[c][r];\n        }\n    }\n    return tmp;\n};\nconst StringToColumn = (s) => {\n    let index = 0;\n    s = s.toUpperCase();\n    for (let i = 0; i < s.length; i++) {\n        index *= 26;\n        index += (s.charCodeAt(i) - 64);\n    }\n    return index - 1;\n};\nconst ColumnToString = (column) => {\n    // there's some weird case where this hangs, not sure\n    // how that happens. trap it and figure it out.\n    const original = column;\n    let s = '';\n    for (;;) {\n        const c = column % 26;\n        s = String.fromCharCode(65 + c) + s;\n        column = Math.floor(column / 26);\n        if (column)\n            column--;\n        if (column < 0)\n            throw (new Error('Column < 0!, original was ' + original));\n        else\n            break;\n    }\n    return s;\n};\nconst OffsetFormula = (formula, offset) => {\n    const cache = {};\n    formula = formula.replace(/\\b([A-Za-z]+)(\\d+)\\b/g, (m, p1, p2) => {\n        if (!cache[m]) {\n            const c = ColumnToString(StringToColumn(p1) + offset.columns);\n            const r = Number(p2) + offset.rows;\n            cache[m] = c + r.toString();\n        }\n        return cache[m];\n    });\n    return formula;\n};\n/**\n * flatten a set of arguments\n * UPDATE: we no longer accept the \"arguments\" object. must be an array.\n * callers can use rest spread to collect arguments.\n */\nconst Flatten = (args) => {\n    if (!Array.isArray(args)) {\n        return [args];\n    } // special case\n    return args.reduce((a, b) => {\n        if (typeof b === 'undefined')\n            return a;\n        if (Array.isArray(b))\n            return a.concat(Flatten(b));\n        if (b instanceof Float32Array)\n            return a.concat(Array.from(b));\n        if (b instanceof Float64Array)\n            return a.concat(Array.from(b));\n        return a.concat([b]);\n    }, []);\n};\nconst UndefinedToEmptyString = (args) => {\n    for (let i = 0; i < args.length; i++) {\n        if (Array.isArray(args[i])) {\n            args[i] = UndefinedToEmptyString(args[i]);\n        }\n        else if (typeof args[i] === 'undefined') {\n            args[i] = '';\n        }\n    }\n    return args;\n};\n/**\n * returns a function that applies the given function to a scalar or a matrix\n * @param base the underlying function\n */\nconst ApplyArrayFunc = (base) => {\n    return (a) => {\n        if (Array.isArray(a)) {\n            const tmp = [];\n            const rows = a[0].length;\n            for (let c = 0; c < a.length; c++) {\n                const col = [];\n                for (let r = 0; r < rows; r++)\n                    col[r] = base(a[c][r]);\n                tmp.push(col);\n            }\n            return tmp;\n        }\n        return base(a);\n    };\n};\nconst ApplyAsArray = (base) => {\n    return (a, ...rest) => {\n        if (Array.isArray(a)) {\n            return a.map(row => row.map((element) => {\n                return base(element, ...rest);\n            }));\n        }\n        else {\n            return base(a, ...rest);\n        }\n    };\n};\nconst ApplyAsArray2 = (base) => {\n    return (a, b, ...rest) => {\n        if (Array.isArray(a)) {\n            if (Array.isArray(b)) {\n                return a.map((row, i) => row.map((element, j) => {\n                    return base(element, b[i][j], ...rest);\n                }));\n            }\n            else {\n                return a.map(row => row.map((element) => {\n                    return base(element, b, ...rest);\n                }));\n            }\n        }\n        else {\n            return base(a, b, ...rest);\n        }\n    };\n};\n\n\n//# sourceURL=webpack://treb/./treb-calculator/src/utilities.ts?");

/***/ }),

/***/ "./treb-format/src/format.ts":
/*!***********************************!*\
  !*** ./treb-format/src/format.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LotusDate\": () => (/* binding */ LotusDate),\n/* harmony export */   \"UnlotusDate\": () => (/* binding */ UnlotusDate),\n/* harmony export */   \"NumberFormat\": () => (/* binding */ NumberFormat)\n/* harmony export */ });\n/* harmony import */ var _format_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./format_parser */ \"./treb-format/src/format_parser.ts\");\n/* harmony import */ var _number_format_section__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./number_format_section */ \"./treb-format/src/number_format_section.ts\");\n/* harmony import */ var treb_base_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! treb-base-types */ \"./treb-base-types/src/index.ts\");\n\n\n\n//\n// excel time is explicitly universal, so we need all dates in and out \n// to be UTC. we can't use local time because of daylight savings (which\n// excel ignores)\n// \n// the actual epoch is \"January 0\" -- I suppose that === Dec 31?\n//\n// const base_date = -2209075200000; // new Date('1899-12-31 00:00:00 Z').getTime();\n//\n// excel time is 1 == 1 day, so relative to js time (millis), we need \n// to scale by 1000 * 60 * 60 * 24\n//\n// const date_scale = 86400000;\n//\n// one last thing -- Excel incorrectly treats 1900 as a leap year. this was\n// for compatibility with Lotus 1-2-3, which handled it incorrectly. we will \n// join the party and treat it incorrectly as well.\n// \n// ref:\n// https://docs.microsoft.com/en-us/office/troubleshoot/excel/wrongly-assumes-1900-is-leap-year\n//\n// what about backwards?\n//\n// OK, I can answer that now: Excel just doesn't handle dates before 1900\n// at all. can't parse them; can't handle negative numbers as dates. \n/** convert cell value -> date, using the rules above */\nconst LotusDate = (value) => {\n    if (value >= 60)\n        value--; // March 1, 1900\n    return new Date(-2209075200000 + 86400000 * value);\n};\n/** convert date (as number, utc millis) -> lotus date value */\nconst UnlotusDate = (value, local = true) => {\n    // if the passed value is local, we need to convert it to UTC\n    if (local) {\n        const local_date = new Date(value);\n        const utc_date = new Date();\n        utc_date.setUTCMilliseconds(local_date.getUTCMilliseconds());\n        utc_date.setUTCSeconds(local_date.getUTCSeconds());\n        utc_date.setUTCMinutes(local_date.getUTCMinutes());\n        utc_date.setUTCHours(local_date.getHours());\n        utc_date.setUTCDate(local_date.getDate());\n        utc_date.setUTCMonth(local_date.getMonth());\n        utc_date.setUTCFullYear(local_date.getFullYear());\n        value = utc_date.getTime();\n    }\n    value = (value + 2209075200000) / 86400000;\n    if (value >= 60) {\n        value++;\n    }\n    return value;\n};\n/**\n * unifying date format and number format (really just bolting dates\n * on the side). dates have only a single section, constant pattern, and\n * are immutable.\n */\nclass NumberFormat {\n    constructor(pattern) {\n        // tslint:disable-next-line:variable-name\n        this._pattern = '';\n        this.decimal_zero_regexp = [];\n        // this is a flag for string representation\n        this.cloned = [];\n        /** for the \"General\" field, a magic decimal point */\n        this.magic_decimal = false;\n        this._pattern = pattern;\n        this.sections = _format_parser__WEBPACK_IMPORTED_MODULE_0__.FormatParser.Parse(pattern);\n        // nothing?\n        if (!this.sections.length)\n            this.sections = [];\n        // check zero. we were previously assuming this stepped, but we\n        // now support gaps in format sections (although not at 0?)\n        if (!this.sections[0]) {\n            this.sections[0] = new _number_format_section__WEBPACK_IMPORTED_MODULE_1__.NumberFormatSection(); // pretty sure this cannot happen atm\n        }\n        // do we have a negative section? if not, use the positive\n        // section and prepend a - sign.\n        if (!this.sections[1]) {\n            this.sections[1] = Object.assign({}, this.sections[0]);\n            this.sections[1].prefix = JSON.parse(JSON.stringify(this.sections[1].prefix));\n            this.sections[1].suffix = JSON.parse(JSON.stringify(this.sections[1].suffix));\n            this.sections[1].prefix.push({ text: '-' }); // at end of prefix, before number\n            this.cloned[1] = true;\n        }\n        // do we have a zero section? if not, clone the positive section.\n        if (!this.sections[2]) {\n            this.sections[2] = Object.assign({}, this.sections[0]);\n            this.cloned[2] = true;\n        }\n        // string section, default just reflects the string. we could perhaps\n        // skip this and just have default behavior if there's no section, which\n        // might simplify rendering\n        // UPDATE, special case: unless a string section is explicitly\n        // provided, we use a default '@' section (it's implicit). however,\n        // if there's a literatal '@' in the first section, we want to\n        // propogate that to all empty sections, including the string section.\n        // note that we should not support literal AND numeric sections in\n        // the same block... it will fail silently here... [FIXME: at least warn]\n        if (!this.sections[3]) {\n            for (const part of this.sections[0].prefix) {\n                if (part.flag === treb_base_types__WEBPACK_IMPORTED_MODULE_2__.TextPartFlag.literal) {\n                    this.sections[3] = Object.assign({}, this.sections[0]);\n                    this.sections[3].string_format = true;\n                    this.cloned[3] = true;\n                    break;\n                }\n            }\n        }\n        /*\n        if (!this.sections[3]) {\n          this.sections[3] = new NumberFormatSection();\n          this.sections[3].string_format = true;\n          this.sections[3].prefix = [{ text: '@', flag: TextPartFlag.literal }];\n    \n          // obviously not cloned, but we want the behavior. FIXME: change flag name\n          this.cloned[3] = true;\n        }\n        */\n        this.decimal_zero_regexp = this.sections.map((section) => {\n            if (section.decimal_max_digits > section.decimal_min_digits) {\n                return new RegExp(`0{1,${section.decimal_max_digits - section.decimal_min_digits}}(?:$|e)`);\n            }\n            return undefined;\n        });\n    }\n    /**\n     * render text parts to string\n     * FIXME: move\n     */\n    static FormatPartsAsText(parts, text_width = 0) {\n        let padded = -1;\n        const formatted = parts.map((part, index) => {\n            switch (part.flag) {\n                case treb_base_types__WEBPACK_IMPORTED_MODULE_2__.TextPartFlag.padded:\n                    padded = index;\n                    return part.text;\n                case treb_base_types__WEBPACK_IMPORTED_MODULE_2__.TextPartFlag.hidden:\n                    return part.text.replace(/./g, ' ');\n                case treb_base_types__WEBPACK_IMPORTED_MODULE_2__.TextPartFlag.formatting:\n                    return '';\n                default:\n                    return part.text;\n            }\n        });\n        if (padded >= 0 && text_width) {\n            const total_length = formatted.reduce((a, str, index) => (index === padded) ? a : a + str.length, 0);\n            let tmp = '';\n            for (let i = 0; i < text_width - total_length; i++) {\n                tmp += formatted[padded];\n            }\n            formatted[padded] = tmp;\n        }\n        return formatted.join('');\n    }\n    //  NumberFormat.decimal_mark = Localization.decimal_separator;\n    //  if (NumberFormat.decimal_mark === ',') NumberFormat.grouping_separator = ' ';\n    //  public static decimal_mark: '.'|',' = Localization.decimal_separator;\n    //  public static grouping_separator = (Localization.decimal_separator === '.') ? ',' : ' ';\n    get pattern() {\n        return this._pattern;\n    }\n    /** flag indicates if this is a date format */\n    get date_format() {\n        return this.sections[0] && this.sections[0].date_format;\n    }\n    /** mutate */\n    IncreaseDecimal() {\n        this.sections.forEach((section) => {\n            section.decimal_min_digits++;\n            section.decimal_max_digits = section.decimal_min_digits;\n        });\n    }\n    /** mutate */\n    DecreaseDecimal() {\n        this.sections.forEach((section) => {\n            section.decimal_min_digits = Math.max(0, section.decimal_min_digits - 1);\n            section.decimal_max_digits = section.decimal_min_digits;\n        });\n    }\n    /** mutate */\n    AddGrouping() {\n        this.sections.forEach((section) => {\n            section.grouping = true;\n        });\n    }\n    /** mutate */\n    RemoveGrouping() {\n        this.sections.forEach((section) => {\n            section.grouping = false;\n        });\n    }\n    /** mutate */\n    ToggleGrouping() {\n        // set all to ! the value of the first one \n        const grouping = !this.sections[0].grouping;\n        this.sections.forEach((section) => {\n            section.grouping = grouping;\n        });\n    }\n    /**\n     * generates a string representation. we use this because we are (now)\n     * allowing mutation of formats; therefore we need to serialize them back\n     * to the basic format.\n     */\n    toString() {\n        if (this.sections[0].date_format) {\n            return this._pattern; // immutable\n        }\n        return this.sections.filter((section, i) => {\n            return !this.cloned[i];\n        }).map((section) => {\n            let nf = '';\n            let i = 0;\n            if (section.fraction_format) {\n                if (section.fraction_integer) {\n                    nf += '? ';\n                }\n                let pattern = '';\n                for (let j = 0; j < section.fraction_denominator_digits; j++) {\n                    pattern += '#';\n                }\n                nf += pattern;\n                nf += '/';\n                if (section.fraction_denominator) {\n                    nf += section.fraction_denominator;\n                }\n                else {\n                    nf += pattern;\n                }\n            }\n            else if (section.has_number_format) {\n                for (i = 0; i < section.integer_min_digits; i++) {\n                    nf += '0';\n                }\n                if (section.grouping) {\n                    if (nf.length < 4)\n                        nf = ('####' + nf).slice(-4);\n                    nf = nf.replace(/[\\d#]{1,3}(?=([\\d#]{3})+(?![\\d#]))/g, '$&' + ','); // Localization.grouping_separator);\n                }\n                if (section.decimal_max_digits || section.decimal_min_digits) {\n                    nf += '.'; // Localization.decimal_separator;\n                    for (i = 0; i < section.decimal_min_digits; i++) {\n                        nf += '0';\n                    }\n                    for (; i < section.decimal_max_digits; i++) {\n                        nf += '#';\n                    }\n                }\n                if (section.scaling) {\n                    const count = Math.log10(section.scaling) / 3;\n                    for (i = 0; i < count; i++) {\n                        nf += ',';\n                    }\n                }\n                if (section.exponential) {\n                    nf += 'e';\n                }\n            }\n            return section.prefix.map((part) => {\n                if (part.flag === treb_base_types__WEBPACK_IMPORTED_MODULE_2__.TextPartFlag.hidden) {\n                    return part.text === '0' ? '?' : '_' + part.text;\n                }\n                else if (part.flag === treb_base_types__WEBPACK_IMPORTED_MODULE_2__.TextPartFlag.padded) {\n                    return '*' + part.text;\n                }\n                else if (part.flag === treb_base_types__WEBPACK_IMPORTED_MODULE_2__.TextPartFlag.formatting) {\n                    return '[' + part.text + ']';\n                }\n                return part.text;\n            }).join('') + nf +\n                section.suffix.map((part) => {\n                    if (part.flag === treb_base_types__WEBPACK_IMPORTED_MODULE_2__.TextPartFlag.hidden) {\n                        return part.text === '0' ? '?' : '_' + part.text;\n                    }\n                    else if (part.flag === treb_base_types__WEBPACK_IMPORTED_MODULE_2__.TextPartFlag.padded) {\n                        return '*' + part.text;\n                    }\n                    return part.text;\n                }).join('');\n        }).join(';');\n    }\n    /**\n     * this method composes the format as a set of parts with various\n     * states. it's intended for graphical representation where things\n     * like hidden characters and padding require multiple passes or measurement.\n     */\n    FormatParts(value) {\n        // new, shortcut\n        if (typeof value !== 'number' && !this.sections[3]) {\n            return [{ text: value.toString() }]; // unreachable because we ensure 4 sections\n        }\n        const { parts, section } = this.BaseFormat(value);\n        let text_parts = [];\n        if (section.date_format || section.string_format) {\n            for (const part of parts) {\n                if (typeof part === 'string')\n                    text_parts.push({ text: part });\n                else\n                    text_parts.push(part);\n            }\n        }\n        else {\n            // magic \n            if (this.magic_decimal && parts[1] === '') {\n                parts.splice(1, 1);\n            }\n            text_parts = [\n                ...(section.prefix.map((text_part) => {\n                    return Object.assign({}, text_part);\n                })),\n                { text: section.has_number_format ? parts.join(treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Localization.decimal_separator) : '' },\n                ...(section.suffix.map((text_part) => {\n                    return Object.assign({}, text_part);\n                })),\n            ];\n        }\n        for (let i = 1; i < text_parts.length; i++) {\n            if (text_parts[i].flag === text_parts[i - 1].flag) {\n                text_parts[i].text = text_parts[i - 1].text + text_parts[i].text;\n                text_parts[i - 1].text = '';\n            }\n        }\n        return text_parts.filter((text_part) => text_part.text); // remove empty\n    }\n    /**\n     * formats a number as text.\n     *\n     * this method will use a single space to replace hidden (leading-underscore)\n     * characters. if a text width is provided, it will use that for padding;\n     * otherwise the padding character (we only allow a single padding character)\n     * is rendered once.\n     *\n     * FIXME: date, string (this is lagging)\n     * UPDATE: unifying, basing this on the text part functionality\n     */\n    Format(value, text_width = 0) {\n        /*\n        const parts = this.FormatParts(value);\n        let padded = -1;\n    \n        const formatted = parts.map((part, index) => {\n          switch (part.flag) {\n            case TextPartFlag.padded:\n              padded = index;\n              return part.text;\n    \n            case TextPartFlag.hidden:\n              return part.text.replace(/./g, ' ');\n    \n            case TextPartFlag.formatting:\n              return '';\n    \n            default:\n              return part.text;\n          }\n        });\n    \n        if (padded >= 0 && text_width) {\n          const total_length = formatted.reduce((a, str, index) => (index === padded) ? a : a + str.length, 0);\n          let tmp = '';\n          for (let i = 0; i < text_width - total_length; i++){\n            tmp += formatted[padded];\n          }\n          formatted[padded] = tmp;\n        }\n    \n        return formatted.join('');\n        */\n        return NumberFormat.FormatPartsAsText(this.FormatParts(value), text_width);\n    }\n    ZeroPad(text, length) {\n        while (text.length < length)\n            text = '0' + text;\n        return text;\n    }\n    DateFormat(value) {\n        const date = LotusDate(value);\n        const section = this.sections[0];\n        let hours = date.getUTCHours();\n        if (section.twelve_hour) {\n            if (hours > 12)\n                hours -= 12;\n            if (hours === 0)\n                hours = 12;\n        }\n        const parts = section.prefix.map((part) => {\n            if (part.flag === treb_base_types__WEBPACK_IMPORTED_MODULE_2__.TextPartFlag.date_component_minutes) {\n                if (part.text === 'mm') {\n                    return { text: this.ZeroPad((date.getUTCMinutes()).toString(), 2) };\n                }\n                return { text: this.ZeroPad((date.getUTCMinutes()).toString(), 1) };\n            }\n            else if (part.flag === treb_base_types__WEBPACK_IMPORTED_MODULE_2__.TextPartFlag.date_component) {\n                switch (part.text.toLowerCase()) {\n                    case 'am/pm':\n                    case 'a/p':\n                        {\n                            const elements = part.text.split('/');\n                            return { text: date.getUTCHours() > 12 ? elements[1] : elements[0] };\n                        }\n                    case 'mmmmm':\n                        return { text: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Localization.date_components.long_months[date.getUTCMonth()][0] };\n                    case 'mmmm':\n                        if (part.text === 'MMMM') {\n                            return { text: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Localization.date_components.long_months[date.getUTCMonth()].toUpperCase() };\n                        }\n                        return { text: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Localization.date_components.long_months[date.getUTCMonth()] };\n                    case 'mmm':\n                        if (part.text === 'MMM') {\n                            return { text: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Localization.date_components.short_months[date.getUTCMonth()].toUpperCase() };\n                        }\n                        return { text: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Localization.date_components.short_months[date.getUTCMonth()] };\n                    case 'mm':\n                        return { text: this.ZeroPad((date.getUTCMonth() + 1).toString(), 2) };\n                    case 'm':\n                        return { text: this.ZeroPad((date.getUTCMonth() + 1).toString(), 1) };\n                    case 'ddddd':\n                    case 'dddd':\n                        if (part.text === 'DDDDD' || part.text === 'DDDD') {\n                            return { text: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Localization.date_components.long_days[date.getUTCDay()].toUpperCase() };\n                        }\n                        return { text: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Localization.date_components.long_days[date.getUTCDay()] };\n                    case 'ddd':\n                        if (part.text === 'DDD') {\n                            return { text: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Localization.date_components.short_days[date.getUTCDay()].toUpperCase() };\n                        }\n                        return { text: treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Localization.date_components.short_days[date.getUTCDay()] };\n                    case 'dd':\n                        return { text: this.ZeroPad((date.getUTCDate()).toString(), 2) };\n                    case 'd':\n                        return { text: this.ZeroPad((date.getUTCDate()).toString(), 1) };\n                    case 'yyyy':\n                    case 'yyy':\n                        return { text: date.getUTCFullYear().toString() };\n                    case 'yy':\n                    case 'y':\n                        // return { text: (date.getUTCFullYear() % 100).toString() };\n                        return { text: this.ZeroPad((date.getUTCFullYear() % 100).toString(), 2) };\n                    case 'hh':\n                        return { text: this.ZeroPad(hours.toString(), 2) };\n                    case 'h':\n                        return { text: this.ZeroPad(hours.toString(), 1) };\n                    case 'ss':\n                        return { text: this.ZeroPad((date.getUTCSeconds()).toString(), 2) };\n                    case 's':\n                        return { text: this.ZeroPad((date.getUTCSeconds()).toString(), 1) };\n                }\n                const match = part.text.match(/^(s+)\\.(0+)$/);\n                if (match) {\n                    return {\n                        text: this.ZeroPad(date.getUTCSeconds().toString(), match[1].length) +\n                            treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Localization.decimal_separator +\n                            (date.getUTCMilliseconds() / 1000).toFixed(match[2].length).substr(2),\n                    };\n                }\n            }\n            return Object.assign({}, part); // text: part.text, state: part.state};\n        });\n        return { parts, section };\n    }\n    StringFormat(value, section) {\n        const parts = [];\n        for (const part of section.prefix) {\n            if (part.flag === treb_base_types__WEBPACK_IMPORTED_MODULE_2__.TextPartFlag.literal) {\n                parts.push({ text: value });\n            }\n            else\n                parts.push(Object.assign({}, part));\n        }\n        return {\n            parts, section,\n        };\n    }\n    /*\n    public DecimalAdjustRound(value: number, exp: number) {\n  \n      if (!exp) { return Math.round(value); }\n  \n      value = +value;\n      // exp = +exp;\n  \n      // Shift\n      let values = value.toString().split('e');\n      value = Math.round(+(values[0] + 'e' + (values[1] ? (+values[1] - exp) : -exp)));\n  \n      // Shift back\n      values = value.toString().split('e');\n      return +(values[0] + 'e' + (values[1] ? (+values[1] + exp) : exp));\n  \n    }\n    */\n    Round2(value, digits) {\n        const m = Math.pow(10, digits);\n        return Math.round(m * value) / m;\n    }\n    FormatFraction(value, section) {\n        if (section.percent) {\n            value *= 100;\n        }\n        let candidate = {\n            denominator: 1,\n            numerator: Math.round(value),\n            error: Math.abs(Math.round(value) - value),\n        };\n        if (section.fraction_denominator) {\n            candidate.denominator = section.fraction_denominator;\n            candidate.numerator = Math.round(value * candidate.denominator);\n        }\n        else {\n            if (candidate.error) {\n                const limit = NumberFormat.fraction_limits[section.fraction_denominator_digits - 1] || NumberFormat.fraction_limits[0];\n                for (let denominator = 2; denominator <= limit; denominator++) {\n                    const numerator = Math.round(value * denominator);\n                    const error = Math.abs(numerator / denominator - value);\n                    if (error < candidate.error) {\n                        candidate = {\n                            numerator, denominator, error,\n                        };\n                        if (!error) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        const text = [];\n        if (section.fraction_integer) {\n            const integer = Math.floor(candidate.numerator / candidate.denominator);\n            candidate.numerator %= candidate.denominator;\n            if (integer || !candidate.numerator) {\n                text.push(integer.toString());\n                if (candidate.numerator) {\n                    text.push(' ');\n                }\n            }\n        }\n        else if (!candidate.numerator) {\n            text.push('0');\n        }\n        if (candidate.numerator) {\n            text.push(candidate.numerator.toString());\n            text.push('/');\n            text.push(candidate.denominator.toString());\n        }\n        return text.join('');\n    }\n    BaseFormat(value) {\n        if (this.sections[0].date_format) {\n            return this.DateFormat(Number(value));\n        }\n        if (typeof value !== 'number') {\n            return this.StringFormat(value.toString(), this.sections[3]);\n        }\n        let section = this.sections[0];\n        let zero_regexp = this.decimal_zero_regexp[0];\n        if (value < 0) {\n            section = this.sections[1];\n        }\n        const max_digits = section.percent ?\n            section.decimal_max_digits + 2 :\n            section.decimal_max_digits;\n        const epsilon = Math.pow(10, -max_digits) / 2;\n        let abs_value = Math.abs(value);\n        if (abs_value < epsilon) {\n            section = this.sections[2];\n            zero_regexp = this.decimal_zero_regexp[2];\n        }\n        // there's kind of a weird thing here where we might have\n        // a non-zero number but scaling turns it into zero...\n        if (section.scaling) {\n            abs_value /= section.scaling;\n            if (abs_value < epsilon) {\n                section = this.sections[2];\n                zero_regexp = this.decimal_zero_regexp[2];\n            }\n        }\n        if (section.string_format) {\n            return this.StringFormat(value.toString(), section);\n        }\n        let representation = '';\n        // special handling for fractions skips most of the other bits\n        if (section.fraction_format) {\n            return { parts: [this.FormatFraction(abs_value, section)], section };\n        }\n        if (section.exponential) {\n            representation = abs_value.toExponential(section.decimal_max_digits);\n        }\n        else {\n            if (section.percent) {\n                abs_value *= 100;\n            }\n            representation = this.Round2(abs_value, section.decimal_max_digits).toFixed(section.decimal_max_digits);\n        }\n        if (zero_regexp) {\n            representation = representation.replace(zero_regexp, '');\n        }\n        const parts = representation.split('.');\n        while (parts[0].length < section.integer_min_digits) {\n            parts[0] = ('0000000000000000' + parts[0]).slice(-section.integer_min_digits);\n        }\n        if (section.integer_min_digits === 0 && parts[0] === '0') {\n            parts[0] = ''; // not sure why anyone would want that\n        }\n        if (section.grouping) {\n            parts[0] = parts[0].replace(NumberFormat.grouping_regexp, '$&' + treb_base_types__WEBPACK_IMPORTED_MODULE_2__.Localization.grouping_separator);\n        }\n        return { parts, section };\n    }\n}\nNumberFormat.grouping_regexp = /\\d{1,3}(?=(\\d{3})+(?!\\d))/g;\nNumberFormat.fraction_limits = [9, 99, 999, 9999];\n\n\n//# sourceURL=webpack://treb/./treb-format/src/format.ts?");

/***/ }),

/***/ "./treb-format/src/format_cache.ts":
/*!*****************************************!*\
  !*** ./treb-format/src/format_cache.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NumberFormatCache\": () => (/* binding */ NumberFormatCache)\n/* harmony export */ });\n/* harmony import */ var _format__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./format */ \"./treb-format/src/format.ts\");\n\n/**\n * since users almost always make caches, we might as well\n * support a universal cache. also universal base (named) types.\n *\n * note that for this reason, you shouldn't mutate number formats.\n * mutate copies instead.\n */\nclass NumberFormatCache {\n    static Get(format) {\n        // FIXME: we should use icase for symbolc formats, although not\n        // for format strings. there should (hopefully) be no case where\n        // these overlap.\n        const canonical_name = this.symbolc_name_map[format.toLowerCase()];\n        let formatter = this.cache[canonical_name || format];\n        if (!formatter) {\n            formatter = new _format__WEBPACK_IMPORTED_MODULE_0__.NumberFormat(format);\n            this.cache[format] = formatter;\n        }\n        return formatter;\n    }\n    /**\n     * does anyone use this? (...)\n     */\n    static Equals(a, b) {\n        if (a === b)\n            return true;\n        const fa = this.Get(a);\n        const fb = this.Get(b);\n        return fa.pattern === fb.pattern;\n    }\n    /**\n     * this method is used to translate symbolic formats,\n     * without actually creating a formatter. it's a shortcut\n     * we need for exporting to xlsx.\n     *\n     * if the passed format matches a symbolic format, we return\n     * the string representation. if it doesn't match any symbolic format,\n     * the string is returned as-is.\n     */\n    static Translate(format) {\n        const mapped = this.symbolc_name_map[format.toLowerCase()];\n        return mapped ? this.cache[mapped].toString() : format;\n        // const formatter = this.cache[format];\n        // if (formatter) { return formatter.toString(); }\n        // return format;\n    }\n    /**\n     * check if the format (as a number format) matches a local\n     * symbolic name and if so, return that.\n     */\n    static SymbolicName(format) {\n        for (const key of Object.keys(this.base_formats)) {\n            if (format === this.base_formats[key])\n                return key;\n        }\n        return null;\n    }\n    static InitCache() {\n        for (const key of Object.keys(this.base_formats)) {\n            this.cache[key] = new _format__WEBPACK_IMPORTED_MODULE_0__.NumberFormat(this.base_formats[key]);\n            this.symbolc_name_map[key.toLowerCase()] = key;\n        }\n        // we're doing this to hide it, but we might as well allow it\n        // since js interfaces will find it regardless\n        this.cache['General'].magic_decimal = true;\n        for (const key of Object.keys(this.aliases)) {\n            this.cache[key] = this.cache[this.aliases[key]];\n            this.symbolc_name_map[key.toLowerCase()] = key;\n        }\n    }\n}\n/** cache instance */\nNumberFormatCache.cache = {};\n/**\n * this map is for case-insensitive mapping symbolic names to formats. we\n * want symbolic names with casing, primarily for interop, but we also want\n * to support icase matching.\n *\n * FIXME: is there a better way to do this, with a pattern or something in\n * the cache?\n */\nNumberFormatCache.symbolc_name_map = {};\n/** base types, with default names */\nNumberFormatCache.base_formats = {\n    Accounting: '_(#,##0.00_);(#,##0.00);-???',\n    Number: '0.00',\n    Integer: '0',\n    Percent: '0.00%',\n    General: '0.######',\n    Fraction: '# ?/?',\n    Dollar: '$* _(#,##0.00_);$* (#,##0.00);$* -???',\n    Exponential: '0.000e',\n    'Short Date': 'mm/dd/yy',\n    'Long Date': 'dddd, mmm d yyyy',\n    Timestamp: 'mm-dd-yy hh:mm:ss',\n};\n/** alias types */\nNumberFormatCache.aliases = {\n    Scientific: 'Exponential',\n    Percentage: 'Percent',\n    Currency: 'Dollar',\n    /*\n    // we switched to Uppercase symbolic names to better\n    // match imported files, but we have legacy stuff using\n    // lowercase, so add aliases.\n\n    accounting: 'Accounting',\n    number: 'Number',\n    integer: 'Integer',\n    percent: 'Percent',\n    general: 'General',\n    dollar: 'Dollar',\n    exponential: 'Exponential',\n\n    'short date': 'Short Date',\n    'long date': 'Long Date',\n    timestamp: 'Timestamp',\n    */\n};\n// is there a pattern for this? or a preferred way? I'm actually\n// concerned that an optimizer might remove the method.\nNumberFormatCache.InitCache();\n// (self as any).NFC = NumberFormatCache;\n\n\n//# sourceURL=webpack://treb/./treb-format/src/format_cache.ts?");

/***/ }),

/***/ "./treb-format/src/format_parser.ts":
/*!******************************************!*\
  !*** ./treb-format/src/format_parser.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FormatParser\": () => (/* binding */ FormatParser)\n/* harmony export */ });\n/* harmony import */ var _number_format_section__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number_format_section */ \"./treb-format/src/number_format_section.ts\");\n/* harmony import */ var treb_base_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! treb-base-types */ \"./treb-base-types/src/index.ts\");\n\n\nconst ASTERISK = 0x2A; // TODO\nconst UNDERSCORE = 0x5F; // TODO\nconst QUESTION_MARK = 0x3F;\nconst ZERO = 0x30;\nconst PERIOD = 0x2E;\nconst SPACE = 0x20;\nconst COMMA = 0x2C;\nconst PERCENT = 0x25;\nconst DOUBLE_QUOTE = 0x22;\nconst NUMBER_SIGN = 0x23;\nconst SEMICOLON = 0x3B;\nconst BACKSLASH = 0x5C;\nconst FORWARDSLASH = 0x2F;\nconst AT = 0x40;\nconst LEFT_BRACE = 0x5B;\nconst RIGHT_BRACE = 0x5D;\nconst UPPERCASE_E = 0x45;\nconst LOWERCASE_E = 0x65;\nconst UPPERCASE_H = 0x48;\nconst LOWERCASE_H = 0x68;\nconst UPPERCASE_M = 0x4D;\nconst LOWERCASE_M = 0x6D;\nconst UPPERCASE_S = 0x53;\nconst LOWERCASE_S = 0x73;\nconst UPPERCASE_D = 0x44;\nconst LOWERCASE_D = 0x64;\nconst UPPERCASE_Y = 0x59;\nconst LOWERCASE_Y = 0x79;\nconst UPPERCASE_A = 0x41;\nconst LOWERCASE_A = 0x61;\nvar NumberPart;\n(function (NumberPart) {\n    NumberPart[NumberPart[\"Integer\"] = 0] = \"Integer\";\n    NumberPart[NumberPart[\"Decimal\"] = 1] = \"Decimal\";\n})(NumberPart || (NumberPart = {}));\nclass FormatParser {\n    /**\n     * parser is static (essentially a singleton). state is ephemeral.\n     *\n     * it's a little hard to unify parsing for dates and numbers.\n     * luckily we don't have to parse that often; only when a format\n     * is created. so we will do some extra work here.\n     */\n    static Parse(pattern) {\n        // local\n        this.pattern = pattern;\n        // convert to numbers\n        this.characters = pattern.split('').map((char) => char.charCodeAt(0));\n        // pointer\n        this.char_index = 0;\n        // allocate initial section\n        this.current_section = new _number_format_section__WEBPACK_IMPORTED_MODULE_0__.NumberFormatSection();\n        this.sections = [this.current_section];\n        // check if it's a date, if so we can move on\n        if (this.ParseDatePattern()) {\n            return this.sections;\n        }\n        // not a date; reset and try again\n        this.char_index = 0;\n        this.current_section = new _number_format_section__WEBPACK_IMPORTED_MODULE_0__.NumberFormatSection();\n        this.sections = [this.current_section];\n        // parse\n        while (this.char_index < this.characters.length) {\n            this.ConsumeChar();\n        }\n        // result\n        return this.sections;\n    }\n    static ConsumeString() {\n        let text = '';\n        if (this.preserve_formatting_characters) {\n            text += this.pattern[this.char_index]; // \"\n        }\n        for (++this.char_index; this.char_index < this.characters.length; this.char_index++) {\n            const char = this.characters[this.char_index];\n            switch (char) {\n                case BACKSLASH: // escape character\n                    if (this.preserve_formatting_characters) {\n                        text += this.pattern[this.char_index];\n                    }\n                    if ((this.char_index + 1) < this.characters.length) {\n                        text += this.pattern[++this.char_index];\n                    }\n                    break;\n                case DOUBLE_QUOTE:\n                    if (this.preserve_formatting_characters) {\n                        text += this.pattern[this.char_index]; // \"\n                    }\n                    this.char_index++;\n                    return text;\n                default:\n                    text += this.pattern[this.char_index];\n                    break;\n            }\n        }\n        throw new Error('unterminated string');\n    }\n    static ConsumeFormatting() {\n        let text = '';\n        for (++this.char_index; this.char_index < this.characters.length; this.char_index++) {\n            const char = this.characters[this.char_index];\n            switch (char) {\n                case BACKSLASH:\n                    throw new Error('invalid escape character in formatting block');\n                case RIGHT_BRACE:\n                    this.char_index++;\n                    return text;\n                default:\n                    text += this.pattern[this.char_index];\n                    break;\n            }\n        }\n        throw new Error('unterminated format');\n    }\n    /**\n     * pre-scan for fractional format, check for legal/illegal chars.\n     * fraction format has an optional integer, spaces, then the fractional\n     * part.\n     *\n     * except for the denominator, all characters are represented as # or ?,\n     * but formats seem to be a little forgiving (not sure we have to be).\n     * essentially, should look something like\n     * ```\n     * # ##/##\n     * ? ??/??\n     * #/32\n     * #/64\n     * # #/16\n     * ```\n     */\n    static ScanFractionFormat() {\n        const fraction_regex = /^([#?]+ +){0,1}([#?]+)\\/([#?0-9]+)(?:$|[^#?0-9])/;\n        const text = this.pattern.substr(this.char_index);\n        const match = text.match(fraction_regex);\n        if (!match) {\n            return false;\n        }\n        const len = (match[1] || '').length + match[2].length + match[3].length + 1;\n        // flag\n        this.current_section.fraction_format = true;\n        // has integer section\n        this.current_section.fraction_integer = !!match[1];\n        // fixed denominator\n        const fixed_denominator = Number(match[3]);\n        if (!isNaN(fixed_denominator)) {\n            this.current_section.fraction_denominator = fixed_denominator;\n        }\n        // we do this regardless; it's used when collapsing values to zero\n        this.current_section.decimal_max_digits = this.current_section.fraction_denominator_digits = match[3].length;\n        this.char_index += len;\n        this.current_section.has_number_format = true;\n        return true;\n    }\n    /**\n     * number format proper contains only the following characters:\n     * +-0#.,\n     * anything else will be ignored\n     *\n     * [UPDATE] fractional number formats can contain spaces and\n     * the / character (in fact they would have to contain that).\n     *\n     */\n    static ConsumeNumberFormat() {\n        let number_part = NumberPart.Integer;\n        for (this.char_index; this.char_index < this.characters.length; this.char_index++) {\n            const char = this.characters[this.char_index];\n            switch (char) {\n                case this.group_separator:\n                    {\n                        // the behavior of this token is different at the end of the number\n                        // format. in that case, each comma represents 'scale by 1000'. so\n                        // we need to do lookahead... but we only one character?\n                        let lookahead_digit = false;\n                        for (let i = this.char_index + 1; !lookahead_digit && i < this.characters.length; i++) {\n                            const next_char = this.characters[i];\n                            if (next_char === this.decimal_mark\n                                || next_char === NUMBER_SIGN\n                                || next_char === ZERO) {\n                                lookahead_digit = true;\n                            }\n                            else if (next_char !== COMMA) {\n                                break;\n                            }\n                        }\n                        if (lookahead_digit) {\n                            if (number_part === NumberPart.Decimal) {\n                                throw new Error('invalid grouping in decimal part');\n                            }\n                            this.current_section.grouping = true;\n                        }\n                        else {\n                            this.current_section.scaling = (this.current_section.scaling || 1) * 1000;\n                        }\n                    }\n                    break;\n                case this.decimal_mark:\n                    if (number_part === NumberPart.Decimal) {\n                        throw new Error('too many decimal marks');\n                    }\n                    number_part = NumberPart.Decimal;\n                    break;\n                case NUMBER_SIGN:\n                    // spacing. allowing for some junk, we treat these as required\n                    // if they're inside of zeros (after in the case of integer, before\n                    // in the case of decimal)\n                    if (number_part === NumberPart.Decimal) {\n                        this.current_section.decimal_max_digits++;\n                    }\n                    else if (this.current_section.integer_min_digits) {\n                        this.current_section.integer_min_digits++;\n                    }\n                    break;\n                case ZERO:\n                    // required digit.\n                    if (number_part === NumberPart.Decimal) {\n                        this.current_section.decimal_max_digits++;\n                        this.current_section.decimal_min_digits = this.current_section.decimal_max_digits;\n                    }\n                    else {\n                        this.current_section.integer_min_digits++;\n                    }\n                    break;\n                default:\n                    // non-number format character; we're done?\n                    return;\n            }\n        }\n    }\n    static AppendCharAsText(advance_pointer = true) {\n        if (this.current_section.has_number_format) {\n            this.current_section.suffix[this.current_section.suffix.length - 1].text += this.pattern[this.char_index];\n        }\n        else {\n            this.current_section.prefix[this.current_section.prefix.length - 1].text += this.pattern[this.char_index];\n        }\n        if (advance_pointer) {\n            this.char_index++;\n        }\n    }\n    static AppendString(text) {\n        if (this.current_section.has_number_format) {\n            this.current_section.suffix[this.current_section.suffix.length - 1].text += text;\n        }\n        else {\n            this.current_section.prefix[this.current_section.prefix.length - 1].text += text;\n        }\n    }\n    static AppendTextPart(part) {\n        if (this.current_section.has_number_format) {\n            this.current_section.suffix.push(part);\n            this.current_section.suffix.push({ text: '' });\n        }\n        else {\n            this.current_section.prefix.push(part);\n            this.current_section.prefix.push({ text: '' });\n        }\n    }\n    static ConsumeChar() {\n        const char = this.characters[this.char_index];\n        // check for fraction format. this can't happen in a string section,\n        // and if there's already a number format then treat it as text (garbage).\n        if (char === QUESTION_MARK || char === NUMBER_SIGN) {\n            if (!this.current_section.has_number_format &&\n                !this.current_section.string_format &&\n                this.ScanFractionFormat()) {\n                return;\n            }\n        }\n        switch (char) {\n            case SEMICOLON:\n                // FIXME: there's a concept of an \"empty\" section, which is\n                // zero-length text between semicolons (or before the first\n                // semicolon). we should treat those as cloned or synthentic.\n                // actually, is that legal for the first section? possibly not.\n                this.char_index++; // discard\n                this.current_section = new _number_format_section__WEBPACK_IMPORTED_MODULE_0__.NumberFormatSection();\n                if (this.sections.length === 3)\n                    this.current_section.string_format = true;\n                this.sections.push(this.current_section);\n                break;\n            case AT:\n                this.char_index++;\n                this.AppendTextPart({\n                    text: '@', flag: treb_base_types__WEBPACK_IMPORTED_MODULE_1__.TextPartFlag.literal,\n                });\n                this.current_section.string_format = true; // force\n                break;\n            case ZERO:\n            case NUMBER_SIGN:\n            case PERIOD:\n            case COMMA:\n                // only one actual format. anything else is treated as text.\n                // also skip for string format (#4)\n                if (!this.current_section.has_number_format && !this.current_section.string_format) {\n                    this.ConsumeNumberFormat();\n                    this.current_section.has_number_format = true;\n                }\n                else {\n                    this.AppendCharAsText();\n                }\n                break;\n            case LEFT_BRACE:\n                this.AppendTextPart({ text: this.ConsumeFormatting(), flag: treb_base_types__WEBPACK_IMPORTED_MODULE_1__.TextPartFlag.formatting });\n                break;\n            case DOUBLE_QUOTE:\n                this.AppendString(this.ConsumeString());\n                break;\n            case QUESTION_MARK: // this is like _0\n                if (this.preserve_formatting_characters) {\n                    this.AppendCharAsText();\n                }\n                else {\n                    this.AppendTextPart({\n                        text: '0',\n                        flag: treb_base_types__WEBPACK_IMPORTED_MODULE_1__.TextPartFlag.hidden,\n                    });\n                    this.char_index++;\n                }\n                break;\n            case UNDERSCORE:\n                if (this.preserve_formatting_characters) {\n                    this.AppendCharAsText();\n                }\n                else {\n                    if (++this.char_index >= this.characters.length) {\n                        throw new Error('invalid pad character at end');\n                    }\n                    this.AppendTextPart({\n                        text: this.pattern[this.char_index++],\n                        flag: treb_base_types__WEBPACK_IMPORTED_MODULE_1__.TextPartFlag.hidden,\n                    });\n                }\n                break;\n            case ASTERISK:\n                if (this.current_section.has_asterisk) {\n                    throw new Error(`we don't support multiple asterisks`);\n                }\n                if (this.preserve_formatting_characters) {\n                    this.AppendCharAsText();\n                }\n                else {\n                    if (++this.char_index >= this.characters.length) {\n                        throw new Error('invalid pad character at end');\n                    }\n                    this.AppendTextPart({\n                        text: this.pattern[this.char_index++],\n                        flag: treb_base_types__WEBPACK_IMPORTED_MODULE_1__.TextPartFlag.padded,\n                    });\n                    this.current_section.has_asterisk = true;\n                }\n                break;\n            case LOWERCASE_E:\n            case UPPERCASE_E:\n                if (this.current_section.percent ||\n                    this.current_section.exponential ||\n                    this.current_section.string_format) {\n                    this.AppendCharAsText();\n                }\n                else {\n                    this.current_section.exponential = true;\n                    this.char_index++;\n                }\n                break;\n            case PERCENT:\n                if (!this.current_section.exponential && !this.current_section.string_format) {\n                    this.current_section.percent = true;\n                }\n                this.AppendCharAsText();\n                break;\n            case BACKSLASH:\n                if (this.preserve_formatting_characters) {\n                    this.AppendCharAsText(false);\n                }\n                if (++this.char_index >= this.characters.length) {\n                    throw new Error('invalid escape character at end');\n                }\n                this.AppendCharAsText();\n                break;\n            default:\n                this.AppendCharAsText();\n        }\n    }\n    /**\n     * we treat it as a date pattern if there's an unquoted date/time letter\n     * (one of [hmsdyHMSDY]). technically mixing date formats and number\n     * formats (#0) is illegal. we will just drop into number formats for those.\n     */\n    static ParseDatePattern() {\n        this.date_pattern = true;\n        while (this.date_pattern && this.char_index < this.pattern.length) {\n            this.DatePatternConsumeChar();\n        }\n        // one more check: there has to be a date format part in there\n        if (this.date_pattern) {\n            this.date_pattern = false;\n            for (const section of this.sections) {\n                for (const part of section.prefix) {\n                    // tslint:disable-next-line: no-bitwise\n                    if (part.flag && (part.flag & (treb_base_types__WEBPACK_IMPORTED_MODULE_1__.TextPartFlag.date_component | treb_base_types__WEBPACK_IMPORTED_MODULE_1__.TextPartFlag.date_component_minutes))) {\n                        this.date_pattern = true;\n                    }\n                }\n            }\n        }\n        // if it _is_ a date pattern, set the section flag.\n        if (this.date_pattern) {\n            this.sections[0].date_format = true;\n            // check for minutes, and set the flag (actually state in the text\n            // part). in date formats mm means months _unless_ it is preceded\n            // by an hh or followed by an ss.\n            this.sections[0].prefix.forEach((item, index) => {\n                if (item.flag === treb_base_types__WEBPACK_IMPORTED_MODULE_1__.TextPartFlag.date_component && (item.text === 'mm' || item.text === 'm')) {\n                    if (index) {\n                        for (let i = index - 1; i; i--) {\n                            const test = this.sections[0].prefix[i];\n                            if (test.flag === treb_base_types__WEBPACK_IMPORTED_MODULE_1__.TextPartFlag.date_component) {\n                                if (/h/i.test(test.text)) {\n                                    item.flag = treb_base_types__WEBPACK_IMPORTED_MODULE_1__.TextPartFlag.date_component_minutes;\n                                    item.text = item.text.toLowerCase(); // normalize\n                                }\n                                break;\n                            }\n                        }\n                    }\n                    if (index < this.sections[0].prefix.length - 1) {\n                        for (let i = index + 1; i < this.sections[0].prefix.length; i++) {\n                            const test = this.sections[0].prefix[i];\n                            if (test.flag === treb_base_types__WEBPACK_IMPORTED_MODULE_1__.TextPartFlag.date_component) {\n                                if (/s/i.test(test.text)) {\n                                    item.flag = treb_base_types__WEBPACK_IMPORTED_MODULE_1__.TextPartFlag.date_component_minutes;\n                                    item.text = item.text.toLowerCase(); // normalize\n                                }\n                                break;\n                            }\n                        }\n                    }\n                }\n            });\n        }\n        return this.date_pattern;\n    }\n    /**\n     * date parts are repeated sequences (e.g. ddd). we allow\n     * fractional seconds with ss.00.\n     */\n    static ConsumeDatePart() {\n        const initial_char = this.pattern[this.char_index++];\n        const normalized = initial_char.toLowerCase();\n        const part = {\n            text: initial_char,\n            flag: treb_base_types__WEBPACK_IMPORTED_MODULE_1__.TextPartFlag.date_component,\n        };\n        while (this.pattern[this.char_index] && (this.pattern[this.char_index].toLowerCase() === normalized)) {\n            part.text += (this.pattern[this.char_index++]);\n        }\n        // partial seconds\n        if (normalized === 's' && this.pattern[this.char_index] === '.') {\n            part.text += (this.pattern[this.char_index++]);\n            while (this.pattern[this.char_index] === '0') {\n                part.text += (this.pattern[this.char_index++]);\n            }\n        }\n        return part;\n    }\n    /**\n     * special patterns for am/pm in date formats\n     */\n    static ConsumeAMPM() {\n        let test = this.pattern.substr(this.char_index, 5);\n        if (test === 'am/pm' || test === 'AM/PM') {\n            this.char_index += 5;\n            this.sections[0].twelve_hour = true;\n            return { text: test, flag: treb_base_types__WEBPACK_IMPORTED_MODULE_1__.TextPartFlag.date_component };\n        }\n        test = this.pattern.substr(this.char_index, 3);\n        if (test === 'a/p' || test === 'A/P') {\n            this.char_index += 3;\n            this.sections[0].twelve_hour = true;\n            return { text: test, flag: treb_base_types__WEBPACK_IMPORTED_MODULE_1__.TextPartFlag.date_component };\n        }\n        return undefined;\n    }\n    static DatePatternConsumeChar() {\n        const char = this.characters[this.char_index];\n        switch (char) {\n            case SEMICOLON:\n                // only one section allowed for dates (not sure why). just ignore\n                // everything after the semicolon, but don't invalidate the pattern.\n                this.char_index = this.characters.length; // end\n                break;\n            case ZERO:\n            case NUMBER_SIGN:\n            case LOWERCASE_E:\n            case UPPERCASE_E:\n            case PERCENT:\n            case AT:\n                // case PERIOD:\n                // case COMMA:\n                // this is not a date format.\n                this.date_pattern = false;\n                break;\n            case UPPERCASE_H:\n            case LOWERCASE_H:\n            case UPPERCASE_M:\n            case LOWERCASE_M:\n            case UPPERCASE_S:\n            case LOWERCASE_S:\n            case UPPERCASE_D:\n            case LOWERCASE_D:\n            case UPPERCASE_Y:\n            case LOWERCASE_Y:\n                this.AppendTextPart(this.ConsumeDatePart());\n                break;\n            case UPPERCASE_A:\n            case LOWERCASE_A:\n                {\n                    const ampm = this.ConsumeAMPM();\n                    if (ampm)\n                        this.AppendTextPart(ampm);\n                    else\n                        this.AppendCharAsText();\n                }\n                break;\n            case DOUBLE_QUOTE:\n                this.AppendString(this.ConsumeString());\n                break;\n            case QUESTION_MARK: // this is like _0\n                if (this.preserve_formatting_characters) {\n                    this.AppendCharAsText();\n                }\n                else {\n                    this.AppendTextPart({\n                        text: '0',\n                        flag: treb_base_types__WEBPACK_IMPORTED_MODULE_1__.TextPartFlag.hidden,\n                    });\n                    this.char_index++;\n                }\n                break;\n            case UNDERSCORE:\n                if (this.preserve_formatting_characters) {\n                    this.AppendCharAsText();\n                }\n                else {\n                    if (++this.char_index >= this.characters.length) {\n                        throw new Error('invalid pad character at end');\n                    }\n                    this.AppendTextPart({\n                        text: this.pattern[this.char_index++],\n                        flag: treb_base_types__WEBPACK_IMPORTED_MODULE_1__.TextPartFlag.hidden,\n                    });\n                }\n                break;\n            case ASTERISK:\n                if (this.current_section.has_asterisk) {\n                    throw new Error(`we don't support multiple asterisks`);\n                }\n                if (this.preserve_formatting_characters) {\n                    this.AppendCharAsText();\n                }\n                else {\n                    if (++this.char_index >= this.characters.length) {\n                        throw new Error('invalid pad character at end');\n                    }\n                    this.AppendTextPart({\n                        text: this.pattern[this.char_index++],\n                        flag: treb_base_types__WEBPACK_IMPORTED_MODULE_1__.TextPartFlag.padded,\n                    });\n                    this.current_section.has_asterisk = true;\n                }\n                break;\n            case BACKSLASH:\n                if (this.preserve_formatting_characters) {\n                    this.AppendCharAsText(false);\n                }\n                if (++this.char_index >= this.characters.length) {\n                    throw new Error('invalid escape character at end');\n                }\n                this.AppendCharAsText();\n                break;\n            default:\n                this.AppendCharAsText();\n        }\n    }\n}\nFormatParser.date_pattern = false;\nFormatParser.pattern = '';\nFormatParser.char_index = 0;\nFormatParser.characters = [];\nFormatParser.sections = [];\nFormatParser.current_section = new _number_format_section__WEBPACK_IMPORTED_MODULE_0__.NumberFormatSection();\nFormatParser.preserve_formatting_characters = false; // true;\n// FIXME: localization\nFormatParser.decimal_mark = PERIOD;\nFormatParser.group_separator = COMMA;\n\n\n//# sourceURL=webpack://treb/./treb-format/src/format_parser.ts?");

/***/ }),

/***/ "./treb-format/src/index.ts":
/*!**********************************!*\
  !*** ./treb-format/src/index.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NumberFormatSection\": () => (/* reexport safe */ _number_format_section__WEBPACK_IMPORTED_MODULE_0__.NumberFormatSection),\n/* harmony export */   \"LotusDate\": () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_1__.LotusDate),\n/* harmony export */   \"NumberFormat\": () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_1__.NumberFormat),\n/* harmony export */   \"UnlotusDate\": () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_1__.UnlotusDate),\n/* harmony export */   \"NumberFormatCache\": () => (/* reexport safe */ _format_cache__WEBPACK_IMPORTED_MODULE_2__.NumberFormatCache),\n/* harmony export */   \"Hints\": () => (/* reexport safe */ _value_parser__WEBPACK_IMPORTED_MODULE_3__.Hints),\n/* harmony export */   \"ValueParser\": () => (/* reexport safe */ _value_parser__WEBPACK_IMPORTED_MODULE_3__.ValueParser)\n/* harmony export */ });\n/* harmony import */ var _number_format_section__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number_format_section */ \"./treb-format/src/number_format_section.ts\");\n/* harmony import */ var _format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./format */ \"./treb-format/src/format.ts\");\n/* harmony import */ var _format_cache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./format_cache */ \"./treb-format/src/format_cache.ts\");\n/* harmony import */ var _value_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./value_parser */ \"./treb-format/src/value_parser.ts\");\n\n\n\n\n\n\n//# sourceURL=webpack://treb/./treb-format/src/index.ts?");

/***/ }),

/***/ "./treb-format/src/number_format_section.ts":
/*!**************************************************!*\
  !*** ./treb-format/src/number_format_section.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NumberFormatSection\": () => (/* binding */ NumberFormatSection)\n/* harmony export */ });\n/**\n * essentially number formats have a core section with the number\n * (possibly scaled), and some representation before and after.\n * exponential and percentage notation scale the number. exponential\n * is only allowed after the number. percent can come before or after.\n *\n * converting to class, default values\n *\n * FIXME: this should be an interface, you can create a default instance\n *\n */\nclass NumberFormatSection {\n    constructor() {\n        /** flag: this is a date format */\n        this.date_format = false;\n        /** flag: this is the string section, don't format numbers */\n        this.string_format = false;\n        /** flag: this is a fractional format */\n        this.fraction_format = false;\n        /** flag: time in 12-hour format  */\n        this.twelve_hour = false;\n        /** fraction: fixed denominator */\n        this.fraction_denominator = 0;\n        /** fraction includes integer */\n        this.fraction_integer = true;\n        /** align fraction digits (using ???) [TODO] */\n        this.fraction_align = 0;\n        /**\n         * fraction denominator digits. we will limit to [1,4] but this can\n         * be zero if there's an explicit denominator.\n         */\n        this.fraction_denominator_digits = 0;\n        /** prepend zeros */\n        this.integer_min_digits = 0;\n        /** append zeros */\n        this.decimal_min_digits = 0;\n        /** append decimal digits, but not trailing zeros */\n        this.decimal_max_digits = 0;\n        /** use grouping (only supports groups of 3, no matter where you put the ,) */\n        this.grouping = false;\n        /** this is a flag for switching whether we append strings to prefix or suffix */\n        this.has_number_format = false;\n        /** leading string(s) */\n        this.prefix = [{ text: '' }];\n        /** trailing string(s) */\n        this.suffix = [{ text: '' }];\n        /**\n         * thousands scaling (trailing commas in the number format section). we set\n         * to zero for a faster flag if no scaling.\n         */\n        this.scaling = 0;\n        /** flag indicating percent -- will multiply value by 100 */\n        this.percent = false;\n        /** flag indicating exponential -- turns numbers in to exp format */\n        this.exponential = false;\n        /** this is a flag for testing -- we don't support multiple * in a format */\n        this.has_asterisk = false;\n    }\n}\n\n\n//# sourceURL=webpack://treb/./treb-format/src/number_format_section.ts?");

/***/ }),

/***/ "./treb-format/src/value_parser.ts":
/*!*****************************************!*\
  !*** ./treb-format/src/value_parser.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Hints\": () => (/* binding */ Hints),\n/* harmony export */   \"ValueParser\": () => (/* binding */ ValueParser)\n/* harmony export */ });\n/* harmony import */ var treb_base_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! treb-base-types */ \"./treb-base-types/src/index.ts\");\n/* harmony import */ var _format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./format */ \"./treb-format/src/format.ts\");\n\n\n/**\n * this is code that was in the old number format class, which was superceded\n * by the new treb-format module. we still need to do rough value parsing,\n * which is separate from parsing and from formatting.\n *\n * cleaning up to remove redundant bits, move inference in here\n *\n * FIXME: move this somewhere else, this is the format library\n */\n// tslint:disable:no-bitwise\n/** hints is a bitfield */\nvar Hints;\n(function (Hints) {\n    Hints[Hints[\"None\"] = 0] = \"None\";\n    Hints[Hints[\"Nan\"] = 1] = \"Nan\";\n    Hints[Hints[\"Exponential\"] = 2] = \"Exponential\";\n    Hints[Hints[\"Percent\"] = 4] = \"Percent\";\n    Hints[Hints[\"Currency\"] = 8] = \"Currency\";\n    Hints[Hints[\"Grouping\"] = 16] = \"Grouping\";\n    Hints[Hints[\"Parens\"] = 32] = \"Parens\";\n    Hints[Hints[\"Date\"] = 64] = \"Date\";\n    Hints[Hints[\"Time\"] = 128] = \"Time\";\n})(Hints || (Hints = {}));\nconst this_year = new Date().getUTCFullYear();\n/**\n * value parser class is a singleton, instance is exported\n */\nclass ValueParserType {\n    TestDate(text) {\n        // first check if JS can turn it into a date at all. we can\n        // use that as a baseline/initial check (in any event there's\n        // no point in doing the work otherwise)\n        const date_value = Date.parse(text);\n        if (isNaN(date_value)) {\n            // console.info('td false: is nan')\n            return false;\n        }\n        const date = new Date(date_value);\n        // OK so there's a date, now we can do whatever validation we want\n        // is there a regexp for accented characters? actually we can\n        // maybe go backwards... remove things that properly belong in\n        // dates: numbers, dashes and slashes (+ comma, whitespace)\n        // dots are in some l10n systems... maybe we should check first?\n        // Q: what does lowercase do for accented characters? (...)\n        // NOTE: as it turns out, Date.parse() only handles US-EN. so\n        // all this is unecessary (and unused) in other locales. to really\n        // do this properly we will probably need to write our own locale-\n        // aware date parser. which is probably a lot of work. TODO.\n        const tmp = text.replace(/[\\d\\-\\\\/,.\\s]+/g, ' ').toLocaleLowerCase();\n        // then split into individual strings. trim and drop empty\n        const components = tmp.split(/\\s+/).map(component => component.trim()).filter(component => !!component);\n        if (!components.length) {\n            // console.info('td true: no strings');\n            return date_value; // probably a date\n        }\n        // now we'll compare these to stuff we have in l10n. rule (WIP):\n        // should be in month or day-of-week. accept short or long, or one \n        // character. (one character introduces some ambiguity...)\n        // drop 1 character, it's ambiguous and annoying (also hard to handle)\n        // so basically, any string in here has to be a month or day; we can't \n        // have two of either; they have to match what was parsed; and you can't\n        // have a day-of-week but not a month.\n        // FIXME: cache/precalc\n        // let's do it lazily\n        // NOTE: portugeuse seems to include periods in their abbreviations...\n        if (!this.compare_month) {\n            this.compare_month = {};\n            for (let i = 0; i < 12; i++) {\n                this.compare_month[treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Localization.date_components.long_months[i].toLocaleLowerCase().replace(/\\./, '')] = i;\n                this.compare_month[treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Localization.date_components.short_months[i].toLocaleLowerCase().replace(/\\./, '')] = i;\n                // comparison[Localization.date_components.long_months[i][0].toLocaleLowerCase()] = i;\n            }\n        }\n        if (!this.compare_day) {\n            this.compare_day = {};\n            for (let i = 0; i < 7; i++) {\n                this.compare_day[treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Localization.date_components.long_days[i].toLocaleLowerCase().replace(/\\./, '')] = i;\n                this.compare_day[treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Localization.date_components.short_days[i].toLocaleLowerCase().replace(/\\./, '')] = i;\n            }\n        }\n        let found_month = false;\n        let found_day = false;\n        for (const component of components) {\n            let found = false;\n            for (const [month, value] of Object.entries(this.compare_month)) {\n                if (component === month) {\n                    // can't have two months in a single date\n                    if (found_month) {\n                        // console.info('td false: two months')\n                        return false;\n                    }\n                    // have a string match [FIXME: fuzzy?]\n                    // check that the month matches\n                    if (date.getUTCMonth() !== value) {\n                        // console.info('td false: month mismatch')\n                        return false;\n                    }\n                    found = true;\n                    found_month = true;\n                }\n            }\n            if (!found) {\n                for (const [day, value] of Object.entries(this.compare_day)) {\n                    if (component === day) {\n                        // can't have two days either\n                        if (found_day) {\n                            // console.info('td false: two days')\n                            return false;\n                        }\n                        if (date.getUTCDay() !== value) {\n                            // console.info('td false: day mismatch')\n                            return false;\n                        }\n                        found = true;\n                        found_day = true;\n                    }\n                }\n            }\n            if (!found) {\n                // whatever this string is, we don't recognize it. so this is \n                // probably not a date.\n                // console.info('td false: unmatched string')\n                return false;\n            }\n        }\n        // last check: no DOW without month.\n        if (found_day && !found_month) {\n            // console.info('td false: day but no month')\n            return false;\n        }\n        // OK, accept it\n        // console.info('td true: ran out of cases')\n        return date_value;\n    }\n    /**\n     * parse a string. if it can reasonably be converted to a number,\n     * do that and return the number; otherwise return the original\n     * string. we also return hints as to formatting, which the caller\n     * may use to select a number format.\n     *\n     * remind me why this is better than just using a parser? (...)\n     */\n    TryParse(text = '') {\n        let hints = Hints.None;\n        // starts with SINGLE quote mark. express string.\n        if (text[0] === '\\'')\n            return { value: text, type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.string };\n        // empty string, treat as string (should be === 0 though?)\n        if (text === '')\n            return { value: text, type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.string };\n        // we test if the conversion returns NaN, which usually means\n        // it's not a number -- unless the string is actually NaN, which\n        // is something we want to preserve.\n        if (text === 'NaN')\n            return { value: NaN, type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, hints: Hints.Nan };\n        let x = text.trim();\n        // x = x.replace(/^[\\$]/, '').trim();\n        const currency = x.match(/^[$](.*?)$/);\n        if (currency) {\n            x = currency[1];\n            hints |= Hints.Currency;\n        }\n        const parens = x.match(/^\\((.*?)\\)$/);\n        if (parens) {\n            x = parens[1];\n            hints |= Hints.Parens;\n        }\n        const pct = x.match(/^(.*?)%\\s*$/);\n        if (pct) {\n            x = pct[1];\n            hints |= Hints.Percent;\n        }\n        if (treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Localization.decimal_separator === '.') {\n            if (/,/.test(x)) {\n                x = x.replace(/,/g, '');\n                hints |= Hints.Grouping;\n            }\n        }\n        else {\n            x = x.replace(/(\\d)\\s+/g, '$1'); // remove spaces inside numbers\n            x = x.replace(/\\./g, ''); // remove point separators\n            x = x.replace(/,/, '.'); // convert to US-style\n        }\n        let num = Number(x);\n        if (null === num || isNaN(num)) {\n            // check boolean\n            const lc = text.toLowerCase();\n            if (lc === 'false')\n                return { value: false, type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.boolean };\n            if (lc === 'true')\n                return { value: true, type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.boolean };\n            // check date, but bound on reasonable years...\n            // also maybe parameterize, make this optional\n            // this is too aggressive (at least in chrome). we need to dial it \n            // back a bit. to do that, we will validate any strings in the text\n            // and ensure they look like date components (usually months and days),\n            // within the current locale.    \n            const date = this.TestDate(text);\n            if (false !== date && !isNaN(date)) {\n                // we can drop this bit, now (I think)\n                const check = new Date(date);\n                const year = check.getUTCFullYear();\n                if (year >= (this_year - 200) && year <= (this_year + 200)) {\n                    hints = Hints.Date;\n                    if (check.getHours() || check.getMinutes() || check.getSeconds()) {\n                        hints |= Hints.Time;\n                    }\n                    return {\n                        value: (0,_format__WEBPACK_IMPORTED_MODULE_1__.UnlotusDate)(date),\n                        type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                        hints,\n                    };\n                }\n            }\n            return { value: text, type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.string };\n        }\n        if (parens) {\n            num = -num;\n        }\n        if (pct) {\n            // NOTE: this is an attempt to reduce fp errors that arise\n            // if you /100 (or if you /10 twice, which actually helps, but\n            // is not sufficient). there's probably a better way to do this...\n            const sign = num < 0 ? -1 : 1;\n            const split = (sign * num).toString().split('.');\n            split[0] = ('00' + split[0]).replace(/(\\d\\d)$/, '.$1');\n            num = Number(split.join('')) * sign;\n        }\n        if (/e/.test(text))\n            hints |= Hints.Exponential;\n        return { value: num, type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, hints };\n    }\n}\nconst ValueParser = new ValueParserType();\n\n\n//# sourceURL=webpack://treb/./treb-format/src/value_parser.ts?");

/***/ }),

/***/ "./treb-grid/src/types/annotation.ts":
/*!*******************************************!*\
  !*** ./treb-grid/src/types/annotation.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Annotation\": () => (/* binding */ Annotation)\n/* harmony export */ });\n/* harmony import */ var treb_base_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! treb-base-types */ \"./treb-base-types/src/index.ts\");\n\n/**\n * new annotation class. annotations are arbitrary content\n * inserted into the sheet, using a floating div element. the\n * class is serialized with the sheet, so the caller can recreate\n * the content if desired.\n *\n * because there's an element of layout involved, callers should\n * interact with annotations through the grid class rather than the\n * sheet.\n *\n * we are redesigning layout so that instead of a rectangle, in\n * coordinate space, annotations use extents and offsets in cell space.\n * so layout should now have a TL cell and a BR cell plus offsets for\n * each. Offset is implemented as a % of the given cell, so offsets are\n * inverted in the TL/BR cells.\n *\n * UPDATE: actually while the inverted BR offset makes intuitive sense,\n * it doesn't make technical sense -- easier to always calcluate offsets\n * in the same direction. so offsets are always positive.\n *\n * we'll leave the old extent in there (for now, at least) to prevent\n * any unintended consequences.\n *\n */\nlet key_generator = 100;\nclass Annotation {\n    /**\n     * constructor takes a property bag (from json, generally). note that\n     * if you are iterating keys on `this`, there has to be an initial value\n     * or the key won't exist.\n     */\n    constructor(opts = {}) {\n        this.key_ = (key_generator++);\n        /** opaque data. this is serialized, so it's persistent data */\n        this.data = {};\n        /** type, for filtering. ensure a value */\n        this.type = '';\n        /** also opaque data, but not serialized. */\n        this.temp = {};\n        /** flag indicating we have inflated this. not serialized */\n        this.inflated = false;\n        /** annotation can be resized. this is advisory, for UI */\n        this.resizable = true;\n        /** annotation can be moved. this is advisory, for UI */\n        this.movable = true;\n        /** annotation can be removed/deleted. this is advisory, for UI */\n        this.removable = true;\n        /** annotation can be selected. this is advisory, for UI */\n        this.selectable = true;\n        /** move when resizing/inserting rows/columns */\n        this.move_with_cells = true;\n        /** resize when resizing/inserting rows/columns */\n        this.resize_with_cells = true;\n        /**\n         * optional formula. the formula will be updated on structure events\n         * (insert/delete row/column).\n         */\n        this.formula = '';\n        for (const key of Object.keys(this)) {\n            if (key !== 'layout' // && key !== 'rect' \n                && opts[key]) { // key !== 'cell_address' && opts[key]) {\n                this[key] = opts[key];\n            }\n        }\n        if (opts.layout) {\n            this.layout = JSON.parse(JSON.stringify(opts.layout));\n        }\n        if (opts.rect) {\n            this.rect = treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Rectangle.Create(opts.rect);\n        }\n    }\n    get key() { return this.key_; }\n    /**\n     * serialization method drops node and trims\n     */\n    toJSON() {\n        const result = {}; // { rect: this.rect };\n        if (this.data)\n            result.data = this.data;\n        if (this.formula)\n            result.formula = this.formula;\n        if (this.type)\n            result.type = this.type;\n        if (!this.resizable)\n            result.resizable = this.resizable;\n        if (!this.movable)\n            result.movable = this.movable;\n        if (!this.removable)\n            result.removable = this.removable;\n        if (!this.selectable)\n            result.selectable = this.selectable;\n        if (!this.move_with_cells)\n            result.move_with_cells = this.move_with_cells;\n        if (!this.resize_with_cells)\n            result.resize_with_cells = this.resize_with_cells;\n        if (this.layout)\n            result.layout = this.layout;\n        if (this.extent)\n            result.extent = this.extent;\n        return result;\n    }\n}\n\n\n//# sourceURL=webpack://treb/./treb-grid/src/types/annotation.ts?");

/***/ }),

/***/ "./treb-grid/src/types/grid_selection.ts":
/*!***********************************************!*\
  !*** ./treb-grid/src/types/grid_selection.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CreateSelection\": () => (/* binding */ CreateSelection),\n/* harmony export */   \"CloneSelection\": () => (/* binding */ CloneSelection)\n/* harmony export */ });\n/* harmony import */ var treb_base_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! treb-base-types */ \"./treb-base-types/src/index.ts\");\n\n/**\n * create an empty selection\n */\nconst CreateSelection = () => {\n    return {\n        target: { row: 0, column: 0 },\n        area: new treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Area({ row: 0, column: 0 }),\n        empty: true,\n    };\n};\nconst CloneSelection = (rhs) => {\n    return JSON.parse(JSON.stringify(rhs));\n};\n\n\n//# sourceURL=webpack://treb/./treb-grid/src/types/grid_selection.ts?");

/***/ }),

/***/ "./treb-grid/src/types/named_range.ts":
/*!********************************************!*\
  !*** ./treb-grid/src/types/named_range.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NamedRangeCollection\": () => (/* binding */ NamedRangeCollection)\n/* harmony export */ });\n/* harmony import */ var treb_base_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! treb-base-types */ \"./treb-base-types/src/index.ts\");\n\nclass NamedRangeCollection {\n    constructor() {\n        this.forward = {};\n        this.backward = [];\n    }\n    /** FIXME: why not an accessor? */\n    Count() {\n        return this.backward.length;\n    }\n    /** FIXME: why not just use toJSON? */\n    Serialize() {\n        return JSON.parse(JSON.stringify(this.Map()));\n    }\n    Deserialize(data) {\n        this.Reset();\n        if (data) {\n            for (const key of Object.keys(data)) {\n                this.SetName(key, new treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Area(data[key].start, data[key].end), false);\n            }\n            this.RebuildList();\n        }\n    }\n    /**\n     * match an area, optionally a target within a larger area (for selections).\n     * we don't use the selection directly, as we may need to adjust target for\n     * merge area.\n     */\n    MatchSelection(area, target) {\n        if (!area.start.sheet_id) {\n            throw new Error('match selection without sheet id');\n        }\n        let label;\n        for (const entry of this.List()) {\n            if (entry.range.start.sheet_id === area.start.sheet_id) {\n                if (entry.range.Equals(area)) {\n                    label = entry.name; // don't break, in case there's a match for target which takes precendence.\n                }\n                if (target === null || target === void 0 ? void 0 : target.Equals(entry.range)) {\n                    return entry.name;\n                }\n            }\n        }\n        return label;\n    }\n    /**\n     * add name. names are case-insensitive. if the name already\n     * exists, it will be overwritten.\n     *\n     * update: returns success (FIXME: proper errors)\n     */\n    SetName(name, range, apply = true) {\n        const validated = this.ValidateNamed(name);\n        if (!validated) {\n            console.warn('invalid name');\n            return false;\n        }\n        if (range.entire_column || range.entire_row) {\n            console.warn('invalid range');\n            return false;\n        }\n        this.forward[validated] = range;\n        if (apply) {\n            this.RebuildList();\n        }\n        return true;\n    }\n    SetNames(list) {\n        for (const key of Object.keys(list)) {\n            const area = list[key];\n            this.SetName(key, new treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Area(area.start, area.end), false);\n        }\n        this.RebuildList();\n    }\n    ClearName(name, apply = true) {\n        delete this.forward[name];\n        if (apply) {\n            this.RebuildList();\n        }\n    }\n    Reset() {\n        this.forward = {};\n        this.backward = [];\n    }\n    Get(name) {\n        return this.forward[name.toUpperCase()];\n    }\n    /** FIXME: accessor */\n    Map() {\n        return this.forward;\n    }\n    /** FIXME: accessor */\n    List() {\n        return this.backward;\n    }\n    /**\n     * named range rules:\n     *\n     * - legal characters are alphanumeric, underscore and dot.\n     * - must start with letter or underscore (not a number or dot).\n     * - cannot look like a spreadsheet address, which is 1-3 letters followed by numbers.\n     *\n     * returns a normalized name (just caps, atm)\n     */\n    ValidateNamed(name) {\n        name = name.trim();\n        if (!name.length)\n            return false;\n        if (/^[A-Za-z]{1,3}\\d+$/.test(name))\n            return false;\n        if (/[^A-Za-z\\d_.]/.test(name))\n            return false;\n        if (/^[^A-Za-z_]/.test(name))\n            return false;\n        return name.toUpperCase();\n    }\n    // was in sheet\n    /**\n     * fix named range references after row/column insert/delete\n     */\n    PatchNamedRanges(before_column, column_count, before_row, row_count) {\n        const copy = this.List().slice(0);\n        for (const entry of copy) {\n            const key = entry.name;\n            const range = entry.range;\n            if (column_count && before_column <= range.end.column) {\n                /*\n                // (1) we are before the insert point, not affected\n        \n                if (before_column > range.end.column) {\n                  continue;\n                }\n                */\n                if (column_count > 0) {\n                    // (2) it's an insert and we are past the insert point:\n                    //     increment [start] and [end] by [count]\n                    if (before_column <= range.start.column) {\n                        range.Shift(0, column_count);\n                    }\n                    // (3) it's an insert and we contain the insert point:\n                    //     increment [end] by [count]\n                    else if (before_column > range.start.column && before_column <= range.end.column) {\n                        range.ConsumeAddress({ row: range.end.row, column: range.end.column + column_count });\n                    }\n                    else {\n                        console.warn(`PNR X case 1`, before_column, column_count, JSON.stringify(range));\n                    }\n                }\n                else if (column_count < 0) {\n                    // (4) it's a delete and we are past the delete point (before+count):\n                    //     decrement [start] and [end] by [count]\n                    if (before_column - column_count <= range.start.column) {\n                        range.Shift(0, column_count);\n                    }\n                    // (5) it's a delete and contains the entire range\n                    else if (before_column <= range.start.column && before_column - column_count > range.end.column) {\n                        this.ClearName(key, false);\n                    }\n                    // (6) it's a delete and contains part of the range. clip the range.\n                    else if (before_column <= range.start.column) {\n                        const last_column = before_column - column_count - 1;\n                        this.SetName(key, new treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Area({\n                            row: range.start.row, column: last_column + 1 + column_count\n                        }, {\n                            row: range.end.row, column: range.end.column + column_count\n                        }), false);\n                    }\n                    else if (before_column <= range.end.column) {\n                        const last_column = before_column - column_count - 1;\n                        if (last_column >= range.end.column) {\n                            this.SetName(key, new treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Area({\n                                row: range.start.row, column: range.start.column\n                            }, {\n                                row: range.end.row, column: before_column - 1\n                            }), false);\n                        }\n                        else {\n                            this.SetName(key, new treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Area({\n                                row: range.start.row, column: range.start.column\n                            }, {\n                                row: range.end.row, column: range.start.column + range.columns + column_count - 1\n                            }), false);\n                        }\n                    }\n                    else {\n                        console.warn(`PNR X case 2`, before_column, column_count, JSON.stringify(range));\n                    }\n                }\n            }\n            if (row_count && before_row <= range.end.row) {\n                /*\n                // (1) we are before the insert point, not affected\n        \n                if (before_row > range.end.row) {\n                  continue;\n                }\n                */\n                if (row_count > 0) {\n                    // (2) it's an insert and we are past the insert point:\n                    //     increment [start] and [end] by [count]\n                    if (before_row <= range.start.row) {\n                        range.Shift(row_count, 0);\n                    }\n                    // (3) it's an insert and we contain the insert point:\n                    //     increment [end] by [count]\n                    else if (before_row > range.start.row && before_row <= range.end.row) {\n                        range.ConsumeAddress({ row: range.end.row + row_count, column: range.end.column });\n                    }\n                    else {\n                        console.warn(`PNR X case 3`, before_row, row_count, JSON.stringify(range));\n                    }\n                }\n                else if (row_count < 0) {\n                    // (4) it's a delete and we are past the delete point (before+count):\n                    //     decrement [start] and [end] by [count]\n                    if (before_row - row_count <= range.start.row) {\n                        range.Shift(row_count, 0);\n                    }\n                    // (5) it's a delete and contains the entire range\n                    else if (before_row <= range.start.row && before_row - row_count > range.end.row) {\n                        this.ClearName(key, false);\n                    }\n                    // (6) it's a delete and contains part of the range. clip the range.\n                    else if (before_row <= range.start.row) {\n                        const last_row = before_row - row_count - 1;\n                        this.SetName(key, new treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Area({\n                            column: range.start.column, row: last_row + 1 + row_count\n                        }, {\n                            column: range.end.column, row: range.end.row + row_count\n                        }), false);\n                    }\n                    else if (before_row <= range.end.row) {\n                        const last_row = before_row - row_count - 1;\n                        if (last_row >= range.end.row) {\n                            this.SetName(key, new treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Area({\n                                column: range.start.column, row: range.start.row\n                            }, {\n                                column: range.end.column, row: before_row - 1\n                            }), false);\n                        }\n                        else {\n                            this.SetName(key, new treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Area({\n                                column: range.start.column, row: range.start.row\n                            }, {\n                                column: range.end.column, row: range.start.row + range.rows + row_count - 1\n                            }), false);\n                        }\n                    }\n                    else {\n                        console.warn(`PNR X case 4`, before_row, row_count, JSON.stringify(range));\n                    }\n                }\n            }\n        }\n        this.RebuildList();\n    }\n    RebuildList() {\n        this.backward = [];\n        for (const key of Object.keys(this.forward)) {\n            this.backward.push({ name: key, range: this.forward[key] });\n        }\n    }\n}\n\n\n//# sourceURL=webpack://treb/./treb-grid/src/types/named_range.ts?");

/***/ }),

/***/ "./treb-grid/src/types/sheet.ts":
/*!**************************************!*\
  !*** ./treb-grid/src/types/sheet.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Sheet\": () => (/* binding */ Sheet)\n/* harmony export */ });\n/* harmony import */ var treb_base_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! treb-base-types */ \"./treb-base-types/src/index.ts\");\n/* harmony import */ var treb_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! treb-format */ \"./treb-format/src/index.ts\");\n/* harmony import */ var treb_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! treb-utils */ \"./treb-utils/src/index.ts\");\n/* harmony import */ var _grid_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./grid_selection */ \"./treb-grid/src/types/grid_selection.ts\");\n/* harmony import */ var _annotation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./annotation */ \"./treb-grid/src/types/annotation.ts\");\n// --- treb imports -----------------------------------------------------------\n\n\n\n\n\n// --- constants --------------------------------------------------------------\nconst DEFAULT_COLUMN_WIDTH = 100;\n// const DEFAULT_ROW_HEIGHT = 26; // not used because it's based on font (theoretically)\nconst DEFAULT_ROW_HEADER_WIDTH = 60;\nclass Sheet {\n    /**\n     * constructor is now protected. use a factory method (Blank or FromJSON).\n     */\n    constructor(theme_style_properties) {\n        /* moved from grid */\n        this.annotations = [];\n        // moved from layout\n        this.freeze = {\n            rows: 0,\n            columns: 0,\n        };\n        /** testing */\n        // public scale = 1.0;\n        this.visible = true;\n        /** standard width (FIXME: static?) */\n        this.default_column_width = 100;\n        /** standard height (FIXME: static?) */\n        this.default_row_height = 25;\n        /** cells data */\n        this.cells = new treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Cells();\n        /**\n         * selection. moved to sheet to preserve selections in multiple sheets.\n         * this instance should just be used to populate the actual selection,\n         * not used as a reference.\n         */\n        this.selection = (0,_grid_selection__WEBPACK_IMPORTED_MODULE_3__.CreateSelection)();\n        /**\n         * cache scroll offset for flipping between sheets. should this be\n         * persisted? (...)\n         */\n        this.scroll_offset = { x: 0, y: 0 };\n        /**\n         * named ranges: name -> area\n         * FIXME: this needs to move to an outer container, otherwise we\n         * may get conflicts w/ multiple sheets. unless we want to allow that...\n         */\n        // public named_ranges = new NamedRangeCollection();\n        this.name = Sheet.default_sheet_name;\n        // tslint:disable-next-line:variable-name\n        this.row_height_ = [];\n        // tslint:disable-next-line:variable-name\n        this.column_width_ = [];\n        /**\n         * optionally, custom row headers (instead of 1...2...3...)\n         * FIXME: should maybe be a function instead?\n         * FIXME: why is this any type? just sloppiness?\n         */\n        this.row_headers = [];\n        /**\n         * optionally, custom column headers (instead of A...B...C...)\n         * FIXME: should maybe be a function instead?\n         * FIXME: why is this any type? just sloppiness?\n         */\n        this.column_headers = [];\n        /** size of header */\n        this.row_header_width = 100;\n        /** size of header */\n        this.column_header_height = 25;\n        // we cache composite styles so we don't wind up with objects\n        // for every cell, when all we need is a single reference.\n        this.style_map = [];\n        // we use json for comparison. it should be faster than the alternative\n        // (even if that doesn't make sense).\n        this.style_json_map = [];\n        // style now uses overlays, but we want to precalculate the\n        // overlaid values. we need to hold on to the originals, in\n        // the event something changes, so we can redo the calculation.\n        // there's a default at the bottom that gets applied to everything.\n        // (in Style). above that, we have the sheet style\n        this.sheet_style = {};\n        // then individual (applied) row and column styles (indexed by row/column)\n        this.row_styles = {};\n        this.column_styles = {};\n        /*\n        we used to have \"alternate row\" styles. it's clumsy, but it is a nice\n        effect. we will add that back via a \"pattern\". not sure how the UI would\n        work for this, but programatically it works.\n      \n        just rows atm, not columns.\n        */\n        this.row_pattern = [];\n        // and finally any cell-specific styles. [FIXME: this is sparse]\n        // [why FIXME? sparse is OK in js]\n        this.cell_style = [];\n        this.default_style_properties = theme_style_properties;\n        // FIXME: the below should be called in a separate 'init' method\n        // that can be called after we change styles (since it will measure)\n        this.default_column_width = DEFAULT_COLUMN_WIDTH;\n        this.row_header_width = DEFAULT_ROW_HEADER_WIDTH;\n        this.UpdateDefaultRowHeight();\n        this.id_ = Sheet.base_id++;\n    }\n    /**\n     * adding verbose flag so we can figure out who is publishing\n     * (and stop -- part of the ExecCommand switchover)\n     */\n    // public static readonly sheet_events = new EventSource<SheetEvent>(true, 'sheet-events');\n    // --- class methods --------------------------------------------------------\n    static Reset() {\n        this.base_id = 100;\n    }\n    /**\n     * factory method creates a new sheet\n     */\n    static Blank(style_defaults, name, rows = 30, columns = 20) {\n        const sheet = new Sheet(style_defaults);\n        if (name) {\n            sheet.name = name;\n        }\n        rows = Math.max(rows, 1);\n        columns = Math.max(columns, 1);\n        sheet.cells.EnsureCell({ row: rows - 1, column: columns - 1 });\n        return sheet;\n    }\n    /**\n     * deserialize json representation. returns new instance or updates\n     * passed instance.\n     *\n     * FIXME: why not make this an instance method, always call on new instance?\n     *\n     * @param hints UpdateHints supports partial deserialization/replacement\n     * if we know there are only minor changes (as part of undo/redo, probably)\n     */\n    static FromJSON(json, style_defaults, sheet) {\n        let obj;\n        if (typeof json === 'string')\n            obj = JSON.parse(json);\n        else\n            obj = json;\n        const unflatten_numeric_array = (target, data) => {\n            Object.keys(data).forEach((key) => {\n                const index = Number(key) || 0;\n                target[index] = data[key];\n            });\n        };\n        if (!sheet) {\n            sheet = new Sheet(style_defaults);\n        }\n        if (obj.default_column_width) {\n            sheet.default_column_width = obj.default_column_width;\n        }\n        if (obj.default_row_height) {\n            sheet.default_row_height = obj.default_row_height;\n        }\n        // persist ID, name\n        if (obj.id) {\n            sheet.id = obj.id;\n        }\n        if (obj.name) {\n            sheet.name = obj.name;\n        }\n        const patch_style = (style) => {\n            // this part is for back compat with older color schemes, it \n            // could theoretically come out if we don't care (or maybe have a tool)\n            const ref = style;\n            if (ref.text_color) {\n                if (ref.text_color !== 'none') {\n                    ref.text = { text: ref.text_color };\n                }\n                ref.text_color = undefined; // will get cleared, eventually\n            }\n            if (ref.background) {\n                if (ref.background !== 'none') {\n                    ref.fill = { text: ref.background };\n                }\n                ref.background = undefined; // ibid\n            }\n            if (ref.border_top_color) {\n                if (ref.border_top_color !== 'none') {\n                    ref.border_top_fill = { text: ref.border_top_color };\n                }\n                ref.border_top_color = undefined;\n            }\n            if (ref.border_left_color) {\n                if (ref.border_left_color !== 'none') {\n                    ref.border_left_fill = { text: ref.border_left_color };\n                }\n                ref.border_left_color = undefined;\n            }\n            if (ref.border_bottom_color) {\n                if (ref.border_bottom_color !== 'none') {\n                    ref.border_bottom_fill = { text: ref.border_bottom_color };\n                }\n                ref.border_bottom_color = undefined;\n            }\n            if (ref.border_right_color) {\n                if (ref.border_right_color !== 'none') {\n                    ref.border_right_fill = { text: ref.border_right_color };\n                }\n                ref.border_right_color = undefined;\n            }\n        };\n        const cell_style_refs = obj.cell_style_refs;\n        for (const entry of cell_style_refs) {\n            patch_style(entry);\n        }\n        // styles (part 1) -- moved up in case we use inlined style refs\n        sheet.cell_style = [];\n        if (cell_style_refs) {\n            (obj.cell_styles || []).forEach((cell_style) => {\n                if (typeof cell_style.ref === 'number') {\n                    cell_style.style =\n                        JSON.parse(JSON.stringify(cell_style_refs[cell_style.ref])); // clone\n                }\n            });\n        }\n        // data: cells (moved after style)\n        sheet.cells.FromJSON(obj.data);\n        if (obj.rows)\n            sheet.cells.EnsureRow(obj.rows - 1);\n        if (obj.columns)\n            sheet.cells.EnsureColumn(obj.columns - 1);\n        // new style stuff\n        // different handling for nested, flat, but we only have to\n        // check once because data is either nested or it isn't.\n        if (obj.data) {\n            if ((0,treb_base_types__WEBPACK_IMPORTED_MODULE_0__.IsFlatDataArray)(obj.data)) {\n                for (const entry of obj.data) {\n                    if (entry.style_ref) {\n                        if (!sheet.cell_style[entry.column])\n                            sheet.cell_style[entry.column] = [];\n                        sheet.cell_style[entry.column][entry.row] = // entry.style;\n                            JSON.parse(JSON.stringify(cell_style_refs[entry.style_ref])); // clone\n                    }\n                }\n            }\n            else {\n                if ((0,treb_base_types__WEBPACK_IMPORTED_MODULE_0__.IsNestedRowArray)(obj.data)) {\n                    for (const block of obj.data) {\n                        const row = block.row;\n                        for (const entry of block.cells) {\n                            const column = entry.column;\n                            if (entry.style_ref) {\n                                if (!sheet.cell_style[column])\n                                    sheet.cell_style[column] = [];\n                                sheet.cell_style[column][row] = // entry.style;\n                                    JSON.parse(JSON.stringify(cell_style_refs[entry.style_ref])); // clone\n                            }\n                        }\n                    }\n                }\n                else {\n                    for (const block of obj.data) {\n                        const column = block.column;\n                        for (const entry of block.cells) {\n                            const row = entry.row;\n                            if (entry.style_ref) {\n                                if (!sheet.cell_style[column])\n                                    sheet.cell_style[column] = [];\n                                sheet.cell_style[column][row] = // entry.style;\n                                    JSON.parse(JSON.stringify(cell_style_refs[entry.style_ref])); // clone\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // freeze\n        sheet.freeze.rows = 0;\n        sheet.freeze.columns = 0;\n        if (obj.freeze) {\n            sheet.freeze.rows = obj.freeze.rows || 0;\n            sheet.freeze.columns = obj.freeze.columns || 0;\n        }\n        // scroll, optionally\n        sheet.scroll_offset = obj.scroll ? Object.assign({}, obj.scroll) : { x: 0, y: 0 };\n        // wrap up styles\n        for (const cell_style of (obj.cell_styles || [])) {\n            if (cell_style.style) {\n                if (!sheet.cell_style[cell_style.column])\n                    sheet.cell_style[cell_style.column] = [];\n                sheet.cell_style[cell_style.column][cell_style.row] = cell_style.style;\n            }\n        }\n        sheet.sheet_style = obj.sheet_style || {};\n        sheet.row_styles = obj.row_style;\n        sheet.column_styles = obj.column_style;\n        sheet.row_pattern = obj.row_pattern || [];\n        // patch other styles\n        patch_style(sheet.sheet_style || {});\n        for (const entry of sheet.row_pattern) {\n            patch_style(entry);\n        }\n        for (const key of Object.keys(sheet.column_styles)) {\n            patch_style(sheet.column_styles[key]);\n        }\n        for (const key of Object.keys(sheet.row_styles)) {\n            patch_style(sheet.row_styles[key]);\n        }\n        // ok\n        // if (hints && !hints.data) sheet.FlushCellStyles();\n        // sheet.default_row_height = obj.default_row_height;\n        // sheet.default_column_width = obj.default_column_width;\n        sheet.row_height_ = [];\n        unflatten_numeric_array(sheet.row_height_, obj.row_height || {}); // sheet.default_row_height);\n        // obj.default_row_height);\n        if (sheet.row_height_.length) {\n            sheet.cells.EnsureRow(sheet.row_height_.length - 1);\n        }\n        sheet.column_width_ = [];\n        unflatten_numeric_array(sheet.column_width_, obj.column_width || {}); // sheet.default_column_width);\n        // obj.default_column_width);\n        if (sheet.column_width_.length) {\n            sheet.cells.EnsureColumn(sheet.column_width_.length - 1);\n        }\n        // NOTE: we're padding out rows/columns here to be under annotations,\n        // otherwise the pruning may have removed them. it would probably be\n        // preferable to not prune them... that shouldn't add much extra data\n        // because it would just be the number.\n        // FIXME\n        sheet.annotations = (obj.annotations || []).map((entry) => new _annotation__WEBPACK_IMPORTED_MODULE_4__.Annotation(entry));\n        if (obj.selection) {\n            // copy to ensure there's no link to random object\n            sheet.selection = JSON.parse(JSON.stringify(obj.selection));\n        }\n        sheet.visible = true; // default\n        if (typeof obj.visible !== 'undefined') {\n            sheet.visible = !!obj.visible;\n        }\n        return sheet;\n    }\n    // --- accessors ------------------------------------------------------------\n    // public get column_header_count() { return this.column_header_count_; }\n    get header_offset() {\n        return { x: this.row_header_width, y: this.column_header_height };\n    }\n    /** accessor: now just a wrapper for the call on cells */\n    get rows() { return this.cells.rows; }\n    /** accessor: now just a wrapper for the call on cells */\n    get columns() { return this.cells.columns; }\n    get id() { return this.id_; }\n    set id(id) {\n        this.id_ = id;\n        if (this.id >= Sheet.base_id) {\n            Sheet.base_id = this.id + 1;\n        }\n    }\n    // --- public methods -------------------------------------------------------\n    MergeCells(area) {\n        // FIXME: it's an error if this area includes some\n        // (but not all) of another merge area.\n        // ...\n        // assuming we're good to go...\n        area = area.Clone();\n        this.cells.Apply(area, (cell, c, r) => {\n            cell.merge_area = area;\n            cell.render_dirty = true;\n            // clear data in !head\n            if (c !== area.start.column || r !== area.start.row)\n                cell.Reset();\n        }, true);\n    }\n    UnmergeCells(area) {\n        // this _must_ be the full merge area. to get it, just get\n        // the merge property from a particular cell or cells.\n        // let's check:\n        let match = true;\n        this.cells.Apply(area, (cell) => {\n            match = match && !!cell.merge_area && area.Equals(cell.merge_area);\n        }, false);\n        if (!match) {\n            console.warn('area mismatch');\n            return;\n        }\n        this.cells.Apply(area, (cell) => {\n            cell.merge_area = undefined;\n            cell.render_dirty = true;\n        }, false);\n    }\n    /**\n     * FIXME: measure the font.\n     */\n    StyleFontSize(style, default_properties = {}) {\n        let font_height = (style.font_size_value || 0);\n        let scale = 0;\n        switch (style.font_size_unit) {\n            case 'px':\n                font_height *= (75 / 100);\n                break;\n            case 'em':\n                scale = style.font_size_value || 1;\n                break;\n            case '%':\n                scale = (style.font_size_value || 100) / 100;\n                break;\n        }\n        if (scale) {\n            font_height = scale * (default_properties.font_size_value || 10);\n            if (default_properties.font_size_unit === 'px') {\n                font_height *= (75 / 100);\n            }\n        }\n        return font_height || 10;\n    }\n    /**\n     * FIXME: this is called in the ctor, which made sense when sheets\n     * were more ephemeral. now that we update a single instance, rather\n     * than create new instances, we lose this behavior. we should call\n     * this when we change sheet style.\n     *\n     * removing parameter, event\n     */\n    UpdateDefaultRowHeight() {\n        const composite = treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Style.Composite([this.default_style_properties, this.sheet_style]);\n        if (typeof window !== 'undefined') {\n            const measurement = treb_utils__WEBPACK_IMPORTED_MODULE_2__.Measurement.MeasureText(treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Style.Font(composite), 'M');\n            const height = Math.round(measurement.height * 1.4);\n            if (this.default_row_height < height) {\n                this.default_row_height = height;\n            }\n        }\n        /*\n        else {\n          // console.info('worker?');\n        }\n        */\n    }\n    /**\n     * deprecated (or give me a reason to keep it)\n     * KEEP IT: just maintain flexibility, it has very low cost\n     */\n    SetRowHeaders(headers) {\n        this.row_headers = headers.map(value => value === undefined ? '' : value.toString());\n        if (this.row_headers) {\n            this.cells.EnsureRow(this.row_headers.length - 1);\n        }\n    }\n    /**\n     * deprecated (or give me a reason to keep it)\n     * KEEP IT: just maintain flexibility, it has very low cost\n     */\n    SetColumnHeaders(headers) {\n        this.column_headers = headers.map(value => value === undefined ? '' : value.toString());\n        if (headers) {\n            this.cells.EnsureColumn(headers.length - 1);\n        }\n    }\n    /**\n     * deprecated\n     * KEEP IT: just maintain flexibility, it has very low cost\n     */\n    RowHeader(row) {\n        if (this.row_headers) {\n            if (this.row_headers.length > row)\n                return this.row_headers[row];\n            return '';\n        }\n        return row + 1;\n    }\n    /**\n     * deprecated\n     * KEEP IT: just maintain flexibility, it has very low cost\n     * (we did drop the multiple rows, though)\n     */\n    ColumnHeader(column) {\n        let s = '';\n        if (this.column_headers) {\n            if (this.column_headers.length > column)\n                return this.column_headers[column];\n            return '';\n        }\n        for (;;) {\n            const c = column % 26;\n            s = String.fromCharCode(65 + c) + s;\n            column = Math.floor(column / 26);\n            if (column)\n                column--;\n            else\n                break;\n        }\n        return s;\n    }\n    GetRowHeight(row) {\n        const height = this.row_height_[row];\n        if (typeof height === 'undefined')\n            return this.default_row_height;\n        return height;\n    }\n    SetRowHeight(row, height) {\n        this.row_height_[row] = height;\n        this.cells.EnsureRow(row);\n        return height;\n    }\n    GetColumnWidth(column) {\n        const width = this.column_width_[column];\n        if (typeof width === 'undefined')\n            return this.default_column_width;\n        return width;\n    }\n    SetColumnWidth(column, width) {\n        this.column_width_[column] = width;\n        this.cells.EnsureColumn(column);\n        return width;\n    }\n    /**\n     * returns set of properties in B that differ from A. returns\n     * property values from B.\n     *\n     * this is the function I could never get to work inline for\n     * Style.Properties -- not sure why it works better with a generic\n     * function (although the partial here is new, so maybe it's that?)\n     *\n     * seems to be related to\n     * https://github.com/microsoft/TypeScript/pull/30769\n     *\n     */\n    Delta(A, B) {\n        const result = {};\n        // keys that are in either object. this will result in some\n        // duplication, probably not too bad. could precompute array? (...)\n        // you could do that using a composite object, but would be wasteful.\n        // would look good in typescript but generate extra javascript. might\n        // still be faster, though? (...)\n        const keys = [...Object.keys(A), ...Object.keys(B)];\n        // FIXME: should check if B[key] is undefined, in which case you don't\n        // want it? (...) that seems appropriate, but since the method we are\n        // replacing did not do that, I'm hesitant to do it now\n        for (const key of keys) {\n            const a = A[key];\n            const b = B[key];\n            // we are not checking for arrays, that's not a consideration atm\n            if (typeof a === 'object' && typeof b === 'object') {\n                // is this faster than checking properties? \n                // especially if we know the list?\n                if (JSON.stringify(a) !== JSON.stringify(b)) {\n                    result[key] = b;\n                }\n            }\n            else if (a !== b) {\n                result[key] = b;\n            }\n            //if (A[key] !== B[key]) {\n            //  result[key] = B[key];\n            //}\n        }\n        return result;\n    }\n    /**\n     * updates cell styles. flushes cached style.\n     *\n     * @param delta merge with existing properties (we will win conflicts)\n     * @param inline this is part of another operation, don't do any undo/state updates\n     */\n    UpdateCellStyle(address, properties, delta = true) {\n        // so what this is doing is constructing two merge stacks: one including\n        // the cell style, and one without. any deltas among the two are the cell\n        // style. the aim here is to remove properties that would be duplicative\n        // because they stack, so if the base sheet has color=red, there is no\n        // reason to apply that to the cell as well.\n        const { row, column } = address;\n        if (!this.cell_style[column])\n            this.cell_style[column] = [];\n        // testing\n        // const underlying = this.CompositeStyleForCell(address, false);\n        const underlying = this.CompositeStyleForCell(address, false, false);\n        const merged = treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Style.Composite([\n            this.default_style_properties,\n            underlying,\n            treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Style.Merge(this.cell_style[column][row] || {}, properties, delta),\n        ]);\n        const composite = this.Delta(underlying, merged);\n        /*\n        // this is type \"any\" because of the assignment, below, which fails\n        // otherwise. however this could be done with spread assignments? (...)\n        // A: no, it's not merging them, it is looking for deltas.\n        // ...but, what if you filtered? (...) [A] how?\n    \n        // I think the only way to do it with types would be to use delete, which\n        // somehow seems wasteful and slow (although I have not validated that)\n    \n        const composite: any = {};\n    \n        // find properties that are different, those will be the cell style.\n    \n        for (const key of Object.keys(merged) as Style.PropertyKeys[]) {\n          if (merged[key] !== underlying[key]) {\n            composite[key] = merged[key];\n          }\n        }\n        for (const key of Object.keys(underlying) as Style.PropertyKeys[]) {\n          if (merged[key] !== underlying[key]) {\n            composite[key] = merged[key];\n          }\n        }\n        */\n        this.cell_style[column][row] = composite; // merged;\n        // targeted flush\n        this.CellData(address).FlushStyle();\n    }\n    /**\n     * invalidate sets the \"render dirty\" flag on cells, whether there\n     * is any change or not. we are currently using it to force rendering\n     * when border/background changes, and we need to handle bleed into\n     * neighboring cells.\n     */\n    Invalidate(area) {\n        this.cells.Apply(this.RealArea(area), cell => cell.render_dirty = true);\n    }\n    /**\n     *\n     * @param area\n     * @param style\n     * @param delta\n     * @param render LEGACY PARAMETER NOT USED\n     */\n    UpdateAreaStyle(area, style = {}, delta = true) {\n        if (!area)\n            return;\n        if (area.entire_sheet) {\n            this.UpdateSheetStyle(style, delta);\n        }\n        else if (area.entire_column) {\n            for (let column = area.start.column; column <= area.end.column; column++) {\n                this.UpdateColumnStyle(column, style, delta);\n            }\n        }\n        else if (area.entire_row) {\n            for (let row = area.start.row; row <= area.end.row; row++) {\n                this.UpdateRowStyle(row, style, delta);\n            }\n        }\n        else\n            area.Array().forEach((address) => this.UpdateCellStyle(address, style, delta));\n    }\n    /**\n     * checks if the given cell has been assigned a specific style, either for\n     * the cell itself, or for row and column.\n     */\n    HasCellStyle(address) {\n        return !!((this.cell_style[address.column] && this.cell_style[address.column][address.row])\n            || this.row_styles[address.row]\n            || this.column_styles[address.column]\n            || this.row_pattern.length);\n    }\n    /**\n     * returns the next non-hidden column. so if you are column C (2) and columns\n     * D, E, and F are hidden, then it will return 6 (G).\n     */\n    NextVisibleColumn(column) {\n        for (++column; this.column_width_[column] === 0; column++) { /* */ }\n        return column;\n    }\n    /**\n     * @see NextVisibleColumn\n     * because this one goes left, it may return -1 meaning you are at the left edge\n     */\n    PreviousVisibleColumn(column) {\n        for (--column; column >= 0 && this.column_width_[column] === 0; column--) { /* */ }\n        return column;\n    }\n    /**\n     * @see NextVisibleColumn\n     */\n    NextVisibleRow(row) {\n        for (++row; this.row_height_[row] === 0; row++) { /* */ }\n        return row;\n    }\n    /**\n     * @see PreviousVisibleColumn\n     */\n    PreviousVisibleRow(row) {\n        for (--row; row >= 0 && this.row_height_[row] === 0; row--) { /* */ }\n        return row;\n    }\n    /**\n     * returns style properties for cells surrounding this cell,\n     * mapped like a number pad:\n     *\n     * +---+---+---+\n     * | 7 | 8 | 9 |\n     * +---+---+---+\n     * | 4 | X | 6 |\n     * +---+---+---+\n     * | 1 | 2 | 3 |\n     * +---+---+---+\n     *\n     * presuming you already have X (5). this is called by renderer, we\n     * move it here so we can inline the next/previous loops.\n     *\n     */\n    SurroundingStyle(address) {\n        const map = [{}, {}, {}, {}, {}, {}, {}, {}, {}, {}];\n        // FIXME: what about merges? (...)\n        let column_right = address.column + 1;\n        let column_left = address.column - 1;\n        let row_below = address.row + 1;\n        let row_above = address.row - 1;\n        for (; this.column_width_[column_right] === 0; column_right++) { /* */ }\n        for (; this.row_height_[row_below] === 0; row_below++) { /* */ }\n        for (; column_left >= 0 && this.column_width_[column_left] === 0; column_left--) { /* */ }\n        for (; row_above >= 0 && this.row_height_[row_above] === 0; row_above--) { /* */ }\n        if (column_left >= 0 && row_above >= 0) {\n            map[7] = this.CellStyleData({ row: row_above, column: column_left }) || {};\n        }\n        if (column_left >= 0) {\n            map[4] = this.CellStyleData({ row: address.row, column: column_left }) || {};\n            map[1] = this.CellStyleData({ row: row_below, column: column_left }) || {};\n        }\n        if (row_above >= 0) {\n            map[8] = this.CellStyleData({ row: row_above, column: address.column }) || {};\n            map[9] = this.CellStyleData({ row: row_above, column: column_right }) || {};\n        }\n        map[6] = this.CellStyleData({ row: address.row, column: column_right }) || {};\n        map[2] = this.CellStyleData({ row: row_below, column: address.column }) || {};\n        map[3] = this.CellStyleData({ row: row_below, column: column_right }) || {};\n        return map;\n    }\n    /**\n     * get style only. as noted in the comment to `CellData` there used to be\n     * no case where this was useful without calculated value as well; but we\n     * now have a case: fixing borders by checking neighboring cells. (testing).\n     *\n     * switching from null to undefined as \"missing\" type\n     */\n    CellStyleData(address) {\n        // don't create if it doesn't exist\n        const cell = this.cells.GetCell(address);\n        if (!cell) {\n            return undefined;\n        }\n        // composite style if necessary\n        if (!cell.style) {\n            const index = this.GetStyleIndex(this.CompositeStyleForCell(address));\n            cell.style = this.style_map[index];\n        }\n        return cell.style;\n    }\n    /**\n     * accessor to get cell style without row pattern -- for cut/copy\n     * @param address\n     */\n    GetCopyStyle(address) {\n        return this.CompositeStyleForCell(address, true, false);\n    }\n    /**\n     * wrapper for getting all relevant render data.\n     * TODO: merge in \"FormattedValue\". restructure data so we don't have\n     * two caches (formatted and calculated).\n     *\n     * NOTE: we removed \"GetCellStyle\" in favor of this function. the rationale\n     * is that there are no reasonable cases where someone looks up the style\n     * without that being a next step to (or in reasonable proximity to)\n     * rendering. so it's reasonable to call this function even if it's in\n     * advance of rendering.\n     *\n     * NOTE: that applies to the \"GetCellFormula\" and \"GetCellValue\" functions\n     * as well -- so remove those too.\n     *\n     * NOTE: actually GetCellFormula resolves array formulae, so maybe not --\n     * or the caller needs to check.\n     *\n     */\n    CellData(address) {\n        const cell = this.cells.EnsureCell(address);\n        // if cell has rendered type (i.e. not undefined), then it has\n        // complete render data and we can return it as-is.\n        if (cell.rendered_type)\n            return cell;\n        // otherwise we need to render it. if we have a calculated value, use that.\n        let type;\n        let value;\n        if (cell.calculated_type) {\n            value = cell.calculated;\n            type = cell.calculated_type;\n        }\n        else {\n            value = cell.value;\n            type = cell.type;\n        }\n        // do we have style for this cell? if not, we need to composite it.\n        if (!cell.style) {\n            const index = this.GetStyleIndex(this.CompositeStyleForCell(address));\n            cell.style = this.style_map[index];\n        }\n        // why is this done here? shouldn't it be done by/in the renderer?\n        if (!type || value === null || typeof value === 'undefined') {\n            cell.formatted = '';\n            cell.rendered_type = treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.string;\n        }\n        else if (type === treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number) {\n            // IE11. not sure of the effect of this.\n            if (isNaN(value)) {\n                cell.formatted = // Style.Format(cell.style, value); // formats NaN\n                    (typeof cell.style.nan === 'undefined') ? 'NaN' : cell.style.nan;\n            }\n            else {\n                cell.formatted = // Style.Format(cell.style, value);\n                    this.FormatNumber(value, cell.style.number_format);\n            }\n            cell.rendered_type = treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number;\n        }\n        else if (type === treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.error) {\n            cell.formatted = '#' + (value || 'ERR?');\n            cell.rendered_type = treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.error;\n        }\n        else if (type === treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.boolean) {\n            cell.formatted = value.toString().toUpperCase(); // implicit locale?\n            cell.rendered_type = treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.boolean;\n        }\n        else if (type === treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.formula && cell.calculated === undefined) {\n            cell.formatted = '';\n            cell.rendered_type = treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.string;\n        }\n        else {\n            // why is this being treated as a number? (...)\n            // A: it's not, number format has a text section. defaults\n            //    to @ (just show the text), but could be different\n            cell.formatted = this.FormatNumber(value, cell.style.number_format);\n            cell.rendered_type = treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.string;\n        }\n        // now we can return it\n        return cell;\n    }\n    /**\n     * format number using passed format; gets the actual format object\n     * and calls method. returns a string or array of text parts\n     * (@see treb-format).\n     */\n    FormatNumber(value, format = '') {\n        const formatted = treb_format__WEBPACK_IMPORTED_MODULE_1__.NumberFormatCache.Get(format).FormatParts(value);\n        if (!formatted.length)\n            return '';\n        if (formatted.length === 1 && !formatted[0].flag) {\n            return formatted[0].text || '';\n        }\n        return formatted;\n    }\n    // no references... removing\n    //public ColumnHeaderHeight(): number {\n    //  return this.column_header_height || this.default_row_height_x;\n    //}\n    /**\n     * the only place this is called is in a method that shows/hides headers;\n     * it sets the size either to 1 (hidden) or undefined, which uses the\n     * defaults here. that suggests we should have a show/hide method instead.\n     *\n     * @param row_header_width\n     * @param column_header_height\n     */\n    SetHeaderSize(row_header_width = DEFAULT_ROW_HEADER_WIDTH, column_header_height = this.default_row_height) {\n        this.row_header_width = row_header_width;\n        this.column_header_height = column_header_height;\n    }\n    /**\n     * resize row to match character hight, taking into\n     * account multi-line values.\n     *\n     * UPDATE: since the only caller calls with inline = true, removing\n     * parameter, test, and extra behavior.\n     */\n    AutoSizeRow(row, default_properties = {}) {\n        let height = this.default_row_height;\n        const padding = 9;\n        for (let column = 0; column < this.cells.columns; column++) {\n            const cell = this.CellData({ row, column });\n            const style = cell.style;\n            let text = cell.formatted || '';\n            if (typeof text !== 'string') {\n                text = text.map((part) => part.text).join('');\n            }\n            if (style && text && text.length) {\n                const lines = text.split(/\\n/);\n                const font_height = this.StyleFontSize(style, default_properties);\n                height = Math.max(height, ((font_height || 10) + padding) * lines.length);\n            }\n        }\n        this.SetRowHeight(row, height);\n    }\n    /**\n     * auto-sizes the column, but if the allow_shrink parameter is not set\n     * it will only enlarge, never shrink the column.\n     *\n     * UPDATE: since the only caller calls with inline = true, removing\n     * parameter, test, and extra behavior.\n     */\n    AutoSizeColumn(column, allow_shrink = true) {\n        if (!Sheet.measurement_canvas)\n            Sheet.measurement_canvas = document.createElement('canvas');\n        const context = Sheet.measurement_canvas.getContext('2d');\n        if (!context)\n            return;\n        let width = 12;\n        const padding = 4 * 2; // FIXME: parameterize\n        if (!allow_shrink)\n            width = this.GetColumnWidth(column);\n        for (let row = 0; row < this.cells.rows; row++) {\n            const cell = this.CellData({ row, column });\n            let text = cell.formatted || '';\n            if (typeof text !== 'string') {\n                text = text.map((part) => part.text).join('');\n            }\n            if (text && text.length) {\n                context.font = treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Style.Font(cell.style || {});\n                width = Math.max(width, Math.ceil(context.measureText(text).width) + padding);\n            }\n        }\n        this.SetColumnWidth(column, width);\n    }\n    /** returns the style properties for a given style index */\n    GetStyle(index) {\n        return this.style_map[index];\n    }\n    /* *\n     * if the cell is in an array, returns the array as an Area.\n     * if not, returns falsy (null or undefined).\n     *\n     * FIXME: is this used? seems like the caller could do this\n     * calculation.\n     *\n     * Answer was no, so removed\n     * /\n    public ContainingArray(address: ICellAddress): Area | undefined {\n      const cell = this.cells.GetCell(address);\n      if (cell) return cell.area;\n      return undefined;\n    }\n    */\n    /**\n     *\n     * @param before_row insert before\n     * @param count number to insert\n     */\n    InsertRows(before_row = 0, count = 1) {\n        // this needs to be shared between sheet/cells and the\n        // outside spreadsheet logic. we should not be fixing references,\n        // for example, because we don't have the graph.\n        // we should definitely fix merge heads. also array heads.\n        // also: you cannot insert rows that would break arrays.\n        // if the new row(s) are inside of a merged cell, that cell\n        // consumes the new row(s).\n        // validate we won't break arrays. a new row would break an\n        // array if before_row is in an array and (before_row-1) is\n        // in the same array.\n        if (before_row) {\n            for (let column = 0; column < this.cells.columns; column++) {\n                const cell1 = this.cells.GetCell({ row: before_row - 1, column }, false);\n                if (cell1 && cell1.area) {\n                    const cell2 = this.cells.GetCell({ row: before_row, column }, false);\n                    if (cell2 && cell2.area && cell2.area.Equals(cell1.area)) {\n                        return false; // failed\n                    }\n                }\n            }\n        }\n        // this.named_ranges.PatchNamedRanges(0, 0, before_row, count);\n        // ok we can insert...\n        if (count < 0) {\n            this.cells.DeleteRows(before_row, -count);\n        }\n        else {\n            this.cells.InsertRows(before_row, count);\n        }\n        // now we have to fix arrays and merge heads. these lists will keep\n        // track of the _new_ starting address.\n        const merge_heads = {};\n        const array_heads = {};\n        // now grab arrays and merge heads that are below the new rows\n        // this should include merges that span the new range\n        for (let row = before_row; row < this.cells.rows; row++) {\n            for (let column = 0; column < this.cells.columns; column++) {\n                const cell = this.cells.GetCell({ row, column }, false);\n                if (cell) {\n                    if (cell.area && !array_heads[cell.area.spreadsheet_label]) {\n                        array_heads[cell.area.spreadsheet_label] = cell.area;\n                    }\n                    if (cell.merge_area && !merge_heads[cell.merge_area.spreadsheet_label]) {\n                        merge_heads[cell.merge_area.spreadsheet_label] = cell.merge_area;\n                    }\n                }\n            }\n        }\n        // console.info(\"IR arrays\", array_heads);\n        // console.info(\"IR merges\", merge_heads);\n        for (const key of Object.keys(array_heads)) {\n            const head = array_heads[key];\n            const patched = new treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Area({ row: head.start.row + count, column: head.start.column }, { row: head.end.row + count, column: head.end.column });\n            patched.Iterate((address) => {\n                const cell = this.cells.GetCell(address, true);\n                cell.area = patched;\n            });\n        }\n        for (const key of Object.keys(merge_heads)) {\n            const head = merge_heads[key];\n            const patched_start = { row: head.start.row, column: head.start.column };\n            if (head.start.row >= before_row)\n                patched_start.row += count;\n            const patched = new treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Area(patched_start, { row: head.end.row + count, column: head.end.column });\n            patched.Iterate((address) => {\n                const cell = this.cells.GetCell(address, true);\n                cell.merge_area = patched;\n            });\n        }\n        // row styles\n        const row_keys = Object.keys(this.row_styles);\n        const new_row_style = {};\n        row_keys.forEach((key) => {\n            const index = Number(key);\n            if (index < before_row)\n                new_row_style[index] = this.row_styles[index];\n            else if (count < 0 && index < before_row - count) { /* ? */ }\n            else\n                new_row_style[index + count] = this.row_styles[index];\n        });\n        this.row_styles = new_row_style;\n        // cell styles\n        let args = [];\n        if (count < 0) {\n            args = [before_row, -count];\n        }\n        else {\n            args = [before_row, 0];\n            for (let i = 0; i < count; i++)\n                args.push(undefined);\n        }\n        // console.info('m5.1');\n        this.cell_style.forEach((column) => {\n            if (column && column.length >= before_row) {\n                // eslint-disable-next-line prefer-spread\n                column.splice.apply(column, args);\n            }\n        });\n        // console.info('m6');\n        // row heights\n        // eslint-disable-next-line prefer-spread\n        this.row_height_.splice.apply(this.row_height_, args);\n        // invalidate style cache\n        this.FlushCellStyles();\n        // console.info('m7');\n        return true;\n    }\n    /**\n     * see InsertRow for details\n     */\n    InsertColumns(before_column = 0, count = 1) {\n        // check for array breaks\n        if (before_column) {\n            for (let row = 0; row < this.cells.rows; row++) {\n                const cell1 = this.cells.GetCell({ row, column: before_column - 1 }, false);\n                if (cell1 && cell1.area) {\n                    const cell2 = this.cells.GetCell({ row, column: before_column }, false);\n                    if (cell2 && cell2.area && cell2.area.Equals(cell1.area))\n                        return false; // failed\n                }\n            }\n        }\n        // this.named_ranges.PatchNamedRanges(before_column, count, 0, 0);\n        // ok we can insert...\n        if (count < 0) {\n            this.cells.DeleteColumns(before_column, -count);\n        }\n        else {\n            this.cells.InsertColumns(before_column, count);\n        }\n        // now we have to fix arrays and merge heads. these lists will keep\n        // track of the _new_ starting address.\n        const merge_heads = {};\n        const array_heads = {};\n        // now grab arrays and merge heads that are below the new rows\n        // this should include merges that span the new range\n        for (let column = before_column; column < this.cells.columns; column++) {\n            for (let row = 0; row < this.cells.rows; row++) {\n                const cell = this.cells.GetCell({ row, column }, false);\n                if (cell) {\n                    if (cell.area && !array_heads[cell.area.spreadsheet_label]) {\n                        array_heads[cell.area.spreadsheet_label] = cell.area;\n                    }\n                    if (cell.merge_area && !merge_heads[cell.merge_area.spreadsheet_label]) {\n                        merge_heads[cell.merge_area.spreadsheet_label] = cell.merge_area;\n                    }\n                }\n            }\n        }\n        for (const key of Object.keys(array_heads)) {\n            const head = array_heads[key];\n            const patched = new treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Area({ row: head.start.row, column: head.start.column + count }, { row: head.end.row, column: head.end.column + count });\n            patched.Iterate((address) => {\n                const cell = this.cells.GetCell(address, true);\n                cell.area = patched;\n            });\n        }\n        for (const key of Object.keys(merge_heads)) {\n            const head = merge_heads[key];\n            const patched_start = { row: head.start.row, column: head.start.column };\n            if (head.start.column >= before_column)\n                patched_start.column += count;\n            const patched = new treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Area(patched_start, { row: head.end.row, column: head.end.column + count });\n            patched.Iterate((address) => {\n                const cell = this.cells.GetCell(address, true);\n                cell.merge_area = patched;\n            });\n        }\n        // column styles\n        const column_keys = Object.keys(this.column_styles);\n        const new_column_style = {};\n        column_keys.forEach((key) => {\n            const index = Number(key);\n            if (index < before_column)\n                new_column_style[index] = this.column_styles[index];\n            else if (count < 0 && index < before_column - count) { /* ? */ }\n            else\n                new_column_style[index + count] = this.column_styles[index];\n        });\n        this.column_styles = new_column_style;\n        // cell styles\n        let args = [];\n        if (count < 0) {\n            args = [before_column, -count];\n        }\n        else {\n            args = [before_column, 0];\n            for (let i = 0; i < count; i++)\n                args.push(undefined);\n        }\n        // eslint-disable-next-line prefer-spread\n        this.cell_style.splice.apply(this.cell_style, args);\n        // row heights\n        // eslint-disable-next-line prefer-spread\n        this.column_width_.splice.apply(this.column_width_, args);\n        // invalidate style cache\n        this.FlushCellStyles();\n        return true;\n    }\n    /** clear cells in area */\n    ClearArea(area) {\n        // this is not allowed if any of the cells are in\n        // an array, and the array does not match the passed\n        // array.\n        // ...\n        // assuming it's ok, :\n        area = this.RealArea(area);\n        this.cells.Apply(area, (cell) => cell.Reset());\n    }\n    // ATM we have 4 methods to set value/values. we need a distinction for\n    // arrays, but that could be a parameter. the single-value/multi-value\n    // area functions could probably be consolidated, also the single-cell-\n    // single-value function... you need logic either on the outside or the\n    // inside, put that logic where it makes the most sense.\n    // also some of this could be moved to the Cells class... if for no\n    // other reason than to remove the iteration overhead\n    SetAreaValues2(area, values) {\n        // we don't want to limit this to the existing area, we only\n        // want to remove infinities (if set). it's possible to expand\n        // the grid here (maybe -- check option?)\n        // actually, realarea already does exactly that -- which is not\n        // what I thought. we may need a new, different method to clip.\n        area = this.RealArea(area);\n        this.cells.SetArea(area, values);\n    }\n    /**\n     * set the area as an array formula, based in the top-left cell\n     */\n    SetArrayValue(area, value) {\n        area = this.RealArea(area);\n        this.cells.Apply(area, (element) => element.SetArray(area), true);\n        const cell = this.cells.GetCell(area.start, true);\n        cell.SetArrayHead(area, value);\n    }\n    /**\n     * set a single value in a single cell\n     */\n    SetCellValue(address, value) {\n        const cell = this.cells.GetCell(address, true);\n        cell.Set(value);\n    }\n    /**\n     * returns the area bounding actual content\n     * (i.e. flattening \"entire row/column/sheet\")\n     *\n     * FIXME: this does not clamp to actual cells... why not?\n     * FIXME: so now we are (optionally) clamping end; should clamp start, too\n     *\n     * @param clamp -- new parameter will optionally clamp to actual sheet size\n     */\n    RealArea(area, clamp = false) {\n        const start = area.start; // this is a copy\n        const end = area.end; // ditto\n        if (area.entire_row) {\n            start.column = 0;\n            start.absolute_column = false;\n            end.column = this.cells.columns - 1;\n            end.absolute_column = false;\n        }\n        if (area.entire_column) {\n            start.row = 0;\n            start.absolute_row = false;\n            end.row = this.cells.rows - 1;\n            end.absolute_row = false;\n        }\n        if (clamp) {\n            if (end.row >= this.rows) {\n                end.row = this.rows - 1;\n                end.absolute_row = false;\n            }\n            if (end.column >= this.columns) {\n                end.column = this.columns - 1;\n                end.absolute_column = false;\n            }\n        }\n        return new treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Area(start, end);\n    }\n    ///\n    FormattedCellValue(address) {\n        const cell = this.CellData(address);\n        if (!cell) {\n            return undefined;\n        }\n        if (typeof cell.formatted === 'string')\n            return cell.formatted;\n        if (cell.formatted) {\n            return cell.formatted.map(part => {\n                switch (part.flag) {\n                    case 1:\n                        return ' ';\n                    case 2:\n                        return ' '; // ??\n                    default:\n                        return part.text;\n                }\n            }).join('');\n        }\n        return cell.value;\n    }\n    GetFormattedRange(from, to = from) {\n        if (from.row === to.row && from.column === to.column) {\n            return this.FormattedCellValue(from);\n        }\n        const result = [];\n        // grab rows\n        for (let row = from.row; row <= to.row; row++) {\n            const target = [];\n            for (let column = from.column; column <= to.column; column++) {\n                target.push(this.FormattedCellValue({ row, column }));\n            }\n            result.push(target);\n        }\n        return result;\n    }\n    /**\n     * get all styles used in the sheet. this is used to populate color\n     * and number format lists in the toolbar. we used to just serialize\n     * the document and use that, but that's absurdly wasteful. for this\n     * application we don't even need composites.\n     *\n     * although, this is a bit dangerous because you could (in theory)\n     * modify the results in place. so maybe we should either duplicate or\n     * just return the requested data...\n     */\n    NumberFormatsAndColors(color_map, number_format_map) {\n        const parse = (style) => {\n            var _a, _b, _c, _d, _e, _f;\n            if (style.number_format) {\n                number_format_map[style.number_format] = 1;\n            }\n            if (((_a = style.text) === null || _a === void 0 ? void 0 : _a.text) && style.text.text !== 'none') {\n                // const color = Measurement.MeasureColorARGB(style.text_color);\n                color_map[style.text.text] = 1;\n            }\n            if ((_b = style.fill) === null || _b === void 0 ? void 0 : _b.text) {\n                color_map[style.fill.text] = 1;\n            }\n            //if (style.background && style.background !== 'none') {\n            //  color_map[style.background] = 1;\n            //}\n            if ((_c = style.border_top_fill) === null || _c === void 0 ? void 0 : _c.text) {\n                color_map[style.border_top_fill.text] = 1;\n            }\n            if ((_d = style.border_left_fill) === null || _d === void 0 ? void 0 : _d.text) {\n                color_map[style.border_left_fill.text] = 1;\n            }\n            if ((_e = style.border_right_fill) === null || _e === void 0 ? void 0 : _e.text) {\n                color_map[style.border_right_fill.text] = 1;\n            }\n            if ((_f = style.border_bottom_fill) === null || _f === void 0 ? void 0 : _f.text) {\n                color_map[style.border_bottom_fill.text] = 1;\n            }\n        };\n        parse(this.sheet_style);\n        for (const key in this.row_styles) {\n            parse(this.row_styles[key]);\n        }\n        for (const key in this.column_styles) {\n            parse(this.column_styles[key]);\n        }\n        for (const style of this.row_pattern) {\n            parse(style);\n        }\n        for (const row of this.cell_style) {\n            if (row) {\n                for (const style of row) {\n                    if (style) {\n                        parse(style);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * generates serializable object. given the new data semantics this\n     * has to change a bit. here is what we are storing:\n     *\n     * all style data (sheet, row/column, alternate and cell)\n     * raw value for cell\n     * array head for arrays\n     * row height and column width arrays\n     *\n     * because we have sparse arrays, we convert them to flat objects first.\n     */\n    toJSON(options = {}) {\n        // flatten height/width arrays\n        var _a;\n        const flatten_numeric_array = (arr, default_value) => {\n            const obj = {};\n            for (let i = 0; i < arr.length; i++) {\n                if ((typeof arr[i] !== 'undefined') && arr[i] !== default_value)\n                    obj[i] = arr[i];\n            }\n            if (Object.keys(obj).length)\n                return obj;\n            return undefined;\n        };\n        // flatten cell styles, which is a sparse array\n        // UPDATE: ref table\n        // NOTE: we originally did this (I think) because it's possible for a\n        // cell to have a style but have no other data, and therefore not be\n        // represented. but we should be able to store the data in the cell object\n        // if we have it...\n        let cell_style_refs = [{}]; // include an empty entry at zero\n        const cell_style_map = {};\n        const cell_reference_map = [];\n        // (1) create a map of cells -> references, and build the reference\n        //     table at the same time. preserve indexes? (...)\n        // it would be nice if we could use some sort of numeric test, rather\n        // than leaving empty indexes as undefined -- that requires a type test\n        // (to avoid zeros).\n        const empty_json = JSON.stringify({});\n        // actually we could just offset the index by 1... (see above)\n        for (let c = 0; c < this.cell_style.length; c++) {\n            const column = this.cell_style[c];\n            if (column) {\n                cell_reference_map[c] = [];\n                for (let r = 0; r < column.length; r++) {\n                    if (column[r]) {\n                        const style_as_json = JSON.stringify(column[r]);\n                        if (style_as_json !== empty_json) {\n                            let reference_index = cell_style_map[style_as_json];\n                            if (typeof reference_index !== 'number') {\n                                cell_style_map[style_as_json] = reference_index = cell_style_refs.length;\n                                cell_style_refs.push(column[r]);\n                            }\n                            cell_reference_map[c][r] = reference_index;\n                        }\n                    }\n                }\n            }\n        }\n        // ensure we're not linked\n        cell_style_refs = JSON.parse(JSON.stringify(cell_style_refs));\n        // same here (note broken naming)\n        const sheet_style = JSON.parse(JSON.stringify(this.sheet_style));\n        const row_style = JSON.parse(JSON.stringify(this.row_styles));\n        const column_style = JSON.parse(JSON.stringify(this.column_styles));\n        const row_pattern = JSON.parse(JSON.stringify(this.row_pattern));\n        const translate_border_color = (color, default_color) => {\n            if (typeof color !== 'undefined' && color !== 'none') {\n                if (color === default_color) {\n                    return undefined;\n                }\n                else {\n                    return treb_utils__WEBPACK_IMPORTED_MODULE_2__.Measurement.MeasureColorARGB(color);\n                }\n            }\n            return undefined;\n        };\n        const translate_border_fill = (color = {}, default_color = {}) => {\n            const result = Object.assign(Object.assign({}, default_color), color);\n            if (result.text) {\n                result.text = treb_utils__WEBPACK_IMPORTED_MODULE_2__.Measurement.MeasureColorARGB(result.text);\n                return result;\n            }\n            else if (typeof result.theme === 'number') {\n                return result;\n            }\n            return undefined;\n        };\n        // translate, if necessary\n        if (options.export_colors) {\n            const style_list = [];\n            for (const group of [row_style, column_style, cell_style_refs, [sheet_style], row_pattern]) {\n                if (Array.isArray(group)) {\n                    for (const entry of group)\n                        style_list.push(entry);\n                }\n                else {\n                    for (const key of Object.keys(group))\n                        style_list.push(group[key]);\n                }\n            }\n            for (const style of style_list) {\n                style.border_top_fill = translate_border_fill(style.border_top_fill, treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Style.DefaultProperties.border_top_fill);\n                style.border_left_fill = translate_border_fill(style.border_left_fill, treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Style.DefaultProperties.border_top_fill);\n                style.border_right_fill = translate_border_fill(style.border_right_fill, treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Style.DefaultProperties.border_top_fill);\n                style.border_bottom_fill = translate_border_fill(style.border_bottom_fill, treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Style.DefaultProperties.border_top_fill);\n                //style.border_top_color = translate_border_color(style.border_top_color, Style.DefaultProperties.border_top_color);\n                //style.border_left_color = translate_border_color(style.border_left_color, Style.DefaultProperties.border_left_color);\n                //style.border_right_color = translate_border_color(style.border_right_color, Style.DefaultProperties.border_right_color);\n                //style.border_bottom_color = translate_border_color(style.border_bottom_color, Style.DefaultProperties.border_bottom_color);\n                if ((_a = style.fill) === null || _a === void 0 ? void 0 : _a.text) {\n                    style.fill.text = treb_utils__WEBPACK_IMPORTED_MODULE_2__.Measurement.MeasureColorARGB(style.fill.text);\n                }\n                //if (typeof style.background !== 'undefined' && style.background !== 'none') {\n                //  style.background = Measurement.MeasureColorARGB(style.background);\n                //}\n                if (style.text) {\n                    if (style.text.text && style.text.text !== 'none') {\n                        style.text.text = treb_utils__WEBPACK_IMPORTED_MODULE_2__.Measurement.MeasureColorARGB(style.text.text);\n                    }\n                }\n            }\n        }\n        // FIXME: flatten row/column styles too\n        // flatten data -- also remove unecessary fields (FIXME: you might\n        // keep rendered data, so it doesn't have to do work on initial render?)\n        const serialization_options = {\n            calculated_value: !!options.rendered_values,\n            preserve_type: !!options.preserve_type,\n            expand_arrays: !!options.expand_arrays,\n            decorated_cells: !!options.decorated_cells,\n            nested: true,\n            cell_style_refs: cell_reference_map,\n        };\n        // the rows/columns we export can be shrunk to the actual used area,\n        // subject to serialization option.\n        const serialized_data = this.cells.toJSON(serialization_options);\n        const data = serialized_data.data;\n        let { rows, columns } = serialized_data;\n        if (!options.shrink) {\n            rows = this.rows;\n            columns = this.columns;\n        }\n        else {\n            // pad by 1 (2?)\n            rows += 2;\n            columns += 1;\n        }\n        // push out for annotations\n        for (const annotation of this.annotations) {\n            if (!annotation.extent) {\n                this.CalculateAnnotationExtent(annotation);\n            }\n            if (annotation.extent) {\n                rows = Math.max(rows, annotation.extent.row + 1);\n                columns = Math.max(columns, annotation.extent.column + 1);\n            }\n        }\n        // (3) (style) for anything that hasn't been consumed, create a\n        //     cell style map. FIXME: optional [?]\n        const cell_styles = [];\n        for (let c = 0; c < cell_reference_map.length; c++) {\n            const column = cell_reference_map[c];\n            if (column) {\n                for (let r = 0; r < column.length; r++) {\n                    if (column[r]) {\n                        cell_styles.push({ row: r, column: c, ref: column[r] });\n                    }\n                }\n            }\n        }\n        const result = {\n            // not used atm, but in the event we need to gate\n            // or swap importers on versions in the future\n            // FIXME: drop, in favor of container versioning. there's no point\n            // in this submodule versioning (is there? ...)\n            // version: (ModuleInfo as any).version,\n            id: this.id,\n            name: this.name,\n            data,\n            sheet_style,\n            rows,\n            columns,\n            cell_styles,\n            cell_style_refs,\n            row_style,\n            column_style,\n            row_pattern: row_pattern.length ? row_pattern : undefined,\n            // why are these serialized? (...) export!\n            default_row_height: this.default_row_height,\n            default_column_width: this.default_column_width,\n            row_height: flatten_numeric_array(this.row_height_, this.default_row_height),\n            column_width: flatten_numeric_array(this.column_width_, this.default_column_width),\n            selection: JSON.parse(JSON.stringify(this.selection)),\n            annotations: JSON.parse(JSON.stringify(this.annotations)),\n        };\n        // omit default (true)\n        if (!this.visible) {\n            result.visible = this.visible;\n        }\n        if (this.scroll_offset.x || this.scroll_offset.y) {\n            result.scroll = this.scroll_offset;\n        }\n        // moved to outer container (data model)\n        /*\n        // omit if empty\n    \n        if (this.named_ranges.Count()) {\n          result.named_ranges = JSON.parse(JSON.stringify(this.named_ranges.Map()));\n        }\n        */\n        // only put in freeze if used\n        if (this.freeze.rows || this.freeze.columns) {\n            result.freeze = this.freeze;\n        }\n        return result;\n    }\n    /*\n     * export values and calcualted values; as for csv export (which is what it's for) * /\n    public ExportValueData(transpose = false, dates_as_strings = false, export_functions = false): CellValue[][] {\n  \n      const arr: CellValue[][] = [];\n      const data = this.cells.data;\n  \n      if (transpose) {\n        const rowcount = data[0].length; // assuming it's a rectangle\n        for (let r = 0; r < rowcount; r++) {\n          const row: CellValue[] = [];\n          for (const column of data) {\n            const ref = column[r];\n            let value: CellValue;\n            if (!export_functions && typeof ref.calculated !== 'undefined') value = ref.calculated;\n            else if (typeof ref.value === 'undefined') value = '';\n            else value = ref.value;\n  \n            if (dates_as_strings && ref.style && typeof value === 'number') {\n              const format = NumberFormatCache.Get(ref.style.number_format || '');\n              if (format.date_format) value = format.Format(value);\n            }\n  \n            // if (dates_as_strings && ref.style && ref.style.date && typeof value === 'number') {\n            //  value = Style.Format(ref.style, value);\n            // }\n            row.push(value);\n          }\n          arr.push(row);\n        }\n      }\n      else {\n        for (const column_ref of data) {\n          const column: CellValue[] = [];\n          for (const ref of column_ref) {\n            let value: CellValue;\n            if (!export_functions && typeof ref.calculated !== 'undefined') value = ref.calculated;\n            else if (typeof ref.value === 'undefined') value = '';\n            else value = ref.value;\n  \n            if (dates_as_strings && ref.style && typeof value === 'number') {\n              const format = NumberFormatCache.Get(ref.style.number_format || '');\n              if (format.date_format) value = format.Format(value);\n            }\n  \n            // if (dates_as_strings && ref.style && ref.style.date && typeof value === 'number') {\n            //   value = Style.Format(ref.style, value);\n            // }\n            column.push(value);\n          }\n          arr.push(column);\n        }\n      }\n  \n      return arr;\n    }\n    */\n    /** flushes ALL rendered styles and caches. made public for theme API */\n    FlushCellStyles() {\n        this.style_map = [];\n        this.style_json_map = [];\n        this.cells.FlushCellStyles();\n    }\n    ImportData(data) {\n        const styles = data.styles;\n        // adding sheet style...\n        // 0 is implicitly just a general style\n        const sheet_style = data.sheet_style;\n        if (sheet_style) {\n            this.UpdateAreaStyle(new treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Area({ row: Infinity, column: Infinity }, { row: Infinity, column: Infinity }), styles[sheet_style]);\n        }\n        // and column styles...\n        const column_styles = data.column_styles;\n        if (column_styles) {\n            for (let i = 0; i < column_styles.length; i++) {\n                // 0 is implicitly just a general style\n                if (column_styles[i]) {\n                    this.UpdateAreaStyle(new treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Area({ row: Infinity, column: i }, { row: Infinity, column: i }), styles[column_styles[i]]);\n                }\n            }\n        }\n        // this.cells.FromJSON(cell_data);\n        this.cells.FromJSON(data.cells);\n        if (data.name) {\n            this.name = data.name || '';\n        }\n        // 0 is implicitly just a general style\n        const cs = this.cell_style;\n        for (const info of data.cells) {\n            if (info.style_ref) {\n                if (!cs[info.column])\n                    cs[info.column] = [];\n                cs[info.column][info.row] = styles[info.style_ref];\n            }\n        }\n        for (let i = 0; i < data.column_widths.length; i++) {\n            if (typeof data.column_widths[i] !== 'undefined') {\n                // OK this is unscaled, we are setting unscaled from source data\n                this.SetColumnWidth(i, data.column_widths[i]);\n            }\n        }\n        for (let i = 0; i < data.row_heights.length; i++) {\n            if (typeof data.row_heights[i] !== 'undefined') {\n                // OK this is unscaled, we are setting unscaled from source data\n                this.SetRowHeight(i, data.row_heights[i]);\n            }\n        }\n        for (const annotation of data.annotations || []) {\n            this.annotations.push(new _annotation__WEBPACK_IMPORTED_MODULE_4__.Annotation(annotation));\n        }\n        if (data.hidden) {\n            this.visible = false;\n        }\n    }\n    // --- protected ------------------------------------------------------------\n    /**\n     * figure out the last row/column of the annotation. this\n     * might set it to 0/0 if there's no rect, just make sure\n     * that it gets cleared on layout changes.\n     */\n    CalculateAnnotationExtent(annotation) {\n        // this is much easier with layout, but we are leaving the old\n        // coude to support older files -- OTOH, the layout will be created\n        // at some point, we just need to make sure that happens before this\n        // is called\n        var _a, _b;\n        if (annotation.layout) {\n            annotation.extent = Object.assign({}, annotation.layout.br.address);\n            return;\n        }\n        // 1000 here is just sanity check, it might be larger\n        const sanity = 1000;\n        annotation.extent = { row: 0, column: 0 };\n        let right = (_a = annotation.rect) === null || _a === void 0 ? void 0 : _a.right;\n        if (right && this.default_column_width) { // also sanity check\n            for (let i = 0; right >= 0 && i < sanity; i++) {\n                right -= this.GetColumnWidth(i); // FIXME: check // it's ok, rect is scaled to unit\n                if (right < 0) {\n                    annotation.extent.column = i;\n                    break;\n                }\n            }\n        }\n        let bottom = (_b = annotation.rect) === null || _b === void 0 ? void 0 : _b.bottom;\n        if (bottom && this.default_row_height) {\n            for (let i = 0; bottom >= 0 && i < sanity; i++) {\n                bottom -= this.GetRowHeight(i); // FIXME: check // it's ok, rect is scaled to unit\n                if (bottom < 0) {\n                    annotation.extent.row = i;\n                    break;\n                }\n            }\n        }\n    }\n    /* *\n     * when checking style properties, check falsy but not '' or 0\n     * (also strict equivalence)\n     * /\n    protected StyleEquals(a: any, b: any): boolean {\n      return a === b ||\n        ((a === false || a === null || a === undefined)\n          && (b === false || b === null || b === undefined));\n    }\n    */\n    /*\n    protected Serialize() {\n      return JSON.stringify(this);\n    }\n    */\n    /*\n    protected Deserialize(data: SerializedSheet) {\n      Sheet.FromJSON(data, this.default_style_properties, this);\n  \n      // some overlap here... consolidate? actually, doesn't\n      // fromJSON call flush styles? [A: sometimes...]\n  \n      this.cells.FlushCachedValues();\n      this.FlushCellStyles();\n    }\n    */\n    // --- private methods ------------------------------------------------------\n    /**\n     * update style properties. merge by default.\n     *\n     * this method will reverse-override properties, meaning if you have set (for\n     * example) a cell style to bold, then you set the whole sheet to unbold, we\n     * expect that the unbold style will control. instead of explicitly setting\n     * the cell style, we go up the chain and remove any matching properties.\n     */\n    UpdateSheetStyle(properties, delta = true) {\n        this.sheet_style = treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Style.Merge(this.sheet_style, properties, delta);\n        // reverse-override...\n        // const keys = Object.keys(properties);\n        const keys = Object.keys(properties);\n        // const keys = Object.keys(this.sheet_style) as Style.PropertyKeys[];\n        for (const style_column of this.cell_style) {\n            if (style_column) {\n                for (const style_ref of style_column) {\n                    if (style_ref) {\n                        keys.forEach((key) => delete style_ref[key]);\n                    }\n                }\n            }\n        }\n        for (const index of Object.keys(this.row_styles)) {\n            keys.forEach((key) => delete this.row_styles[index][key]);\n        }\n        for (const index of Object.keys(this.column_styles)) {\n            keys.forEach((key) => delete this.column_styles[index][key]);\n        }\n        // FIXME:  ROW PATTERN\n        this.FlushCellStyles(); // not targeted\n    }\n    /**\n     * updates row properties. reverse-overrides cells (@see UpdateSheetStyle).\n     *\n     * we also need to ensure that the desired effect takes hold, meaning if\n     * there's an overriding column property (columns have priority), we will\n     * need to update the cell property to match the desired output.\n     */\n    UpdateRowStyle(row, properties, delta = true) {\n        this.row_styles[row] = treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Style.Merge(this.row_styles[row] || {}, properties, delta);\n        // reverse-override... remove matching properties from cells in this row\n        // (we can do this in-place)\n        // const keys = Object.keys(properties);\n        const keys = Object.keys(properties);\n        // const keys = Object.keys(this.row_styles[row]) as Style.PropertyKeys[];\n        for (const column of this.cell_style) {\n            if (column && column[row]) {\n                // FIXME: we don't want to delete. reverse-add.\n                keys.forEach((key) => delete column[row][key]);\n            }\n        }\n        /*\n    \n        //\n        // seems to be related to\n        // https://github.com/microsoft/TypeScript/pull/30769\n        //\n        // not clear why the behavior should be different, but\n        //\n        // \"indexed access with generics now works differently inside & outside a function.\"\n        //\n    \n        const FilteredAssign = <T>(test: T, source: T, target: T, keys: Array<keyof T>): void => {\n          for (const key of keys) {\n            if (test[key] !== undefined) {\n              target[key] = source[key];\n            }\n          }\n        };\n        */\n        // if there's a column style, it will override the row\n        // style; so we need to set a cell style to compensate.\n        for (let i = 0; i < this.cells.columns; i++) {\n            if (this.column_styles[i]) {\n                const column_style = this.column_styles[i];\n                const override = this.cell_style[i] ? this.cell_style[i][row] || {} : {};\n                // FilteredAssign(column_style, properties, override, keys);\n                for (const key of keys) {\n                    if (typeof column_style[key] !== 'undefined') {\n                        override[key] = properties[key];\n                    }\n                }\n                if (Object.keys(override).length) {\n                    // console.info(override);\n                    if (!this.cell_style[i])\n                        this.cell_style[i] = [];\n                    this.cell_style[i][row] = JSON.parse(JSON.stringify(override));\n                }\n            }\n        }\n        // FIXME: ROW PATTERN\n        this.cells.Apply(this.RealArea(treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Area.FromRow(row)), (cell) => cell.FlushStyle());\n    }\n    /**\n     * styles are applied as a stack,\n     *\n     * sheet\n     * row pattern\n     * row\n     * column\n     * cell\n     *\n     * there are some cases where we wind up with overridden but matching\n     * styles that are duplicative. they can be removed, although it's not\n     * necessarily useful to do it in real time -- we can do it on load/save\n     * or perhaps on idle.\n     *\n     */\n    FlattenStyles() {\n        this.CompositeStyleForCell;\n    }\n    /**\n     * updates column properties. reverse-overrides cells (@see UpdateSheetStyle).\n     */\n    UpdateColumnStyle(column, properties, delta = true) {\n        this.column_styles[column] = treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Style.Merge(this.column_styles[column] || {}, properties, delta);\n        // returning to this function after a long time. so what this is doing\n        // is removing unecessary properties from style objects higher in the\n        // style chain, if those properties are overridden. note that this doesn't\n        // seem to prune now-empty styles, which it probably should...\n        // in essence, we have a containing style object\n        // { a: 1, c: 2 }\n        //\n        // then we iterate all cells in the column, and if there are any\n        // matching properties they're deleted; so if a cell has\n        // { a: 0, b: 1 }\n        //\n        // we drop the a property, so it becomes\n        // { b: 1 }\n        //\n        // note you can drop and re-create the cell style object, because the cell's\n        // reference is actually to a separate object (composited with the stack),\n        // and the reference is cleared so the composite will be rebuilt when it's\n        // needed next.\n        // NOTE this was broken anyway; it wasn't taking the merge into account...\n        // ALTHOUGH that breaks \"remove-color\" operations. I think the old way\n        // took into account that the styles would be relatively in sync already.\n        // reverse-override... I think we only need to override _cell_ values.\n        const keys = Object.keys(properties);\n        // const keys = Object.keys(this.column_styles[column]) as Style.PropertyKeys[];\n        if (this.cell_style[column]) {\n            for (const ref of this.cell_style[column]) {\n                if (ref) {\n                    // FIXME: we don't want to delete. reverse-add.\n                    keys.forEach((key) => delete ref[key]);\n                }\n            }\n        }\n        this.cells.Apply(this.RealArea(treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Area.FromColumn(column)), (cell) => cell.FlushStyle());\n        // FIXME: ROW PATTERN\n    }\n    /**\n     * generates the composite style for the given cell. this\n     * should only be used to generate a cache of styles (Q: really? PERF?)\n     *\n     * the \"apply_cell_style\" parameter is used for testing when pruning. we\n     * want to check what happens if the cell style is not applied; if nothing\n     * happens, then we can drop the cell style (or the property in the style).\n     */\n    CompositeStyleForCell(address, apply_cell_style = true, apply_row_pattern = true) {\n        const { row, column } = address;\n        const stack = [this.default_style_properties, this.sheet_style];\n        if (apply_row_pattern && this.row_pattern.length) {\n            stack.push(this.row_pattern[row % this.row_pattern.length]);\n        }\n        if (this.row_styles[row]) {\n            stack.push(this.row_styles[row]);\n        }\n        if (this.column_styles[column]) {\n            stack.push(this.column_styles[column]);\n        }\n        if (apply_cell_style\n            && this.cell_style[column]\n            && this.cell_style[column][row]) {\n            stack.push(this.cell_style[column][row]);\n        }\n        return treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Style.Composite(stack);\n    }\n    /**\n     * can we use the rendered JSON as a key, instead?\n     */\n    GetStyleIndex(style) {\n        const json = JSON.stringify(style);\n        for (let i = 0; i < this.style_json_map.length; i++) {\n            if (json === this.style_json_map[i])\n                return i; // match\n        }\n        // ok we need to add it to the list. make sure to add a copy,\n        // and add json to the json index.\n        const new_index = this.style_map.length;\n        this.style_map.push(JSON.parse(json));\n        this.style_json_map.push(json);\n        return new_index;\n    }\n}\nSheet.base_id = 100;\nSheet.default_sheet_name = 'Sheet1';\n\n\n//# sourceURL=webpack://treb/./treb-grid/src/types/sheet.ts?");

/***/ }),

/***/ "./treb-mc/src/calculation-worker/calculation-worker.ts":
/*!**************************************************************!*\
  !*** ./treb-mc/src/calculation-worker/calculation-worker.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _worker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../worker */ \"./treb-mc/src/worker.ts\");\n// ----------------------\n\nconst ctx = self;\nconst worker = new _worker__WEBPACK_IMPORTED_MODULE_0__.WorkerImpl(ctx);\n// initialize message handler\nctx.addEventListener('message', (event) => worker.OnMessage(event));\n\n\n//# sourceURL=webpack://treb/./treb-mc/src/calculation-worker/calculation-worker.ts?");

/***/ }),

/***/ "./treb-mc/src/calculation-worker/index-modern.ts":
/*!********************************************************!*\
  !*** ./treb-mc/src/calculation-worker/index-modern.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _calculation_worker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./calculation-worker */ \"./treb-mc/src/calculation-worker/calculation-worker.ts\");\n\n\n\n//# sourceURL=webpack://treb/./treb-mc/src/calculation-worker/index-modern.ts?");

/***/ }),

/***/ "./treb-mc/src/pack-results.ts":
/*!*************************************!*\
  !*** ./treb-mc/src/pack-results.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PackOne\": () => (/* binding */ PackOne),\n/* harmony export */   \"UnpackOne\": () => (/* binding */ UnpackOne),\n/* harmony export */   \"ConsolidateResults\": () => (/* binding */ ConsolidateResults)\n/* harmony export */ });\n/**\n * results looks like this:\n * Array<{row: number, column: number, data: any[]}>\n *\n * where the array length is the number of trials. assuming\n * we only handle numbers, we should be able to pack this into\n * an array.\n *\n * container looks like this:\n * {\n *    elapsed: number;\n *    trials: number;\n *    results: Float64Array[] (actually ArrayBuffer)\n * }\n *\n */\nconst PackOne = (result) => {\n    const size = 4 + result.data.length;\n    const data = new Float64Array(size);\n    data[0] = result.column;\n    data[1] = result.row;\n    data[2] = result.sheet_id;\n    data[3] = result.data.length;\n    data.set(result.data, 4);\n    return data;\n};\nconst UnpackOne = (data) => {\n    // we might have old-style data... how to know? should have\n    // added a version flag (probably not, wasteful)\n    if (data.length === 3 + data[2]) {\n        return { column: data[0], row: data[1], sheet_id: 0, data: data.subarray(3) };\n    }\n    else {\n        return { column: data[0], row: data[1], sheet_id: data[2], data: data.subarray(4) };\n    }\n};\n/**\n * consolidate multiple results (from multiple threads)\n */\nconst ConsolidateResults = (thread_results) => {\n    // special case\n    if (thread_results.length === 1) {\n        return thread_results[0];\n    }\n    let elapsed = 0;\n    let trials = 0;\n    for (const result of thread_results) {\n        elapsed = Math.max(elapsed, result.elapsed);\n        trials += result.trials;\n    }\n    // allocate, and copy first set\n    const base = thread_results[0];\n    const consolidated = base.results.map((original) => {\n        const resized = new Float64Array(4 + trials);\n        resized.set(new Float64Array(original));\n        return resized;\n    });\n    let offset = base.trials + 4;\n    // now copy the rest (omitting header)\n    for (let i = 1; i < thread_results.length; i++) {\n        const set = thread_results[i];\n        set.results.forEach((packed, index) => {\n            const result = new Float64Array(packed);\n            const target = consolidated[index];\n            // validate\n            if (target[0] !== result[0]\n                || target[1] !== result[1]\n                || target[2] !== result[2]) {\n                throw new Error('mismatch in result address');\n            }\n            target.set(result.subarray(4), offset);\n        });\n        offset += set.trials;\n    }\n    // ok\n    return {\n        elapsed,\n        trials,\n        results: consolidated.map(result => result.buffer),\n    };\n};\n\n\n//# sourceURL=webpack://treb/./treb-mc/src/pack-results.ts?");

/***/ }),

/***/ "./treb-mc/src/simulation-calculator.ts":
/*!**********************************************!*\
  !*** ./treb-mc/src/simulation-calculator.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MCCalculator\": () => (/* binding */ MCCalculator)\n/* harmony export */ });\n/* harmony import */ var treb_calculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! treb-calculator */ \"./treb-calculator/src/index.ts\");\n/* harmony import */ var treb_calculator_src_dag_graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! treb-calculator/src/dag/graph */ \"./treb-calculator/src/dag/graph.ts\");\n/* harmony import */ var _pack_results__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pack-results */ \"./treb-mc/src/pack-results.ts\");\n/* harmony import */ var _simulation_expression_calculator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./simulation-expression-calculator */ \"./treb-mc/src/simulation-expression-calculator.ts\");\n/* harmony import */ var _simulation_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./simulation-model */ \"./treb-mc/src/simulation-model.ts\");\n// this will move to a new subdir eventually so we can enforce isolation\n\n\n\n\n\nclass MCCalculator extends treb_calculator__WEBPACK_IMPORTED_MODULE_0__.Calculator {\n    constructor() {\n        super();\n        this.expression_calculator =\n            this.simulation_expression_calculator = new _simulation_expression_calculator__WEBPACK_IMPORTED_MODULE_3__.MCExpressionCalculator(this.library, this.parser);\n        // mc functions\n        this.library.Register(this.simulation_expression_calculator.simulation_model.functions);\n    }\n    InitSimulation(iterations, lhs, \n    // cells: Cells,\n    model, additional_cells, seed) {\n        var _a;\n        const simulation_model = this.simulation_expression_calculator.simulation_model;\n        simulation_model.iterations = iterations;\n        simulation_model.results = [];\n        simulation_model.lhs = lhs;\n        simulation_model.correlated_distributions = {};\n        if (typeof seed === 'number') {\n            simulation_model.seed = seed;\n        }\n        // const cells = model.active_sheet.cells;\n        // calling the flush method, instead of flushing tree directly,\n        // will also set status -> OK. note that (atm, at least) we don't\n        // need to deal with spreadsheet leaf nodes in the worker thread.\n        this.Reset();\n        // this.AttachData(model);\n        // this.expression_calculator.SetModel(model);\n        this.AttachModel(model);\n        // add additional cells to monitor, but only if they actually\n        // exist; otherwise they will generate calc errors. \n        //\n        // cells passed as \"additional cells\" MUST HAVE SHEET ID (will throw)\n        if (additional_cells && additional_cells.length) {\n            for (const address of additional_cells) {\n                if (!address.sheet_id) {\n                    throw new Error('additional cell passed without sheet id');\n                }\n                for (const sheet of ((_a = this.model) === null || _a === void 0 ? void 0 : _a.sheets) || []) {\n                    if (sheet.id === address.sheet_id) {\n                        const cell = sheet.cells.GetCell(address, false);\n                        if (cell) {\n                            simulation_model.StoreCellResults(address);\n                        }\n                        break;\n                    }\n                }\n                /*\n                const cell = cells.GetCell(address, false); // whoops\n                if (cell) {\n                  simulation_model.StoreCellResults(address);\n                }\n                else console.info( 'Skipping empty cell', address);\n                */\n            }\n        }\n        this.RebuildGraph();\n        if (this.LoopCheck()) {\n            throw new Error('Loop (circular dependency) found in graph');\n        }\n        // NOTE: not dealing with annotations here. the rationale is that these\n        // may have external function definitions, so we can't reliably get the\n        // metadata. there should really be no reason to do this anyway... so\n        // dropping annotations from simulation. someone else needs to get the\n        // metadata for collecting results and pass it in (via additional_cells)\n        // FIXME: consolidate with trial method\n        simulation_model.state = _simulation_model__WEBPACK_IMPORTED_MODULE_4__.SimulationState.Prep;\n        simulation_model.iteration = 0;\n        this.Recalculate();\n        simulation_model.CorrelateDistributions();\n        simulation_model.state = _simulation_model__WEBPACK_IMPORTED_MODULE_4__.SimulationState.Simulation;\n        return treb_calculator_src_dag_graph__WEBPACK_IMPORTED_MODULE_1__.GraphStatus.OK; // result.status;\n    }\n    /**\n     * returns simulation results. this is called after a simulation, results\n     * will be returned from the worker(s) back to the main thread.\n     */\n    GetResults() {\n        return this.simulation_expression_calculator.simulation_model.results;\n    }\n    /**\n     * runs a single iteration in a simulation. calculation is simpler because\n     * we know that nothing has changed in the graph since the last calculation\n     * (since we set up the graph). the only things that are going to be dirty\n     * are the volatile cells, which set set explicitly.\n     */\n    SimulationTrial(iteration) {\n        const simulation_model = this.simulation_expression_calculator.simulation_model;\n        simulation_model.iteration = iteration;\n        // now handled in graph/calc via volatile and simulationvolatile\n        // Model.volatile_functions.forEach((addr) => this.SetDirty(addr));\n        // there's no loop check here because the graph can't change between\n        // init() and here; although the loop check would theoretically short-\n        // circuit anyway, since it's gated\n        try {\n            this.Recalculate();\n            // FIXME: we should pull out index pairs once, then refer\n            // to the list. while this probably isn't slow, it seems\n            // unecessary.\n            // tslint:disable-next-line:forin\n            for (const id in simulation_model.results) {\n                // we should validate this, but I don't want to do that on every\n                // trial... can we precheck against collected cells, before running?\n                // maybe in prep? (...)\n                const cells = this.cells_map[id];\n                // tslint:disable-next-line:forin\n                for (const c in simulation_model.results[id]) {\n                    const column = simulation_model.results[id][c];\n                    // tslint:disable-next-line:forin\n                    for (const r in column) {\n                        const cell = cells.GetCell({ row: Number(r), column: Number(c) });\n                        // it seems like this is a waste -- if the cell doesn't exist,\n                        // we should remove it from the list (or not add it in the first\n                        // place). that prevents it from getting tested every loop.\n                        if (cell) {\n                            const value = cell.GetValue();\n                            switch (typeof value) {\n                                case 'number':\n                                    column[r][iteration] = value;\n                                    break;\n                                case 'boolean':\n                                    column[r][iteration] = value ? 1 : 0;\n                                    break;\n                                default: column[r][iteration] = 0;\n                            }\n                        }\n                    }\n                }\n            }\n            return { status: treb_calculator_src_dag_graph__WEBPACK_IMPORTED_MODULE_1__.GraphStatus.OK, reference: null };\n        }\n        catch (err) {\n            console.info('calculation error trapped', err);\n            return { status: treb_calculator_src_dag_graph__WEBPACK_IMPORTED_MODULE_1__.GraphStatus.CalculationError, reference: null };\n        }\n    }\n    /**\n     * flattens results for passing to the main thread from worker\n     */\n    FlattenedResults() {\n        const simulation_model = this.simulation_expression_calculator.simulation_model;\n        // flatten into buffers\n        const flattened = [];\n        // tslint:disable-next-line:forin\n        for (const id in simulation_model.results) {\n            // tslint:disable-next-line:forin\n            for (const c in simulation_model.results[id]) {\n                const column = simulation_model.results[id][c];\n                // tslint:disable-next-line:forin\n                for (const r in column) {\n                    flattened.push(_pack_results__WEBPACK_IMPORTED_MODULE_2__.PackOne({\n                        row: Number(r), column: Number(c), sheet_id: Number(id), data: column[r]\n                    }).buffer);\n                }\n            }\n        }\n        return flattened;\n    }\n    /** basically set null results */\n    FlushSimulationResults() {\n        const simulation_model = this.simulation_expression_calculator.simulation_model;\n        simulation_model.results = [];\n        simulation_model.elapsed = 0;\n        simulation_model.trials = 0;\n    }\n    /** TODO */\n    ShiftSimulationResults(before_row, before_column, rows, columns) {\n        // ...\n    }\n    /**\n     * updates simulation results for watched cells. after a simulation,\n     * these will generally come in from the worker thread. FIXME: move\n     * worker in here?\n     *\n     * once these are set, simulation functions (e.g. mean) can return\n     * results\n     *\n     * @param model model passed directly, in case the model has not yet\n     * been set; we may need this for assigning simulation results from\n     * older files.\n     *\n     * @param set_dirty ordinarily we would set the cell dirty, but on\n     * load it may not yet be available, and we are going to mark it dirty\n     * later anyway -- so pass false to skip.\n     */\n    UpdateResults(data, model = this.model, set_dirty = true) {\n        if (!model) {\n            throw new Error('UpdateResults called without model');\n        }\n        const simulation_model = this.simulation_expression_calculator.simulation_model;\n        if (!data) {\n            simulation_model.results = [];\n            simulation_model.elapsed = 0;\n            simulation_model.trials = 0;\n        }\n        else {\n            simulation_model.results = [];\n            simulation_model.elapsed = data.elapsed;\n            simulation_model.trials = data.trials;\n            for (const result of data.results) {\n                const entry = (result instanceof ArrayBuffer) ? _pack_results__WEBPACK_IMPORTED_MODULE_2__.UnpackOne(new Float64Array(result)) : result;\n                if (!entry.sheet_id) {\n                    entry.sheet_id = model.active_sheet.id;\n                }\n                if (!simulation_model.results[entry.sheet_id]) {\n                    simulation_model.results[entry.sheet_id] = [];\n                }\n                if (!simulation_model.results[entry.sheet_id][entry.column]) {\n                    simulation_model.results[entry.sheet_id][entry.column] = [];\n                }\n                simulation_model.results[entry.sheet_id][entry.column][entry.row] = entry.data;\n                if (set_dirty) {\n                    this.SetDirty(entry);\n                }\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://treb/./treb-mc/src/simulation-calculator.ts?");

/***/ }),

/***/ "./treb-mc/src/simulation-expression-calculator.ts":
/*!*********************************************************!*\
  !*** ./treb-mc/src/simulation-expression-calculator.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MCExpressionCalculator\": () => (/* binding */ MCExpressionCalculator)\n/* harmony export */ });\n/* harmony import */ var _treb_calculator_src_expression_calculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../treb-calculator/src/expression-calculator */ \"./treb-calculator/src/expression-calculator.ts\");\n/* harmony import */ var _treb_calculator_src_descriptors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../treb-calculator/src/descriptors */ \"./treb-calculator/src/descriptors.ts\");\n/* harmony import */ var _treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../treb-calculator/src/function-error */ \"./treb-calculator/src/function-error.ts\");\n/* harmony import */ var _simulation_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./simulation-model */ \"./treb-mc/src/simulation-model.ts\");\n/* harmony import */ var treb_base_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! treb-base-types */ \"./treb-base-types/src/index.ts\");\n// we're deep-linking because these types are not exported by the project\n\n\n\n\n\nclass MCExpressionCalculator extends _treb_calculator_src_expression_calculator__WEBPACK_IMPORTED_MODULE_0__.ExpressionCalculator {\n    constructor(library, parser) {\n        super(library, parser);\n        this.simulation_model = new _simulation_model__WEBPACK_IMPORTED_MODULE_3__.SimulationModel();\n        this.context = this.simulation_model;\n    }\n    /** excutes a function call */\n    CallExpression(outer, return_reference = false) {\n        // get the function descriptor, which won't change.\n        // we can bind in closure (also short-circuit check for\n        // invalid name)\n        const func = this.library.Get(outer.name);\n        if (!func) {\n            return (expr) => (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_2__.NameError)();\n        }\n        // I wonder if we can handle prep separately, outside of\n        // the closure. on the assumption that prep is always the\n        // first call, perhaps we can check state first; do prep;\n        // and then return the closure without prep calls.\n        // also move this out?\n        const argument_descriptors = func.arguments || []; // map\n        if (this.simulation_model.state === _simulation_model__WEBPACK_IMPORTED_MODULE_3__.SimulationState.Prep) {\n            // this is a separate loop because we only need to call it on prep\n            // FIXME: can this move to parsing stage? (old note: probably this too,\n            // with a flag)\n            // we could split the simulation functions into regular and prep stage,\n            // which would drop a test inside the function.\n            // if you do that, though, make sure to set the captured call_index here\n            // (currently that's set below for the function call).\n            // NOTE: call_index is not relevant to StoreCellResults\n            // FIXME: this uses sheet IDs, correct? [yes]\n            outer.args.forEach((arg, arg_index) => {\n                const descriptor = argument_descriptors[arg_index] || {};\n                if (arg && descriptor.collector) {\n                    if (arg.type === 'address') {\n                        this.simulation_model.StoreCellResults(arg);\n                    }\n                    else if (arg.type === 'identifier') {\n                        const named_range = this.named_range_map[arg.name.toUpperCase()];\n                        if (named_range) {\n                            this.simulation_model.StoreCellResults(named_range.start);\n                        }\n                    }\n                    else if (arg.type === 'call') {\n                        // support for \"offset\", essentially (see also below)\n                        const result = this.CalculateExpression(arg, true);\n                        if (result && (0,_treb_calculator_src_expression_calculator__WEBPACK_IMPORTED_MODULE_0__.UnionIsExpressionUnit)(result)) {\n                            if (result.value.type === 'address') {\n                                this.simulation_model.StoreCellResults(result.value);\n                            }\n                            else if (result.value.type === 'range') {\n                                this.simulation_model.StoreCellResults(result.value.start);\n                            }\n                        }\n                    }\n                    else {\n                        // console.info('mark x...', arg.type)\n                    }\n                }\n            });\n        }\n        //\n        return (expr) => {\n            // get an index we can use for this call (we may recurse when\n            // calculating arguments), then increment for the next call.\n            const call_index = this.call_index++;\n            // yeah so this is clear. just checking volatile.\n            // FIXME: should this be set later, at the same time as the\n            // calculation index? I think it should, since we may recurse.\n            // BEFORE YOU DO THAT, track down all references that read this field\n            // from what I can tell, the only place this is read is after the\n            // external (outer) Calculate() call. so we should move this assignment,\n            // and we should also be able to get it to fail:\n            //\n            // RandBetween() should be volatile, but if we have a nonvolatile function\n            // as an argument that should unset it, and remove the volatile flag.\n            // Check?\n            // actually this works, because it only sets the flag (does not unset).\n            // volatile applies to the _cell_, not just the function -- so as long\n            // as the outer function sets the flag, it's not material if an inner\n            // function is nonvolatile. similarly an inner volatile function will\n            // make the outer function volatile.\n            // this does mean that the nonvolatile function will be treated differently\n            // if it's an argument to a volatile function, but I think that's reasonable\n            // behavior; also it's symmetric with the opposite case (inner volatile.)\n            // so leave this as-is, or you can move it -- should be immaterial\n            this.simulation_model.volatile = this.simulation_model.volatile || (!!func.volatile) ||\n                ((!!func.simulation_volatile) && this.simulation_model.state !== _simulation_model__WEBPACK_IMPORTED_MODULE_3__.SimulationState.Null);\n            // NOTE: the argument logic is (possibly) calculating unecessary operations,\n            // if there's a conditional (like an IF function). although that is the\n            // exception rather than the rule...\n            const if_function = outer.name.toUpperCase() === 'IF';\n            let skip_argument_index = -1;\n            let argument_error;\n            const mapped_args = (expr.args).map((arg, arg_index) => {\n                // short circuit\n                if (argument_error) {\n                    return undefined;\n                }\n                // get descriptor. if the number of arguments exceeds \n                // the number of descriptors, recycle the last one\n                const descriptor = argument_descriptors[Math.min(arg_index, argument_descriptors.length - 1)] || {};\n                // // if function, wrong branch\n                if (arg_index === skip_argument_index) {\n                    // console.info('skipped');\n                    return descriptor.boxed ? (0,treb_base_types__WEBPACK_IMPORTED_MODULE_4__.UndefinedUnion)() : undefined;\n                }\n                if (typeof arg === 'undefined') {\n                    if (if_function && arg_index === 0) {\n                        skip_argument_index = 1;\n                    }\n                    return descriptor.boxed ? (0,treb_base_types__WEBPACK_IMPORTED_MODULE_4__.UndefinedUnion)() : undefined;\n                }\n                // FIXME (address): what about named ranges (actually those will work),\n                // constructed references (we don't support them atm)?\n                // NOTE: named ranges will _not_ work, because the address will be an\n                // object, not a string. so FIXME.\n                // FIXME?: as currently implemented, OFFSET and INDIRECT will not work.\n                // we may be able to fix that, but I'm not sure we should -- this is\n                // an acceptable limitation, and the cost of doing that [correctly] \n                // would be high. also, it's possible to get the same result using \n                // the spreadsheet, instead of adding here, so let that be the resolution.\n                // we can do that, now, using metadata. we should do that. it will require\n                // a little snipping here and there... use metadata, then format from address.\n                // is this adding overhead, with the lookup? maybe we should check type...\n                if (descriptor.address) {\n                    return descriptor.boxed ? {\n                        type: treb_base_types__WEBPACK_IMPORTED_MODULE_4__.ValueType.string,\n                        value: this.parser.Render(arg).replace(/\\$/g, ''),\n                    } : this.parser.Render(arg).replace(/\\$/g, '');\n                }\n                else if (descriptor.metadata) {\n                    return this.GetMetadata(arg, (cell_data, address) => {\n                        const simulation_data = (this.simulation_model.state === _simulation_model__WEBPACK_IMPORTED_MODULE_3__.SimulationState.Null) ?\n                            this.simulation_model.StoreCellResults(address) : [];\n                        return { simulation_data };\n                    });\n                }\n                else if (descriptor.collector && this.simulation_model.state === _simulation_model__WEBPACK_IMPORTED_MODULE_3__.SimulationState.Null) {\n                    // this branch is _getting_ simulation data, even though it uses\n                    // the same function that marks cells for storage. we could perhaps\n                    // use a separate function that doesn't allocate.\n                    if (arg.type === 'address') {\n                        return this.simulation_model.StoreCellResults(arg);\n                    }\n                    else if (arg.type === 'range') {\n                        return this.simulation_model.StoreCellResults(arg.start);\n                    }\n                    else if (arg.type === 'identifier') {\n                        const named_range = this.named_range_map[arg.name.toUpperCase()];\n                        if (named_range) {\n                            return this.simulation_model.StoreCellResults(named_range.start);\n                        }\n                    }\n                    else if (arg.type === 'call') {\n                        // support for \"offset\", essentially (see also above)\n                        const result = this.CalculateExpression(arg, true);\n                        if (result && (0,_treb_calculator_src_expression_calculator__WEBPACK_IMPORTED_MODULE_0__.UnionIsExpressionUnit)(result)) {\n                            if (result.value.type === 'address') {\n                                return this.simulation_model.StoreCellResults(result.value);\n                            }\n                            else if (result.value.type === 'range') {\n                                return this.simulation_model.StoreCellResults(result.value.start);\n                            }\n                        }\n                    }\n                    // if we didn't have a valid reference it's an error\n                    argument_error = (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_2__.ReferenceError)();\n                    return argument_error;\n                }\n                else {\n                    const result = this.CalculateExpression(arg);\n                    if (!Array.isArray(result) && result.type === treb_base_types__WEBPACK_IMPORTED_MODULE_4__.ValueType.error) {\n                        if (descriptor.allow_error) {\n                            return result; // always boxed\n                        }\n                        argument_error = result;\n                        return undefined; // argument not used, so don't bother boxing\n                    }\n                    // can't shortcut if you have an array (or we need to test all the values)\n                    if (if_function && arg_index === 0 && !Array.isArray(result)) {\n                        let result_truthy = false;\n                        // if (Array.isArray(result)) { result_truthy = true; }\n                        if (result.type === treb_base_types__WEBPACK_IMPORTED_MODULE_4__.ValueType.string) {\n                            const lowercase = result.value.toLowerCase().trim();\n                            result_truthy = lowercase !== 'false' && lowercase !== 'f';\n                        }\n                        else {\n                            result_truthy = !!result.value;\n                        }\n                        // console.info(\"RTT\", result_truthy);\n                        skip_argument_index = result_truthy ? 2 : 1;\n                    }\n                    if (descriptor.boxed) {\n                        return result;\n                    }\n                    if (Array.isArray(result)) {\n                        return result.map(row => row.map(value => value.value));\n                    }\n                    else {\n                        return result.value; // unboxing\n                    }\n                }\n                throw new Error('never');\n                return undefined; // default\n            });\n            if (argument_error) {\n                return argument_error;\n            }\n            // if we have any nested calls, they may have updated the index so\n            // we use the captured value here.\n            this.context.call_index = call_index;\n            // I thought we were passing the model as this (...) ? actually\n            // now we bind functions that need this, so maybe we should pass\n            // null here.\n            if (func.return_type === _treb_calculator_src_descriptors__WEBPACK_IMPORTED_MODULE_1__.ReturnType.reference) {\n                const result = func.fn.apply(null, mapped_args);\n                if (return_reference) {\n                    return result;\n                }\n                if ((0,_treb_calculator_src_expression_calculator__WEBPACK_IMPORTED_MODULE_0__.UnionIsExpressionUnit)(result)) {\n                    if (result.value.type === 'address') {\n                        return this.CellFunction2(result.value)();\n                    }\n                    else if (result.value.type === 'range') {\n                        return this.CellFunction4(result.value.start, result.value.end);\n                    }\n                }\n                return result; // error?\n            }\n            return func.fn.apply(null, mapped_args);\n        };\n    }\n}\n\n\n//# sourceURL=webpack://treb/./treb-mc/src/simulation-expression-calculator.ts?");

/***/ }),

/***/ "./treb-mc/src/simulation-model.ts":
/*!*****************************************!*\
  !*** ./treb-mc/src/simulation-model.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SimulationState\": () => (/* binding */ SimulationState),\n/* harmony export */   \"SimulationModel\": () => (/* binding */ SimulationModel)\n/* harmony export */ });\n/* harmony import */ var treb_base_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! treb-base-types */ \"./treb-base-types/src/index.ts\");\n/* harmony import */ var _treb_calculator_src_utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../treb-calculator/src/utilities */ \"./treb-calculator/src/utilities.ts\");\n/* harmony import */ var riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! riskampjs-mc */ \"./node_modules/riskampjs-mc/dist/index.js\");\n/* harmony import */ var riskampjs_mc__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../treb-calculator/src/function-error */ \"./treb-calculator/src/function-error.ts\");\n/* harmony import */ var treb_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! treb-utils */ \"./treb-utils/src/index.ts\");\n/* eslint-disable no-unexpected-multiline */\n\n\n\n\n\nvar SimulationState;\n(function (SimulationState) {\n    SimulationState[SimulationState[\"Null\"] = 0] = \"Null\";\n    SimulationState[SimulationState[\"Prep\"] = 1] = \"Prep\";\n    SimulationState[SimulationState[\"Simulation\"] = 2] = \"Simulation\";\n    SimulationState[SimulationState[\"Post\"] = 3] = \"Post\";\n})(SimulationState || (SimulationState = {}));\nconst ShuffledIntegers = (count) => {\n    const field = riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.Uniform(count);\n    const shuffled = [];\n    for (let i = 0; i < count; i++) {\n        shuffled[i] = i;\n    }\n    for (let i = 0; i < count; i++) {\n        const j = i + Math.floor(field[i] * (count - i));\n        const tmp = shuffled[i];\n        shuffled[i] = shuffled[j];\n        shuffled[j] = tmp;\n    }\n    return shuffled;\n};\n/**\n * class represents a model, including simulation data and functions. the\n * spreadsheet functions refer to an instance of the model, which retains\n * state.\n *\n * FIXME: split state and model so we can have a non-MC model\n *\n * making a non-MC model might require moving some logic in here from\n * the various calculator classes (I think)\n */\nclass SimulationModel {\n    constructor() {\n        // I think these two are the only ones we might need outside of\n        // simulation/MC functions\n        this.address = { row: 0, column: 0 };\n        this.volatile = false;\n        // public name_stack: Array<{[index: string]: ExpressionUnit}> = [];\n        // the rest are specific to MC, I think\n        this.iteration = 0;\n        this.iterations = 0;\n        this.call_index = 0;\n        this.lhs = false;\n        this.state = SimulationState.Null;\n        this.results = [];\n        this.elapsed = 0;\n        this.trials = 0;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.distributions = [];\n        this.correlated_distributions = {};\n        this.functions = {\n            'Multivariate.Normal': {\n                description: 'Returns a sample from the multivariate normal distribution',\n                simulation_volatile: true,\n                arguments: [\n                    { name: 'range of values', description: 'Set of Correlated Distributions (N)', address: true },\n                    { name: 'correlation', description: 'Correlation Matrix (NxN)' },\n                    { name: 'mean', description: 'Distribution Mean', default: 0 },\n                    { name: 'stdev', description: 'Standard Deviation', default: 1 },\n                ],\n                fn: this.multivariate_normal.bind(this),\n                category: ['RiskAMP Random Distributions'],\n                extension: true,\n            },\n            'Multivariate.LogNormal': {\n                description: 'Returns a sample from the multivariate log-normal distribution',\n                simulation_volatile: true,\n                arguments: [\n                    { name: 'range of values', description: 'Set of Correlated Distributions (N)', address: true },\n                    { name: 'correlation', description: 'Correlation Matrix (NxN)' },\n                    { name: 'mean', description: 'Mean of underlying Normal distribution', default: 0 },\n                    { name: 'stdev', description: 'Standard Deviation of underlying Normal distribution', default: 1 },\n                ],\n                fn: this.multivariate_lognormal.bind(this),\n                category: ['RiskAMP Random Distributions'],\n                extension: true,\n            },\n            'Multivariate.Uniform': {\n                description: 'Returns a sample from the multivariate uniform distribution',\n                simulation_volatile: true,\n                arguments: [\n                    { name: 'range of values', description: 'Set of Correlated Distributions (N)', address: true },\n                    { name: 'correlation', description: 'Correlation Matrix (NxN)' },\n                    { name: 'min', description: 'Minimum Value', default: 0 },\n                    { name: 'max', description: 'Maximum Value', default: 1 },\n                ],\n                fn: this.multivariate_uniform.bind(this),\n                category: ['RiskAMP Random Distributions'],\n                extension: true,\n            },\n            'Multivariate.Beta': {\n                description: 'Returns a sample from the multivariate beta distribution',\n                simulation_volatile: true,\n                arguments: [\n                    { name: 'range of values', description: 'Set of Correlated Distributions (N)', address: true },\n                    { name: 'correlation', description: 'Correlation Matrix (NxN)' },\n                    { name: 'w', description: 'Shape Parameter' },\n                    { name: 'v', description: 'Shape Parameter' },\n                ],\n                fn: this.multivariate_beta.bind(this),\n                category: ['RiskAMP Random Distributions'],\n                extension: true,\n            },\n            'Multivariate.PERT': {\n                description: 'Returns a sample from the multivariate PERT distribution',\n                simulation_volatile: true,\n                arguments: [\n                    { name: 'range of values', description: 'Set of Correlated Distributions (N)', address: true },\n                    { name: 'correlation', description: 'Correlation Matrix (NxN)' },\n                    { name: 'min', description: 'Minimum Value' },\n                    { name: 'mode', description: 'Most-Likely Value' },\n                    { name: 'max', description: 'Maximum Value' },\n                    { name: 'lambda', default: 4 },\n                ],\n                fn: this.multivariate_pert.bind(this),\n                category: ['RiskAMP Random Distributions'],\n                extension: true,\n            },\n            'Multivariate.Triangular': {\n                description: 'Returns a sample from the multivariate triangular distribution',\n                simulation_volatile: true,\n                arguments: [\n                    { name: 'range of values', description: 'Set of Correlated Distributions (N)', address: true },\n                    { name: 'correlation', description: 'Correlation Matrix (NxN)' },\n                    { name: 'min', description: 'Minimum Value' },\n                    { name: 'mode', description: 'Most-Likely Value' },\n                    { name: 'max', description: 'Maximum Value' },\n                ],\n                fn: this.multivariate_triangular.bind(this),\n                category: ['RiskAMP Random Distributions'],\n                extension: true,\n            },\n            // basic distributions\n            UniformRangeSample: {\n                description: 'Returns one of a set of values, with equal probability and with replacement',\n                simulation_volatile: true,\n                arguments: [\n                    { name: 'range', description: 'Range of Values' },\n                ],\n                fn: this.uniformrangesample.bind(this),\n                category: ['RiskAMP Random Distributions'],\n                extension: true,\n            },\n            SampleValue: {\n                description: 'Returns one of a set of values, with equal probability and with replacement',\n                simulation_volatile: true,\n                arguments: [\n                    { name: 'range', description: 'Range of Values' },\n                ],\n                fn: this.samplevalue.bind(this),\n                category: ['RiskAMP Random Distributions'],\n                extension: true,\n            },\n            'SampleValue.Weighted': {\n                description: 'Returns one of a set of values, weighted by a second set of values',\n                simulation_volatile: true,\n                arguments: [\n                    { name: 'range', description: 'Range of Values' },\n                    { name: 'weights', description: 'Range of Weights' },\n                ],\n                fn: this.samplevalue_weighted.bind(this),\n                category: ['RiskAMP Random Distributions'],\n                extension: true,\n            },\n            BernoulliValue: {\n                description: 'Returns true or false (boolean) based on the given probability',\n                simulation_volatile: true,\n                arguments: [\n                    { name: 'p', description: 'Probability to return True', default: 0.5 },\n                ],\n                fn: this.bernoullivalue.bind(this),\n                category: ['RiskAMP Random Distributions'],\n                extension: true,\n            },\n            ProbabilityValue: {\n                description: 'Returns true or false (boolean) based on the given probability',\n                simulation_volatile: true,\n                arguments: [\n                    { name: 'p', description: 'Probability to return True', default: 0.5 },\n                ],\n                fn: this.probabilityvalue.bind(this),\n                category: ['RiskAMP Random Distributions'],\n                extension: true,\n            },\n            UniformValue: {\n                description: 'Returns a sample from the uniform distribution',\n                simulation_volatile: true,\n                arguments: [\n                    { name: 'min', description: 'Minimum', default: 0 },\n                    { name: 'max', description: 'Maximum', default: 1 },\n                ],\n                fn: this.uniformvalue.bind(this),\n                category: ['RiskAMP Random Distributions'],\n                extension: true,\n            },\n            BetaValue: {\n                description: 'Returns a sample from the beta distribution',\n                simulation_volatile: true,\n                arguments: [\n                    { name: 'w', description: 'Shape Parameter' },\n                    { name: 'v', description: 'Shape Parameter' },\n                ],\n                fn: this.betavalue.bind(this),\n                category: ['RiskAMP Random Distributions'],\n                extension: true,\n            },\n            TruncatedNormalValue: {\n                description: 'Returns a sample from the normal distribution',\n                simulation_volatile: true,\n                arguments: [\n                    { name: 'mean', description: 'Mean', default: 0 },\n                    { name: 'stdev', description: 'Standard Deviation', default: 1 },\n                    { name: 'min', description: 'Minimum Value' },\n                    { name: 'max', description: 'Maximum Value' },\n                ],\n                fn: this.truncatednormalvalue.bind(this),\n                category: ['RiskAMP Random Distributions'],\n                extension: true,\n            },\n            NormalValue: {\n                description: 'Returns a sample from the normal distribution',\n                simulation_volatile: true,\n                arguments: [\n                    { name: 'mean', description: 'Mean', default: 0 },\n                    { name: 'stdev', description: 'Standard Deviation', default: 1 },\n                ],\n                fn: this.normalvalue.bind(this),\n                category: ['RiskAMP Random Distributions'],\n                extension: true,\n            },\n            PERTValue: {\n                description: 'Returns a sample from the beta-PERT distribution',\n                simulation_volatile: true,\n                arguments: [\n                    { name: 'min', description: 'Minimum Value', default: 0 },\n                    { name: 'mode', description: 'Most-Likely Value', default: 0.5 },\n                    { name: 'max', description: 'Maximum Value', default: 1 },\n                    { name: 'lambda', default: 4 },\n                ],\n                fn: this.pertvalue.bind(this),\n                category: ['RiskAMP Random Distributions'],\n                extension: true,\n            },\n            LognormalValue: {\n                description: 'Returns a sample from the log-normal distribution',\n                simulation_volatile: true,\n                arguments: [\n                    { name: 'mean', description: 'Mean of underlying Normal distribution', default: 0 },\n                    { name: 'stdev', description: 'Standard Deviation of underlying Normal distribution', default: 1 },\n                ],\n                fn: this.lognormalvalue.bind(this),\n                category: ['RiskAMP Random Distributions'],\n                extension: true,\n            },\n            SequentialValue: {\n                description: 'Returns one from a set of values, in order',\n                simulation_volatile: true,\n                arguments: [\n                    { name: 'values', description: 'Data Array' },\n                    { name: 'count', description: 'Count', default: 0 },\n                ],\n                fn: this.sequentialvalue.bind(this),\n                category: ['RiskAMP Random Distributions'],\n                extension: true,\n            },\n            IndexValue: {\n                description: 'Returns a monotonically increasing value',\n                simulation_volatile: true,\n                arguments: [\n                    { name: 'max', description: 'Maximum', default: 0 },\n                ],\n                fn: this.indexvalue.bind(this),\n                category: ['RiskAMP Random Distributions'],\n                extension: true,\n            },\n            'PERTValue.P': {\n                description: 'Returns a sample from the beta-PERT distribution',\n                simulation_volatile: true,\n                arguments: [\n                    { name: 'p10', description: '10th-Percentile Value', default: 0 },\n                    { name: 'mode', description: 'Most-Likely Value', default: 0.5 },\n                    { name: 'p90', description: '90th-Percentile Value', default: 1 },\n                    { name: 'lambda', default: 4 },\n                ],\n                fn: this.pertvalue_p.bind(this),\n                category: ['RiskAMP Random Distributions'],\n                extension: true,\n            },\n            TriangularValue: {\n                description: 'Returns a sample from the triangular distribution',\n                simulation_volatile: true,\n                arguments: [\n                    { name: 'min', description: 'Minimum Value', default: 0 },\n                    { name: 'mode', description: 'Most Likely Value', default: 0.5 },\n                    { name: 'max', description: 'Maximum Value', default: 1 },\n                ],\n                fn: this.triangularvalue.bind(this),\n                category: ['RiskAMP Random Distributions'],\n                extension: true,\n            },\n            // stats\n            SimulationCorrelation: {\n                description: 'Returns the correlation between the data from two cells in the simulation',\n                arguments: [\n                    { name: 'reference cell', description: 'Cell 1', collector: true },\n                    { name: 'reference cell', description: 'Cell 2', collector: true },\n                ],\n                fn: this.simulationcorrelation.bind(this),\n                category: ['RiskAMP Simulation Functions'],\n                extension: true,\n            },\n            SimulationRSquared: {\n                // tslint:disable-next-line:max-line-length\n                description: 'Returns the r-squared value (coefficient of correlation) of the data from two cells in the simulation',\n                arguments: [\n                    { name: 'dependent', description: 'Dependent Value', collector: true },\n                    { name: 'independent', description: 'Indepdendent Value', collector: true },\n                ],\n                fn: this.simulationrsquared.bind(this),\n                category: ['RiskAMP Simulation Functions'],\n                extension: true,\n            },\n            SimulationSkewness: {\n                description: 'Returns the skewness of data from this cell in the simulation',\n                arguments: [\n                    { name: 'reference cell', description: 'Source Cell', collector: true },\n                ],\n                fn: this.simulationskewness.bind(this),\n                category: ['RiskAMP Simulation Functions'],\n                extension: true,\n            },\n            SimulationKurtosis: {\n                description: 'Returns the kurtosis (peakedness) of data from this cell in the simulation',\n                arguments: [\n                    { name: 'reference cell', description: 'Source Cell', collector: true },\n                ],\n                fn: this.simulationkurtosis.bind(this),\n                category: ['RiskAMP Simulation Functions'],\n                extension: true,\n            },\n            SimulationPercentile: {\n                description: 'Returns the value of a cell at a given percentile in the simulation',\n                arguments: [\n                    { name: 'reference cell', description: 'Source Cell', collector: true },\n                    { name: 'percentile', description: 'Percentile (as %)' },\n                ],\n                fn: this.simulationpercentile.bind(this),\n                category: ['RiskAMP Simulation Functions'],\n                extension: true,\n            },\n            SimulationInterval: {\n                description: 'Returns the portion of results in the simulation that fall within some bounds (as a percentage)',\n                arguments: [\n                    { name: 'reference cell', description: 'Source Cell', collector: true },\n                    { name: 'min', description: 'Minimum Value (optional, inclusive)' },\n                    { name: 'max', description: 'Maximum Value (optional, inclusive)' },\n                ],\n                fn: this.simulationinterval.bind(this),\n                category: ['RiskAMP Simulation Functions'],\n                extension: true,\n            },\n            SimulationMean: {\n                description: 'Returns the mean (average) value of the data from this cell in the simulation',\n                arguments: [\n                    { name: 'reference cell', description: 'Source Cell', collector: true },\n                ],\n                fn: this.simulationmean.bind(this),\n                extension: true,\n                category: ['RiskAMP Simulation Functions'],\n            },\n            SimulationMedian: {\n                description: 'Returns the median value of the data from this cell in the simulation',\n                arguments: [\n                    { name: 'reference cell', description: 'Source Cell', collector: true },\n                ],\n                fn: this.simulationmedian.bind(this),\n                category: ['RiskAMP Simulation Functions'],\n                extension: true,\n            },\n            SimulationValue: {\n                description: 'Returns the value of this cell in the simulation at the given trial number',\n                arguments: [\n                    { name: 'reference cell', description: 'Source Cell', collector: true },\n                    { name: 'iteration', description: 'Trial Number' },\n                ],\n                fn: this.simulationvalue.bind(this),\n                category: ['RiskAMP Simulation Functions'],\n                extension: true,\n            },\n            SimulationValuesArray: {\n                description: 'Returns all values of this cell in the simulation, as an array',\n                arguments: [\n                    { name: 'reference cell', description: 'Source Cell', collector: true },\n                ],\n                fn: this.simulationvaluesarray.bind(this),\n                category: ['RiskAMP Simulation Functions'],\n                extension: true,\n            },\n            SortedSimulationIndex: {\n                description: 'Returns the iteration number of a sorted value for this cell',\n                arguments: [\n                    { name: 'reference cell', description: 'Source Cell', collector: true },\n                    { name: 'index', }\n                ],\n                fn: this.sortedsimulationindex.bind(this),\n                category: ['RiskAMP Simulation Functions'],\n                extension: true,\n            },\n            'SimulationValuesArray.Ordered': {\n                description: 'Returns all values of this cell in the simulation, as an array, ordered by a second cell',\n                arguments: [\n                    { name: 'reference cell', description: 'Source Cell', collector: true },\n                    { name: 'order by', description: 'Reference Cell for Ordering', collector: true },\n                ],\n                fn: this.simulationvaluesarray_ordered.bind(this),\n                category: ['RiskAMP Simulation Functions'],\n                extension: true,\n            },\n            SimulationMin: {\n                description: 'Returns the minimum value of the data from this cell in the simulation',\n                arguments: [\n                    { name: 'reference cell', description: 'Source Cell', collector: true },\n                ],\n                fn: this.simulationmin.bind(this),\n                category: ['RiskAMP Simulation Functions'],\n                extension: true,\n            },\n            SimulationMax: {\n                description: 'Returns the maximum value of the data from this cell in the simulation',\n                arguments: [\n                    { name: 'reference cell', description: 'Source Cell', collector: true },\n                ],\n                fn: this.simulationmax.bind(this),\n                category: ['RiskAMP Simulation Functions'],\n                extension: true,\n            },\n            SimulationStandardError: {\n                description: 'Returns the standard error of the mean from this cell in the simulation',\n                arguments: [\n                    { name: 'reference cell', collector: true },\n                ],\n                fn: this.simulationstandarderror.bind(this),\n                category: ['RiskAMP Simulation Functions'],\n                extension: true,\n            },\n            SimulationStandardDeviation: {\n                description: 'Returns the standard deviation of the data from this cell in the simulation',\n                arguments: [\n                    { name: 'reference cell', description: 'Source Cell', collector: true },\n                ],\n                fn: this.simulationstandarddeviation.bind(this),\n                category: ['RiskAMP Simulation Functions'],\n                extension: true,\n            },\n            SimulationVariance: {\n                description: 'Returns the variance of the data from this cell in the simulation',\n                arguments: [\n                    { name: 'reference cell', description: 'Source Cell', collector: true },\n                ],\n                fn: this.simulationvariance.bind(this),\n                category: ['RiskAMP Simulation Functions'],\n                extension: true,\n            },\n            // special\n            SimulationTrials: {\n                description: 'Returns the number of trials from the last simulation',\n                fn: this.simulationtrials.bind(this),\n                category: ['RiskAMP Simulation Functions'],\n                extension: true,\n            },\n            SimulationTime: {\n                description: 'Returns the elapsed time of the last simulation',\n                fn: this.simulationtime.bind(this),\n                category: ['RiskAMP Simulation Functions'],\n                extension: true,\n            },\n            // some extra random functions, available because we have the matrix classes\n            IsPosDef: {\n                description: 'Checks that a matrix is positive-definite',\n                arguments: [{ name: 'matrix' }],\n                fn: (mat) => {\n                    if (mat.some((arr) => {\n                        return arr.some((v) => typeof v !== 'number');\n                    }))\n                        return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.ValueError)();\n                    const m = riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.Matrix.FromArray(mat);\n                    return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.boolean, value: m.IsPosDef() };\n                },\n                extension: true,\n            },\n            MakePosDef: {\n                description: 'Returns a matrix that is positive-definite',\n                arguments: [{ name: 'matrix' }],\n                fn: (mat) => {\n                    if (mat.some((arr) => {\n                        return arr.some((v) => typeof v !== 'number');\n                    }))\n                        return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.ValueError)();\n                    const m = riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.Matrix.FromArray(mat).MakePosDef().ToArray();\n                    return m.map(row => row.map(value => {\n                        return {\n                            type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                            value,\n                        };\n                    }));\n                },\n                extension: true,\n            },\n            Cholesky: {\n                arguments: [{ name: 'matrix' }, { name: 'transpose', default: false }],\n                fn: (mat, transpose = false) => {\n                    const m = riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.Matrix.FromArray(mat).Cholesky(transpose).ToArray();\n                    return m.map(row => row.map(value => {\n                        return {\n                            type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                            value,\n                        };\n                    }));\n                },\n                extension: true,\n            },\n            EigenValues: {\n                description: 'Returns the eigenvalues of the matrix (as column vector)',\n                arguments: [{ name: 'matrix' }],\n                fn: (mat) => {\n                    if (mat.some((arr) => {\n                        return arr.some((v) => typeof v !== 'number');\n                    }))\n                        return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.ValueError)();\n                    const m = riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.Matrix.FromArray(mat);\n                    const e = m.EigenSystem();\n                    return [e.realvalues.map(value => {\n                            return {\n                                type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                                value,\n                            };\n                        })];\n                },\n                extension: true,\n            },\n            EigenVectors: {\n                description: 'Returns the eigenvectors of the matrix (as matrix)',\n                arguments: [{ name: 'matrix' }],\n                fn: (mat) => {\n                    if (mat.some((arr) => {\n                        return arr.some((v) => typeof v !== 'number');\n                    }))\n                        return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.ValueError)();\n                    const m = riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.Matrix.FromArray(mat);\n                    const e = m.EigenSystem();\n                    return e.vectors.map(vector => {\n                        return Array.from(vector).map(value => {\n                            return {\n                                type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                                value,\n                            };\n                        });\n                    });\n                },\n                extension: true,\n            },\n            MMult: {\n                description: 'Multiplies two matrices',\n                arguments: [{ name: 'Matrix 1' }, { name: 'Matrix 2' }],\n                fn: (a, b) => {\n                    var _a, _b;\n                    if (!a || !b)\n                        return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.ArgumentError)();\n                    const a_cols = a.length || 0;\n                    const a_rows = ((_a = a[0]) === null || _a === void 0 ? void 0 : _a.length) || 0;\n                    const b_cols = b.length || 0;\n                    const b_rows = ((_b = b[0]) === null || _b === void 0 ? void 0 : _b.length) || 0;\n                    if (!a_rows || !b_rows || !a_cols || !b_cols\n                        || a_rows !== b_cols || a_cols !== b_rows)\n                        return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.ValueError)();\n                    // this is backwards. why? because the arrays passed in \n                    // are column-major. instead of calling transpose three times\n                    // we can just switch around. intransitive property ftw!\n                    const ma = riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.Matrix.FromArray(a);\n                    const mb = riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.Matrix.FromArray(b);\n                    const m = mb.Multiply(ma).ToArray();\n                    return m.map(row => row.map(value => {\n                        return {\n                            type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                            value,\n                        };\n                    }));\n                }\n            },\n            MInverse: {\n                description: 'Returns the inverse matrix',\n                arguments: [{ name: 'Matrix' }],\n                fn: (a) => {\n                    try {\n                        const mat = riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.Matrix.FromArray(a).Transpose();\n                        const m = mat.Inverse().ToArray(true);\n                        return m.map(row => row.map(value => {\n                            return {\n                                type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                                value,\n                            };\n                        }));\n                    }\n                    catch (err) {\n                        console.warn(err);\n                        return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.ValueError)();\n                    }\n                }\n            },\n            // new stuff\n            'RiskAMP.Scale': {\n                description: 'Creates a uniform scale within a given range',\n                arguments: [{ name: 'min' }, { name: 'max' }],\n                fn: this.Scale.bind(this),\n                extension: true,\n            },\n            'RiskAMP.HistogramTable': {\n                description: 'Creates a histogram table from a source cell',\n                arguments: [{ name: 'reference cell', collector: true, }],\n                fn: this.HistogramTable.bind(this),\n                extension: true,\n            },\n            'RiskAMP.Permutation': {\n                description: 'Creates a random permutation of source data',\n                arguments: [{ name: 'range', boxed: true }],\n                fn: this.Permutation.bind(this),\n                extension: true,\n                simulation_volatile: true,\n            }\n        };\n    }\n    set seed(seed) {\n        riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.Random.Seed(seed);\n    }\n    /**\n     * returns the shape of the caller, in case it's an array.\n     * we can use this to allocate the response array to match.\n     */\n    CallerArea() {\n        var _a;\n        let rows = 1, columns = 1;\n        let cell;\n        if (this.address.sheet_id) {\n            for (const sheet of ((_a = this.model) === null || _a === void 0 ? void 0 : _a.sheets) || []) {\n                if (sheet.id === this.address.sheet_id) {\n                    if (sheet.cells.data[this.address.row]) {\n                        cell = sheet.cells.data[this.address.row][this.address.column];\n                    }\n                    break;\n                }\n            }\n        }\n        if (cell === null || cell === void 0 ? void 0 : cell.area) {\n            rows = cell.area.rows;\n            columns = cell.area.columns;\n        }\n        return { rows, columns };\n    }\n    CorrelateDistributions() {\n        for (const key of Object.keys(this.correlated_distributions)) {\n            const desc = this.correlated_distributions[key];\n            const distributions = desc.addresses.map((address) => {\n                return this.distributions[address.sheet_id || 0][address.column][address.row][address.call_index];\n            });\n            try {\n                const result = riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.CorrelateCDM(desc.correlation, distributions, true);\n                desc.addresses.forEach((address, index) => {\n                    this.distributions[address.sheet_id || 0][address.column][address.row][address.call_index] = result[index];\n                });\n            }\n            catch (err) {\n                // FIXME: put some zeros in there or something? (...)\n                console.warn(err);\n            }\n        }\n    }\n    /**\n     * creates space in the distributions array for this cell. each cell\n     * might have multiple distributions, so the value is an array.\n     */\n    InitDistribution() {\n        if (!this.address)\n            throw (new Error('invalid address'));\n        if (!this.address.sheet_id)\n            throw (new Error('address missing sheet ID'));\n        if (!this.distributions[this.address.sheet_id]) {\n            this.distributions[this.address.sheet_id] = [];\n        }\n        const sheet = this.distributions[this.address.sheet_id];\n        if (!sheet[this.address.column]) {\n            sheet[this.address.column] = [];\n        }\n        const column = sheet[this.address.column];\n        if (!column[this.address.row]) {\n            column[this.address.row] = [];\n        }\n        // let cell = column[this.address.row];\n        // if (!cell) cell = []; // ?? this is local... not sure what it's expected to do\n    }\n    StoreCellResults(address) {\n        // this is equivalent to \"add shared rs\"\n        if (!address)\n            address = this.address;\n        if (!address) {\n            return undefined;\n        }\n        if (!address.sheet_id) {\n            throw new Error('SCR called without sheet id');\n        }\n        if (!this.results[address.sheet_id])\n            this.results[address.sheet_id] = [];\n        if (!this.results[address.sheet_id][address.column])\n            this.results[address.sheet_id][address.column] = [];\n        const column = this.results[address.sheet_id][address.column];\n        if (!column[address.row]) {\n            column[address.row] = [];\n        }\n        const cell = column[address.row];\n        return cell;\n    }\n    // --- multivariate distributions --------------------------------------------\n    PrepMultivariate(range_of_values, correlation_matrix) {\n        if (!this.correlated_distributions[range_of_values]) {\n            // support lower-triangular\n            let correlation = riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.CDMatrix.FromArray(correlation_matrix);\n            if (!correlation.IsSymmetric()) {\n                for (let m = 1; m < correlation_matrix.length; m++) {\n                    for (let n = 0; n < m; n++) {\n                        if (correlation_matrix[m][n]) {\n                            console.warn('invalid lower-triangular matrix');\n                            break;\n                        }\n                    }\n                }\n                correlation = correlation.Symmetrize(true);\n            }\n            this.correlated_distributions[range_of_values] = {\n                correlation,\n                addresses: [],\n            };\n        }\n        this.correlated_distributions[range_of_values].addresses.push({\n            column: this.address.column,\n            row: this.address.row,\n            sheet_id: this.address.sheet_id,\n            call_index: this.call_index,\n        });\n        this.InitDistribution();\n    }\n    ValidateCorrelationMatrix(correlation_matrix) {\n        let correlation = riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.Matrix.FromArray(correlation_matrix);\n        if (!correlation.IsSymmetric()) {\n            correlation = correlation.Symmetrize(true);\n        }\n        if (correlation_matrix.some(row => row.some(value => typeof value !== 'number' && typeof value !== 'undefined'))\n            || !correlation.IsPosDef()) {\n            return false;\n        }\n        return true;\n    }\n    multivariate_normal(range_of_values, correlation_matrix, mean = 0, sd = 1) {\n        // this test (and all the other ones) is in the wrong order\n        if (this.state === SimulationState.Prep) {\n            this.PrepMultivariate(range_of_values, correlation_matrix);\n            this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index] =\n                riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.Normal(this.iterations, { mean, sd, lhs: this.lhs, ordered: true });\n        }\n        else if (this.state === SimulationState.Simulation) {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index][this.iteration] };\n        }\n        if (!this.ValidateCorrelationMatrix(correlation_matrix)) {\n            return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.DataError)();\n        }\n        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.Normal(1, { mean, sd })[0] };\n    }\n    multivariate_lognormal(range_of_values, correlation_matrix, mean = 0, sd = 1) {\n        if (this.state === SimulationState.Prep) {\n            this.PrepMultivariate(range_of_values, correlation_matrix);\n            this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index] =\n                riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.LogNormal(this.iterations, { mean, sd, lhs: this.lhs, ordered: true });\n        }\n        else if (this.state === SimulationState.Simulation) {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index][this.iteration] };\n        }\n        if (!this.ValidateCorrelationMatrix(correlation_matrix)) {\n            return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.DataError)();\n        }\n        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.LogNormal(1, { mean, sd })[0] };\n    }\n    multivariate_beta(range_of_values, correlation_matrix, a = 1, b = 2) {\n        if (this.state === SimulationState.Prep) {\n            this.PrepMultivariate(range_of_values, correlation_matrix);\n            this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index] =\n                riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.Beta(this.iterations, { a, b, lhs: this.lhs, ordered: true });\n        }\n        else if (this.state === SimulationState.Simulation) {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index][this.iteration] };\n        }\n        if (!this.ValidateCorrelationMatrix(correlation_matrix)) {\n            return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.DataError)();\n        }\n        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.Beta(1, { a, b })[0] };\n    }\n    multivariate_uniform(range_of_values, correlation_matrix, min = 0, max = 1) {\n        if (this.state === SimulationState.Prep) {\n            this.PrepMultivariate(range_of_values, correlation_matrix);\n            this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index] =\n                riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.Uniform(this.iterations, { min, max, lhs: this.lhs, ordered: true });\n        }\n        else if (this.state === SimulationState.Simulation) {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index][this.iteration] };\n        }\n        if (!this.ValidateCorrelationMatrix(correlation_matrix)) {\n            return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.DataError)();\n        }\n        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.Uniform(1, { min, max })[0] };\n    }\n    multivariate_pert(range_of_values, correlation_matrix, min = 0, mode = 0.5, max = 1, lambda = 4) {\n        if (this.state === SimulationState.Prep) {\n            this.PrepMultivariate(range_of_values, correlation_matrix);\n            this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index] =\n                riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.PERT(this.iterations, { a: min, b: max, c: mode, lambda, lhs: this.lhs, ordered: true });\n        }\n        else if (this.state === SimulationState.Simulation) {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index][this.iteration] };\n        }\n        if (!this.ValidateCorrelationMatrix(correlation_matrix)) {\n            return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.DataError)();\n        }\n        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.PERT(1, { a: min, b: max, c: mode, lambda })[0] };\n    }\n    multivariate_triangular(range_of_values, correlation_matrix, min = 0, mode = 0.5, max = 1) {\n        if (this.state === SimulationState.Prep) {\n            this.PrepMultivariate(range_of_values, correlation_matrix);\n            this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index] =\n                riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.Triangular(this.iterations, { a: min, b: max, c: mode, lhs: this.lhs, ordered: true });\n        }\n        else if (this.state === SimulationState.Simulation) {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index][this.iteration] };\n        }\n        if (!this.ValidateCorrelationMatrix(correlation_matrix)) {\n            return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.DataError)();\n        }\n        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.Triangular(1, { a: min, b: max, c: mode })[0] };\n    }\n    // --- univariate distributions ----------------------------------------------\n    uniformvalue(min = 0, max = 1) {\n        if (this.state === SimulationState.Prep) {\n            this.InitDistribution();\n            this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index] =\n                riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.Uniform(this.iterations, { min, max, lhs: this.lhs });\n        }\n        else if (this.state === SimulationState.Simulation) {\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                value: this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index][this.iteration]\n            };\n        }\n        return {\n            type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n            value: riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.Uniform(1, { min, max })[0]\n        };\n    }\n    bernoullivalue(p = .5) {\n        if (this.state === SimulationState.Prep) {\n            this.InitDistribution();\n            this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index] =\n                riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.Bernoulli(this.iterations, { p, lhs: this.lhs });\n        }\n        else if (this.state === SimulationState.Simulation) {\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                value: this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index][this.iteration]\n            };\n        }\n        return {\n            type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.boolean,\n            value: riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.Bernoulli(1, { p })[0]\n        };\n    }\n    // alias\n    probabilityvalue(p = .5) { return this.bernoullivalue(p); }\n    // new\n    sequentialvalue(data, count = 0) {\n        if (this.state === SimulationState.Prep) {\n            this.InitDistribution();\n        }\n        else if (this.state === SimulationState.Simulation) {\n            let index = this.iteration;\n            if (count > 0)\n                index = (this.iteration % count);\n            const rows = data[0].length;\n            const column = Math.floor(index / rows) % data.length;\n            const row = index % rows;\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                value: data[column][row]\n            };\n        }\n        return {\n            type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n            value: data[0][0]\n        };\n    }\n    // new\n    indexvalue(max = 0) {\n        if (this.state === SimulationState.Prep) {\n            this.InitDistribution();\n        }\n        else if (this.state === SimulationState.Simulation) {\n            if (max > 0) {\n                return {\n                    type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                    value: (this.iteration % max) + 1\n                };\n            }\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                value: this.iteration + 1\n            };\n        }\n        return {\n            type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n            value: 1\n        };\n    }\n    lognormalvalue(mean = 0, sd = 1) {\n        if (this.state === SimulationState.Prep) {\n            this.InitDistribution();\n            this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index] =\n                riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.LogNormal(this.iterations, { mean, sd, lhs: this.lhs });\n        }\n        else if (this.state === SimulationState.Simulation) {\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                value: this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index][this.iteration]\n            };\n        }\n        return {\n            type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n            value: riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.LogNormal(1, { mean, sd })[0]\n        };\n    }\n    truncatednormalvalue(mean = 0, sd = 1, min, max) {\n        if (this.state === SimulationState.Prep) {\n            this.InitDistribution();\n            this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index] =\n                riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.TruncatedNormal(this.iterations, { mean, sd, lhs: this.lhs, min, max });\n        }\n        else if (this.state === SimulationState.Simulation) {\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                value: this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index][this.iteration]\n            };\n        }\n        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.TruncatedNormal(1, { mean, sd, min, max })[0] };\n    }\n    normalvalue(mean = 0, sd = 1) {\n        if (this.state === SimulationState.Prep) {\n            this.InitDistribution();\n            this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index] =\n                riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.Normal(this.iterations, { mean, sd, lhs: this.lhs });\n        }\n        else if (this.state === SimulationState.Simulation) {\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                value: this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index][this.iteration]\n            };\n        }\n        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.Normal(1, { mean, sd })[0] };\n    }\n    pertvalue(min = 0, mode = .5, max = 1, lambda = 4) {\n        if (this.state === SimulationState.Prep) {\n            this.InitDistribution();\n            this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index] =\n                riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.PERT(this.iterations, { a: min, b: max, c: mode, lambda, lhs: this.lhs });\n        }\n        else if (this.state === SimulationState.Simulation) {\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                value: this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index][this.iteration]\n            };\n        }\n        return {\n            type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n            value: riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.PERT(1, { a: min, b: max, c: mode, lambda })[0]\n        };\n    }\n    pertvalue_p(p10 = 0, mode = .5, p90 = 1, lambda = 4) {\n        if (this.state === SimulationState.Prep) {\n            const parms = riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.P80Pert(p10, p90, mode, lambda);\n            this.InitDistribution();\n            this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index] =\n                riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.PERT(this.iterations, Object.assign(Object.assign({}, parms), { lambda, lhs: this.lhs }));\n        }\n        else if (this.state === SimulationState.Simulation) {\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                value: this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index][this.iteration]\n            };\n        }\n        const parms = riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.P80Pert(p10, p90, mode, lambda);\n        return {\n            type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n            value: riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.PERT(1, Object.assign(Object.assign({}, parms), { lambda }))[0]\n        };\n    }\n    /**\n     * unified function for distributions. it works, but all this indirection\n     * seems like wasted cycles. since this is interpreted, it's probably better\n     * to err on the side of extra code plus efficiency (not that any of this is\n     * all that efficient to begin with; no need to make it any worse).\n     */\n    CommonDistributionFunction(fun, instance, args) {\n        if (this.state === SimulationState.Prep) {\n            this.InitDistribution();\n            this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index] =\n                fun.apply(instance, [this.iterations].concat(args));\n        }\n        else if (this.state === SimulationState.Simulation) {\n            return this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index][this.iteration];\n        }\n        return fun.apply(instance, [1].concat(args))[0];\n    }\n    triangularvalue(min = 0, mode = .5, max = 1) {\n        // return this.CommonDistributionFunction(MC.Triangular, MC, [{a: min, b: max, c: mode, lhs: this.lhs}]);\n        if (this.state === SimulationState.Prep) {\n            this.InitDistribution();\n            this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index] =\n                riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.Triangular(this.iterations, { a: min, b: max, c: mode, lhs: this.lhs });\n        }\n        else if (this.state === SimulationState.Simulation) {\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                value: this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index][this.iteration]\n            };\n        }\n        return {\n            type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n            value: riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.Triangular(1, { a: min, b: max, c: mode })[0]\n        };\n    }\n    betavalue(a = 1, b = 1) {\n        if (this.state === SimulationState.Prep) {\n            this.InitDistribution();\n            this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index] =\n                riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.Beta(this.iterations, { a, b, lhs: this.lhs });\n        }\n        else if (this.state === SimulationState.Simulation) {\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                value: this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index][this.iteration]\n            };\n        }\n        return {\n            type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n            value: riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.Beta(1, { a, b })[0]\n        };\n    }\n    samplevalue(range) {\n        return this.uniformrangesample(range);\n    }\n    samplevalue_weighted(range, weights) {\n        // create a uniform distribution in {0,1}\n        // we're not caching. why not? because we want to support variable\n        // weights and values. not sure that that is a good idea, though.\n        // without caching this function is slow.\n        if (this.state === SimulationState.Prep) {\n            this.InitDistribution();\n            this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index] =\n                riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.Uniform(this.iterations, { min: 0, max: 1, lhs: this.lhs });\n        }\n        else {\n            const r = (this.state === SimulationState.Simulation) ?\n                this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index][this.iteration] :\n                riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.Uniform(1, { min: 0, max: 1 })[0];\n            // assume it's rectangular. if not, there's nothing we can do.\n            if (!range || !range.length) {\n                return {\n                    type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.undefined,\n                    value: undefined,\n                };\n            }\n            // FIXME: cache! [see above]\n            const sum = // SpreadsheetFunctions.sum(weights);\n             _treb_calculator_src_utilities__WEBPACK_IMPORTED_MODULE_1__.Flatten(weights).reduce((a, b) => {\n                if (typeof b === 'undefined')\n                    return a;\n                return a + Number(b);\n            }, 0);\n            const value = r * sum;\n            let step = 0;\n            for (let col = 0; col < range.length; col++) {\n                for (let row = 0; row < range[col].length; row++) {\n                    step += weights[col][row];\n                    if (step >= value) {\n                        return {\n                            type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                            value: range[col][row]\n                        };\n                    }\n                }\n            }\n        }\n        return {\n            type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n            value: range[0][0],\n        };\n    }\n    uniformrangesample(range) {\n        // create a uniform distribution in {0,1}\n        if (this.state === SimulationState.Prep) {\n            this.InitDistribution();\n            this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index] =\n                riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.Uniform(this.iterations, { min: 0, max: 1, lhs: this.lhs });\n        }\n        const r = (this.state === SimulationState.Simulation) ?\n            this.distributions[this.address.sheet_id || 0][this.address.column][this.address.row][this.call_index][this.iteration] :\n            riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.MC.Uniform(1, { min: 0, max: 1 })[0];\n        // assume it's rectangular. if not, there's nothing we can do.\n        if (!range || !range.length)\n            return {\n                type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.undefined,\n                value: undefined\n            };\n        // const count = range[0].length * range.length;\n        // const index = Math.floor(count * r);\n        const index = Math.floor(range[0].length * range.length * r);\n        // const column = index % range.length;\n        // const row = Math.floor(index / range.length);\n        // const val = range[column][row];\n        const value = range[index % range.length][Math.floor(index / range.length)] || '';\n        // FIXME: what should undefined look like?\n        return {\n            value,\n            type: (0,treb_base_types__WEBPACK_IMPORTED_MODULE_0__.GetValueType)(value),\n        };\n    }\n    // --- simulation functions --------------------------------------------------\n    simulationtrials() {\n        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: this.trials };\n    }\n    simulationtime() {\n        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: this.elapsed / 1000 };\n    }\n    simulationvaluesarray(data) {\n        if (this.state !== SimulationState.Null) {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: 0 };\n        }\n        if (!data || !data.length) {\n            return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.DataError)();\n        }\n        const result = [];\n        for (let i = 0; i < data.length; i++) {\n            result[i] = { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: data[i] };\n        }\n        return [result];\n    }\n    /**\n     * now defaults to ordering by source cell\n     * UPDATE: now does that properly. if there's no sort argument, use the\n     * source cell. if there's a source cell but no data, return an error.\n     */\n    simulationvaluesarray_ordered(data, order_by) {\n        if (this.state !== SimulationState.Null) {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: 0 };\n        }\n        if (!data || !data.length || (order_by && !order_by.length)) {\n            return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.DataError)();\n        }\n        if (!order_by) {\n            // can use a simpler sort method in this case\n            // be sure to copy so we don't munge the original data\n            return [Array.prototype.slice.call(data, 0).sort((a, b) => a - b).map(value => {\n                    return {\n                        type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                        value,\n                    };\n                })];\n        }\n        const tuples = Array.from(data).map((x, i) => [x, order_by[i]]);\n        tuples.sort((a, b) => a[1] - b[1]);\n        return [tuples.map((tuple) => {\n                return {\n                    type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                    value: tuple[0]\n                };\n            })];\n    }\n    simulationrsquared(dependent, independent) {\n        if (this.state !== SimulationState.Null) {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: 0 };\n        }\n        if (!dependent || !dependent.length || !independent || !independent.length) {\n            return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.DataError)();\n        }\n        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.Stats.R2(dependent, independent) };\n    }\n    simulationcorrelation(a, b) {\n        if (this.state !== SimulationState.Null) {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: 0 };\n        }\n        if (!a || !a.length || !b || !b.length) {\n            return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.DataError)();\n        }\n        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.Stats.Correlation(a, b) };\n    }\n    sortedsimulationindex(data, index = 1) {\n        if (this.state !== SimulationState.Null) {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: 0 };\n        }\n        if (!data || !data.length) {\n            return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.DataError)();\n        }\n        if (index < 1 || index > data.length) {\n            return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.ArgumentError)();\n        }\n        const pairs = Array.from(data).map((x, i) => [x, i + 1]);\n        pairs.sort((a, b) => a[0] - b[0]);\n        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: pairs[index - 1][1] };\n    }\n    simulationvalue(data, index = 1) {\n        if (this.state !== SimulationState.Null) {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: 0 };\n        }\n        if (!data || !data.length) {\n            return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.DataError)();\n        }\n        if (index < 1 || index > data.length) {\n            return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.ArgumentError)();\n        }\n        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: data[index - 1] };\n    }\n    simulationpercentile(data, percentile = .5) {\n        if (this.state !== SimulationState.Null) {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: 0 };\n        }\n        if (!data || !data.length) {\n            return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.DataError)();\n        }\n        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.Stats.Percentile(data, percentile) };\n    }\n    simulationstandarddeviation(data) {\n        if (this.state !== SimulationState.Null) {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: 0 };\n        }\n        if (!data || !data.length) {\n            return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.DataError)();\n        }\n        const stats = riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.Stats.Statistics(data);\n        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: stats.stdev };\n    }\n    simulationvariance(data) {\n        if (this.state !== SimulationState.Null) {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: 0 };\n        }\n        if (!data || !data.length) {\n            return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.DataError)();\n        }\n        const stats = riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.Stats.Statistics(data);\n        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: stats.variance };\n    }\n    simulationskewness(data) {\n        if (this.state !== SimulationState.Null) {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: 0 };\n        }\n        if (!data || !data.length) {\n            return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.DataError)();\n        }\n        const stats = riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.Stats.Statistics(data);\n        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: stats.skewness };\n    }\n    simulationkurtosis(data) {\n        if (this.state !== SimulationState.Null) {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: 0 };\n        }\n        if (!data || !data.length) {\n            return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.DataError)();\n        }\n        const stats = riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.Stats.Statistics(data);\n        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: stats.kurtosis };\n    }\n    simulationinterval(data, min, max) {\n        if (this.state !== SimulationState.Null) {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: 0 };\n        }\n        if (!data || !data.length) {\n            return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.DataError)();\n        }\n        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: riskampjs_mc__WEBPACK_IMPORTED_MODULE_2__.Stats.Interval({ data, min, max }) };\n    }\n    simulationstandarderror(data) {\n        if (this.state !== SimulationState.Null) {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: 0 };\n        }\n        if (!data || !data.length) {\n            return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.DataError)();\n        }\n        let sum = 0;\n        let variance = 0;\n        // start with mean\n        for (const value of data) {\n            sum += (value || 0);\n        }\n        const mean = sum / data.length;\n        // next calc variance\n        for (const value of data) {\n            const deviation = value - mean;\n            variance += (deviation * deviation);\n        }\n        return {\n            type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n            value: (Math.sqrt(variance / data.length)) / Math.sqrt(data.length),\n        };\n    }\n    simulationmin(data) {\n        if (this.state !== SimulationState.Null) {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: 0 };\n        }\n        if (!data || !data.length) {\n            return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.DataError)();\n        }\n        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: Math.min.apply(0, data) };\n    }\n    simulationmax(data) {\n        if (this.state !== SimulationState.Null) {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: 0 };\n        }\n        if (!data || !data.length) {\n            return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.DataError)();\n        }\n        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: Math.max.apply(0, data) };\n    }\n    simulationmean(data) {\n        if (this.state !== SimulationState.Null) {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: 0 };\n        }\n        if (!data || !data.length) {\n            return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.DataError)();\n        }\n        // return data.reduce((a: number, b: number) => a + b, 0) / data.length;\n        let sum = 0;\n        for (const value of data)\n            sum += value;\n        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: sum / data.length };\n    }\n    simulationmedian(data) {\n        if (this.state !== SimulationState.Null) {\n            return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: 0 };\n        }\n        if (!data || !data.length) {\n            return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.DataError)();\n        }\n        const copy = data.filter((element) => typeof element === 'number' ? element : 0); // when would this happen? \n        copy.sort((a, b) => a - b);\n        return { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: copy[Math.round(copy.length / 2)] };\n    }\n    Permutation(range) {\n        if (!range) {\n            // special case, no argument\n            const { rows, columns } = this.CallerArea();\n            const count = rows * columns;\n            if (count <= 0) {\n                return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.ArgumentError)();\n            }\n            const shuffled = ShuffledIntegers(count);\n            const result = [];\n            let index = 0;\n            for (let c = 0; c < columns; c++) {\n                const column = [];\n                for (let r = 0; r < rows; r++) {\n                    column.push({ type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: shuffled[index++] });\n                }\n                result.push(column);\n            }\n            return result;\n        }\n        if (Array.isArray(range)) {\n            const rows = range.length;\n            const cols = range[0].length;\n            if (!rows || !cols) {\n                return (0,_treb_calculator_src_function_error__WEBPACK_IMPORTED_MODULE_3__.ArgumentError)();\n            }\n            const flat = range.reduce((a, arr) => arr.concat(a), []);\n            const count = rows * cols;\n            if (flat.length !== count) {\n                console.info('invalid?', count, range, flat);\n                throw new Error('invalid length');\n            }\n            const shuffled = ShuffledIntegers(count);\n            const result = [];\n            let index = 0;\n            // is this backwards? somehow it still seems to work...\n            for (let r = 0; r < rows; r++) {\n                const row = [];\n                for (let c = 0; c < cols; c++) {\n                    const x = shuffled[index++];\n                    row.push(Object.assign({}, flat[x]));\n                }\n                result.push(row);\n            }\n            return result;\n        }\n        else {\n            return Object.assign({}, range); // single value?\n        }\n    }\n    Scale(min, max) {\n        /*\n        let rows = 1, columns = 1;\n    \n        let cell: Cell|undefined;\n    \n        if (this.address.sheet_id) {\n          for (const sheet of this.model?.sheets || []) {\n            if (sheet.id === this.address.sheet_id) {\n              if (sheet.cells.data[this.address.row]) {\n                cell = sheet.cells.data[this.address.row][this.address.column];\n              }\n              break;\n            }\n          }\n        }\n    \n        if (!cell) { return ArgumentError(); }\n    \n        if (cell.area) {\n          const area = new Area(cell.area.start, cell.area.end);\n          rows = area.rows;\n          columns = area.columns;\n        }\n        */\n        const { rows, columns } = this.CallerArea();\n        const length = Math.max(rows, columns);\n        const scale = min > max ?\n            (0,treb_utils__WEBPACK_IMPORTED_MODULE_4__.Scale)(max, min, length - 1, true) :\n            (0,treb_utils__WEBPACK_IMPORTED_MODULE_4__.Scale)(min, max, length - 1, true);\n        let base = scale.min;\n        // const result: Array<number|undefined>[] = [[]];\n        const result = [[]];\n        if (scale.count < length - 1) {\n            base = scale.min - (Math.floor((length - 1 - scale.count) / 2)) * scale.step;\n        }\n        if (min > max) {\n            for (let i = 0; i < length; i++) {\n                const bucket = base + i * scale.step;\n                result[0][length - 1 - i] = { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: bucket };\n            }\n        }\n        else {\n            for (let i = 0; i < length; i++) {\n                const bucket = base + i * scale.step;\n                result[0][i] = { type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number, value: bucket };\n            }\n        }\n        return rows < columns ? _treb_calculator_src_utilities__WEBPACK_IMPORTED_MODULE_1__.Transpose2(result) : result;\n    }\n    HistogramTable(reference) {\n        // this function used to rely on the Cell structure being passed\n        // as the address. we used to do that, in error. while we might want\n        // to bring it back, for the time being we will look up in the model\n        // instead.\n        const { rows, columns } = this.CallerArea();\n        const length = Math.max(rows, columns);\n        const depth = Math.min(rows, columns);\n        if (Array.isArray(reference) || reference instanceof Float64Array || reference instanceof Float32Array) {\n            if (reference.length <= 1) {\n                return {\n                    type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                    value: 0,\n                }; // ??\n            }\n            if (!Array.isArray(reference)) {\n                reference = Array.prototype.slice.call(reference);\n            }\n            reference.sort((a, b) => a - b);\n            const min = reference[0] || 0;\n            const max = reference[reference.length - 1] || 0;\n            if (max === min) {\n                // ...\n                return {\n                    type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                    value: 0,\n                };\n            }\n            let result = [[], []];\n            const scale = (0,treb_utils__WEBPACK_IMPORTED_MODULE_4__.Scale)(min, max, length, true);\n            let base = scale.min;\n            let index = 0;\n            if (scale.count < length) {\n                base = scale.min - (Math.ceil(length - scale.count) / 2) * scale.step;\n            }\n            for (let i = 0; i < length; i++) {\n                // count from (last) to (next)\n                const bucket = base + (i + 1) * scale.step;\n                let count = 0;\n                for (; index < reference.length && reference[index] < bucket; index++, count++) { /* */ }\n                result[1][i] = {\n                    type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                    value: count,\n                }; // (this.trials || 0);\n                result[0][i] = {\n                    type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n                    value: bucket,\n                };\n            }\n            if (depth === 1) {\n                result = [result[1]];\n            }\n            return (columns > rows) ? _treb_calculator_src_utilities__WEBPACK_IMPORTED_MODULE_1__.Transpose2(result) : result;\n        }\n        return {\n            type: treb_base_types__WEBPACK_IMPORTED_MODULE_0__.ValueType.number,\n            value: 0,\n        };\n    }\n}\n\n\n//# sourceURL=webpack://treb/./treb-mc/src/simulation-model.ts?");

/***/ }),

/***/ "./treb-mc/src/worker.ts":
/*!*******************************!*\
  !*** ./treb-mc/src/worker.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WorkerImpl\": () => (/* binding */ WorkerImpl)\n/* harmony export */ });\n/* harmony import */ var treb_base_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! treb-base-types */ \"./treb-base-types/src/index.ts\");\n/* harmony import */ var treb_grid_src_types_sheet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! treb-grid/src/types/sheet */ \"./treb-grid/src/types/sheet.ts\");\n/* harmony import */ var treb_grid_src_types_named_range__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! treb-grid/src/types/named_range */ \"./treb-grid/src/types/named_range.ts\");\n/* harmony import */ var _simulation_calculator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./simulation-calculator */ \"./treb-mc/src/simulation-calculator.ts\");\n/* harmony import */ var _treb_calculator_src_dag_graph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../treb-calculator/src/dag/graph */ \"./treb-calculator/src/dag/graph.ts\");\n/**\n * worker for simulation\n */\n\n\n\n\n\nclass WorkerImpl {\n    constructor(base_worker) {\n        this.base_worker = base_worker;\n        this.trials = 0;\n        this.lhs = false;\n        this.data_model = {\n            active_sheet: treb_grid_src_types_sheet__WEBPACK_IMPORTED_MODULE_1__.Sheet.Blank({}),\n            sheets: [treb_grid_src_types_sheet__WEBPACK_IMPORTED_MODULE_1__.Sheet.Blank({})],\n            named_ranges: new treb_grid_src_types_named_range__WEBPACK_IMPORTED_MODULE_2__.NamedRangeCollection(),\n            macro_functions: {},\n        };\n        this.screen_updates = false;\n        this.calculator = new _simulation_calculator__WEBPACK_IMPORTED_MODULE_3__.MCCalculator();\n        this.start_time = 0;\n        this.additional_cells = [];\n        /** iteration count for screen updating */\n        this.iteration = 0;\n    }\n    Timestamp() {\n        if (self.performance)\n            return performance.now();\n        return Date.now();\n    }\n    OnMessage(event) {\n        const message = event.data;\n        if (!message)\n            return;\n        switch (message.type) {\n            /*\n            case WorkerMessageType.Extend:\n              if (message.data) {\n                if (message.data.path) {\n                  (self as any).importScripts(message.data.path);\n                  if ((self as any).RegisterCallback) {\n                    (self as any).RegisterCallback.call(this);\n                  }\n                }\n              }\n              break;\n              */\n            case 'configure':\n                if (message.locale && message.locale !== treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Localization.locale) {\n                    treb_base_types__WEBPACK_IMPORTED_MODULE_0__.Localization.UpdateLocale(message.locale);\n                    this.calculator.UpdateLocale();\n                }\n                this.data_model.sheets = message.sheets.map((sheet) => treb_grid_src_types_sheet__WEBPACK_IMPORTED_MODULE_1__.Sheet.FromJSON(sheet, {}));\n                this.data_model.active_sheet = this.data_model.sheets[0];\n                if (message.additional_cells) {\n                    this.additional_cells = message.additional_cells;\n                }\n                this.data_model.named_ranges.Deserialize(message.named_ranges); // implicit reset\n                this.data_model.macro_functions = {};\n                if (message.macro_functions) {\n                    for (const macro_function of message.macro_functions) {\n                        this.data_model.macro_functions[macro_function.name.toUpperCase()] = macro_function;\n                    }\n                }\n                // seed is optional. we will use it in the Init method, so we\n                // store it before running, but then we will drop it.\n                this.seed = message.seed;\n                // ... macro functions ...\n                break;\n            case 'step':\n                this.SimulationStep();\n                break;\n            case 'start':\n                this.trials = message.trials || 1000;\n                this.lhs = !!message.lhs;\n                this.screen_updates = !!message.screen_updates;\n                this.Start();\n                break;\n        }\n    }\n    Post(message, transfer) {\n        this.base_worker.postMessage(message, transfer);\n    }\n    /* *\n     * generates flattened results suitable for passing to the main thread.\n     * FIXME: move to calculator so we can hide simulation_model\n     * /\n    protected FlattenedResults(){\n  \n      // flatten into buffers\n      const flattened: any[] = [];\n  \n      // tslint:disable-next-line:forin\n      for (const c in this.calculator.simulation_model.results) {\n        const column = this.calculator.simulation_model.results[c];\n  \n        // tslint:disable-next-line:forin\n        for (const r in column) {\n          flattened.push(PackResults.PackOne({\n            row: Number(r), column: Number(c), data: column[r] }).buffer);\n        }\n      }\n  \n      return flattened;\n    }\n    */\n    /**\n     * runs a single step in a stepped simulation (used for screen updates)\n     */\n    SimulationStep() {\n        if (this.iteration >= this.trials)\n            return;\n        this.calculator.SimulationTrial(this.iteration);\n        const percent_complete = Math.floor(this.iteration / this.trials * 100);\n        // last one\n        if (++this.iteration === this.trials) {\n            this.Finish();\n            return;\n        }\n        // otherwise, send intermediate\n        // we shouldn't have to send this; we should be able to build it up.\n        // not sure that it's worth writing the code to do that, though.\n        const flattened = this.calculator.FlattenedResults();\n        const elapsed = this.Timestamp() - this.start_time;\n        this.Post({\n            type: 'update',\n            percent_complete,\n            cells: this.data_model.active_sheet.cells.toJSON(),\n            trial_data: {\n                results: flattened,\n                trials: this.iteration,\n                elapsed,\n            },\n        }, flattened);\n    }\n    /**\n     * starts the simulation. for screen updating, this will just run the\n     * first iteration and then wait for subsequent calls. otherwise it\n     * will loop through iterations until complete, and then call Finish().\n     */\n    Start() {\n        if (!this.trials) {\n            throw (new Error('invalid trial count'));\n        }\n        else {\n            // console.info(`running simulation with ${this.trials} trials, lhs=${this.lhs}${this.screen_updates ? ' (stepped)' : ''}`);\n        }\n        this.start_time = this.Timestamp(); // performance.now();\n        // first, full calc\n        const status = this.calculator.InitSimulation(this.trials, this.lhs, this.data_model, this.additional_cells, this.seed);\n        this.seed = undefined; // clear \n        if (status !== _treb_calculator_src_dag_graph__WEBPACK_IMPORTED_MODULE_4__.GraphStatus.OK)\n            throw (new Error('graph failed'));\n        let percent_complete = 0;\n        if (this.screen_updates) {\n            this.iteration = 0;\n            this.SimulationStep(); // first iteration\n        }\n        else {\n            for (let i = 0; i < this.trials; i++) {\n                this.calculator.SimulationTrial(i);\n                const p = Math.floor(i / this.trials * 100);\n                if (p !== percent_complete) {\n                    percent_complete = p;\n                    this.Post({\n                        type: 'progress',\n                        percent_complete,\n                    });\n                }\n            }\n            this.Finish();\n        }\n    }\n    /**\n     * simulation is complete; post a last progress message, then\n     * send results.\n     */\n    Finish() {\n        // because this will never get sent (floor):\n        this.Post({\n            type: 'progress',\n            percent_complete: 100,\n        });\n        // now send results\n        const flattened = this.calculator.FlattenedResults();\n        const elapsed = this.Timestamp() - this.start_time;\n        // FIXME: for IE (and edge?) we are probably going to have to convert\n        // this to a non-typed array, or it will pass through all the indexes\n        // return w/ transfer\n        this.Post({\n            type: 'complete',\n            trial_data: {\n                results: flattened,\n                trials: this.trials,\n                elapsed,\n            },\n        }, flattened);\n    }\n}\n\n\n//# sourceURL=webpack://treb/./treb-mc/src/worker.ts?");

/***/ }),

/***/ "./treb-parser/src/csv-parser.ts":
/*!***************************************!*\
  !*** ./treb-parser/src/csv-parser.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ParseCSV\": () => (/* binding */ ParseCSV)\n/* harmony export */ });\nvar ParseState;\n(function (ParseState) {\n    ParseState[ParseState[\"default\"] = 0] = \"default\";\n    ParseState[ParseState[\"quoted\"] = 1] = \"quoted\";\n})(ParseState || (ParseState = {}));\n/**\n * csv parser, following (largely) RFC4180 rules, with some extensions.\n * specifically:\n *\n * - lines should end with CRLF, but we support CR\n * - we do not support header (atm)\n * - variable-length records are supported\n * - any field may be quoted\n * - quoted fields can contain newlines and commas\n * - use two double-quotes to escape a double quote\n *\n */\nconst ParseCSV = (text, delimiter = ',') => {\n    let state = ParseState.default;\n    let record = [];\n    let field = '';\n    const records = [];\n    const length = text.length;\n    if (/[\\r\\n\"]/.test(delimiter)) {\n        throw new Error('invalid delimiter');\n    }\n    for (let i = 0; i < length; i++) {\n        const char = text[i];\n        if (state === ParseState.default) {\n            switch (char) {\n                case delimiter:\n                    record.push(field);\n                    field = '';\n                    break;\n                case '\\r':\n                    // naked (non-quoted) \\r without immediate \\n is illegal\n                    // if (i + 1 < length && text[i + 1] === '\\n') i++; // drop into next block\n                    // else\n                    break;\n                case '\\n':\n                    record.push(field);\n                    field = '';\n                    records.push(record);\n                    record = [];\n                    break;\n                case '\"':\n                    // we're allowing unescaped double-quotes in non-quoted fields\n                    if (field.length === 0) {\n                        state = ParseState.quoted;\n                    }\n                    else {\n                        field += char;\n                    }\n                    break;\n                default:\n                    field += char;\n                    break;\n            }\n        }\n        else {\n            if (char === '\"') {\n                if (i + 1 < length && text[i + 1] === '\"') {\n                    field += '\"';\n                    i++;\n                }\n                else {\n                    state = ParseState.default;\n                }\n            }\n            else\n                field += char;\n        }\n    }\n    // we're at the end. this might be a blank line at the end of the\n    // file, or it might be the end of the last record. let's make the\n    // simplifying assumption that we can drop a blank line, instead\n    // of treating it as a record with one zero-length field.\n    if (record.length || field.length) {\n        record.push(field);\n        records.push(record);\n    }\n    return records;\n};\n\n\n//# sourceURL=webpack://treb/./treb-parser/src/csv-parser.ts?");

/***/ }),

/***/ "./treb-parser/src/index.ts":
/*!**********************************!*\
  !*** ./treb-parser/src/index.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ArgumentSeparatorType\": () => (/* reexport safe */ _parser_types__WEBPACK_IMPORTED_MODULE_0__.ArgumentSeparatorType),\n/* harmony export */   \"DecimalMarkType\": () => (/* reexport safe */ _parser_types__WEBPACK_IMPORTED_MODULE_0__.DecimalMarkType),\n/* harmony export */   \"IllegalSheetNameRegex\": () => (/* reexport safe */ _parser__WEBPACK_IMPORTED_MODULE_1__.IllegalSheetNameRegex),\n/* harmony export */   \"Parser\": () => (/* reexport safe */ _parser__WEBPACK_IMPORTED_MODULE_1__.Parser),\n/* harmony export */   \"QuotedSheetNameRegex\": () => (/* reexport safe */ _parser__WEBPACK_IMPORTED_MODULE_1__.QuotedSheetNameRegex),\n/* harmony export */   \"ParseCSV\": () => (/* reexport safe */ _csv_parser__WEBPACK_IMPORTED_MODULE_2__.ParseCSV)\n/* harmony export */ });\n/* harmony import */ var _parser_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parser-types */ \"./treb-parser/src/parser-types.ts\");\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parser */ \"./treb-parser/src/parser.ts\");\n/* harmony import */ var _csv_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./csv-parser */ \"./treb-parser/src/csv-parser.ts\");\n\n\n\n\n\n//# sourceURL=webpack://treb/./treb-parser/src/index.ts?");

/***/ }),

/***/ "./treb-parser/src/parser-types.ts":
/*!*****************************************!*\
  !*** ./treb-parser/src/parser-types.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ArgumentSeparatorType\": () => (/* binding */ ArgumentSeparatorType),\n/* harmony export */   \"DecimalMarkType\": () => (/* binding */ DecimalMarkType)\n/* harmony export */ });\n/**\n * argument separator type for i18n\n */\nvar ArgumentSeparatorType;\n(function (ArgumentSeparatorType) {\n    ArgumentSeparatorType[\"Comma\"] = \",\";\n    ArgumentSeparatorType[\"Semicolon\"] = \";\";\n})(ArgumentSeparatorType || (ArgumentSeparatorType = {}));\n/**\n * decimal mark for i18n\n */\nvar DecimalMarkType;\n(function (DecimalMarkType) {\n    DecimalMarkType[\"Period\"] = \".\";\n    DecimalMarkType[\"Comma\"] = \",\";\n})(DecimalMarkType || (DecimalMarkType = {}));\n\n\n//# sourceURL=webpack://treb/./treb-parser/src/parser-types.ts?");

/***/ }),

/***/ "./treb-parser/src/parser.ts":
/*!***********************************!*\
  !*** ./treb-parser/src/parser.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"QuotedSheetNameRegex\": () => (/* binding */ QuotedSheetNameRegex),\n/* harmony export */   \"IllegalSheetNameRegex\": () => (/* binding */ IllegalSheetNameRegex),\n/* harmony export */   \"Parser\": () => (/* binding */ Parser)\n/* harmony export */ });\n/* harmony import */ var _parser_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parser-types */ \"./treb-parser/src/parser-types.ts\");\n\n/**\n * regex determines if a sheet name requires quotes. centralizing\n * this to simplify maintenance and reduce overlap/errors\n */\nconst QuotedSheetNameRegex = /[\\s-+=<>!()]/;\n/**\n * similarly, illegal sheet name. we don't actually handle this in\n * the parser, but it seems like a reasonable place to keep this\n * definition.\n */\nconst IllegalSheetNameRegex = /['*\\\\]/;\nconst DOUBLE_QUOTE = 0x22; // '\"'.charCodeAt(0);\nconst SINGLE_QUOTE = 0x27; // `'`.charCodeAt(0);\nconst NON_BREAKING_SPACE = 0xa0;\nconst SPACE = 0x20;\nconst TAB = 0x09;\nconst CR = 0x0a;\nconst LF = 0x0d;\nconst ZERO = 0x30;\nconst NINE = 0x39;\nconst PERIOD = 0x2e;\nconst PLUS = 0x2b;\nconst MINUS = 0x2d;\nconst OPEN_PAREN = 0x28;\nconst CLOSE_PAREN = 0x29;\nconst COMMA = 0x2c;\nconst PERCENT = 0x25;\nconst UNDERSCORE = 0x5f;\nconst DOLLAR_SIGN = 0x24;\nconst OPEN_BRACE = 0x7b;\nconst CLOSE_BRACE = 0x7d;\nconst EXCLAMATION_MARK = 0x21;\n// const COLON = 0x3a; // became an operator\nconst SEMICOLON = 0x3b;\nconst UC_A = 0x41;\nconst LC_A = 0x61;\nconst UC_E = 0x45;\nconst LC_E = 0x65;\nconst UC_Z = 0x5a;\nconst LC_Z = 0x7a;\nconst ACCENTED_RANGE_START = 192;\nconst ACCENTED_RANGE_END = 312;\n/**\n * precedence map\n */\nconst binary_operators_precendence = {\n    '==': 6,\n    '!=': 6,\n    '<>': 6,\n    '=': 6,\n    '<': 7,\n    '>': 7,\n    '<=': 7,\n    '>=': 7,\n    '+': 9,\n    '-': 9,\n    '&': 9,\n    '*': 10,\n    '/': 10,\n    '^': 11,\n    ':': 13, // range operator\n};\n/**\n * binary ops are sorted by length so we can compare long ops first\n */\nconst binary_operators = Object.keys(binary_operators_precendence).sort((a, b) => b.length - a.length);\n/**\n * unary operators. atm we have no precedence issues, unary operators\n * always have absolute precedence. (for numbers, these are properly part\n * of the number, but consider `=-SUM(1,2)` -- this is an operator).\n */\nconst unary_operators = { '-': 100, '+': 100 };\n/**\n * parser for spreadsheet language.\n *\n * FIXME: this is stateless, think about exporting a singleton.\n *\n * (there is internal state, but it's only used during a Parse() call,\n * which runs synchronously). one benefit of using a singleton would be\n * consistency in decimal mark, we'd only have to set once.\n *\n * FIXME: split rendering into a separate class? would be a little cleaner.\n */\nclass Parser {\n    constructor() {\n        /**\n         * argument separator. this can be changed prior to parsing/rendering.\n         * FIXME: use an accessor to ensure type, outside of ts?\n         */\n        this.argument_separator = _parser_types__WEBPACK_IMPORTED_MODULE_0__.ArgumentSeparatorType.Comma;\n        /**\n         * decimal mark. this can be changed prior to parsing/rendering.\n         * FIXME: use an accessor to ensure type, outside of ts?\n         */\n        this.decimal_mark = _parser_types__WEBPACK_IMPORTED_MODULE_0__.DecimalMarkType.Period;\n        /**\n         * internal argument separator, as a number. this is set internally on\n         * parse call, following the argument_separator value.\n         */\n        this.argument_separator_char = COMMA;\n        /**\n         * internal decimal mark, as a number.\n         */\n        this.decimal_mark_char = PERIOD;\n        /**\n         * internal counter for incrementing IDs\n         */\n        this.id_counter = 0;\n        this.expression = '';\n        this.data = [];\n        this.index = 0;\n        this.length = 0;\n        /** success flag */\n        this.valid = true;\n        this.dependencies = {\n            addresses: {},\n            ranges: {},\n        };\n        // referenced addresses -- used to merge ranges/addresses, although I'm\n        // not sure that's actually all that useful\n        this.address_refcount = {};\n        /**\n         * full list of referenced addresses and ranges. we're adding this\n         * to support highlighting, for which we need multiple instances\n         * of a single address. the original dep list was used for graph dependencies,\n         * so we compressed the list.\n         *\n         * FIXME: use a single list, i.e. something like\n         *\n         *   address -> [instance, instance]\n         *\n         * because that's a big API change it's going to have to wait. for now,\n         * use a second list.\n         *\n         * UPDATE: adding (otherwise unused) tokens, which could be named ranges.\n         * in the future we may pass in a list of names at parse time, and resolve\n         * them; for now we are just listing names.\n         */\n        this.full_reference_list = [];\n    }\n    /**\n     * recursive tree walk.\n     *\n     * @param func function called on each node. for nodes that have children\n     * (operations, calls, groups) return false to skip the subtree, or true to\n     * traverse.\n     */\n    Walk(unit, func) {\n        switch (unit.type) {\n            case 'address':\n            case 'missing':\n            case 'literal':\n            case 'identifier':\n            case 'operator':\n                func(unit);\n                return;\n            case 'range':\n                if (func(unit)) {\n                    this.Walk(unit.start, func);\n                    this.Walk(unit.end, func);\n                }\n                return;\n            case 'binary':\n                if (func(unit)) {\n                    this.Walk(unit.left, func);\n                    this.Walk(unit.right, func);\n                }\n                return;\n            case 'unary':\n                if (func(unit)) {\n                    this.Walk(unit.operand, func);\n                }\n                return;\n            case 'group':\n                if (func(unit)) {\n                    unit.elements.forEach((element) => this.Walk(element, func));\n                }\n                return;\n            case 'call':\n                if (func(unit)) {\n                    unit.args.forEach((arg) => this.Walk(arg, func));\n                }\n        }\n    }\n    /** utility: transpose array */\n    Transpose(arr) {\n        const m = arr.length;\n        const transposed = [];\n        let n = 0;\n        for (let i = 0; i < m; i++) {\n            if (Array.isArray(arr[i])) {\n                n = Math.max(n, arr[i].length);\n            }\n        }\n        for (let i = 0; i < n; i++) {\n            transposed[i] = [];\n            for (let j = 0; j < m; j++) {\n                transposed[i][j] = arr[j][i];\n            }\n        }\n        return transposed;\n    }\n    /**\n     * renders the passed expression as a string.\n     * @param unit base expression\n     * @param offset offset for addresses, used to offset relative addresses\n     * (and ranges). this is for copy-and-paste or move operations.\n     * @param missing string to represent missing values (can be '', for functions)\n     */\n    Render(unit, offset = { rows: 0, columns: 0 }, missing = '(missing)', convert_decimal, convert_argument_separator) {\n        // use default separator, unless we're explicitly converting.\n        let separator = this.argument_separator + ' ';\n        if (convert_argument_separator === _parser_types__WEBPACK_IMPORTED_MODULE_0__.ArgumentSeparatorType.Comma) {\n            separator = ', ';\n        }\n        else if (convert_argument_separator === _parser_types__WEBPACK_IMPORTED_MODULE_0__.ArgumentSeparatorType.Semicolon) {\n            separator = '; ';\n        }\n        // this is only used if we're converting.\n        const decimal = convert_decimal === _parser_types__WEBPACK_IMPORTED_MODULE_0__.DecimalMarkType.Comma ? ',' : '.';\n        const decimal_rex = this.decimal_mark === _parser_types__WEBPACK_IMPORTED_MODULE_0__.DecimalMarkType.Comma ? /,/ : /\\./;\n        switch (unit.type) {\n            case 'address':\n                return this.AddressLabel(unit, offset);\n            case 'range':\n                return (this.AddressLabel(unit.start, offset) +\n                    ':' +\n                    this.AddressLabel(unit.end, offset));\n            case 'missing':\n                return missing;\n            case 'array':\n                // we have to transpose because we're column-major but the \n                // format is row-major\n                return '{' +\n                    this.Transpose(unit.values).map((row) => row.map((value) => {\n                        if (typeof value === 'string') {\n                            return '\"' + value + '\"';\n                        }\n                        return value;\n                    }).join(', ')).join('; ') + '}';\n            case 'binary':\n                return (this.Render(unit.left, offset, missing, convert_decimal, convert_argument_separator) +\n                    ' ' +\n                    unit.operator +\n                    ' ' +\n                    this.Render(unit.right, offset, missing, convert_decimal, convert_argument_separator));\n            case 'unary':\n                return (unit.operator +\n                    this.Render(unit.operand, offset, missing, convert_decimal, convert_argument_separator));\n            case 'literal':\n                if (typeof unit.value === 'string') {\n                    // escape any quotation marks in string\n                    return '\"' + unit.value.replace(/\"/g, '\"\"') + '\"';\n                }\n                else if (convert_decimal && typeof unit.value === 'number') {\n                    if (unit.text) {\n                        // here we want to translate the literal typed-in value.\n                        // users can type in a decimal point and possibly grouping.\n                        // if we are converting from dot to comma, we need to make\n                        // sure to remove any existing commas. for the time being\n                        // we will just remove them.\n                        // what about the alternate case? in that case, we're not allowing\n                        // users to type in groupings (I think), so we can skip that part.\n                        // ACTUALLY, we don't allow grouping at all. we normalize it\n                        // if you type in a number. why? consider functions, grouping\n                        // looks like parameter separation. so no.\n                        let text = unit.text;\n                        if (convert_decimal === _parser_types__WEBPACK_IMPORTED_MODULE_0__.DecimalMarkType.Comma &&\n                            this.decimal_mark === _parser_types__WEBPACK_IMPORTED_MODULE_0__.DecimalMarkType.Period) {\n                            text = text.replace(/,/g, ''); // remove grouping\n                        }\n                        return text.replace(decimal_rex, decimal);\n                    }\n                    else {\n                        // this always works because this function is guaranteed\n                        // to return value in dot-decimal format without separators.\n                        return unit.value.toString().replace(/\\./, decimal);\n                    }\n                }\n                else if (unit.text)\n                    return unit.text;\n                return unit.value.toString();\n            case 'identifier':\n                return unit.name;\n            case 'operator':\n                return '[' + unit.operator + ']'; // this should be invalid output\n            case 'group':\n                if (unit.explicit) {\n                    return ('(' +\n                        unit.elements\n                            .map((x) => this.Render(x, offset, missing, convert_decimal, convert_argument_separator))\n                            .join(separator) +\n                        ')');\n                }\n                else {\n                    return unit.elements\n                        .map((x) => this.Render(x, offset, missing, convert_decimal, convert_argument_separator))\n                        .join(separator);\n                }\n            case 'call':\n                return (unit.name +\n                    '(' +\n                    unit.args\n                        .map((x) => this.Render(x, offset, missing, convert_decimal, convert_argument_separator))\n                        .join(separator) +\n                    ')');\n        }\n        return '??';\n    }\n    /**\n     * parses expression and returns the root of the parse tree, plus a\n     * list of dependencies (addresses and ranges) found in the expression.\n     *\n     * NOTE that in the new address parsing structure, we will overlap ranges\n     * and addresses (range corners). this is OK because ranges are mapped\n     * to individual address dependencies. it's just sloppy (FIXME: refcount?)\n     */\n    Parse(expression) {\n        // normalize\n        expression = expression.trim();\n        // remove leading =\n        if (expression[0] === '=') {\n            expression = expression.substr(1).trim();\n        }\n        this.expression = expression;\n        this.data = [];\n        this.length = expression.length;\n        this.index = 0;\n        this.valid = true;\n        this.error_position = undefined;\n        this.error = undefined;\n        this.dependencies.addresses = {};\n        this.dependencies.ranges = {};\n        this.address_refcount = {};\n        this.full_reference_list = [];\n        // reset ID\n        this.id_counter = 0;\n        // set separator\n        switch (this.argument_separator) {\n            case _parser_types__WEBPACK_IMPORTED_MODULE_0__.ArgumentSeparatorType.Semicolon:\n                this.argument_separator_char = SEMICOLON;\n                break;\n            default:\n                this.argument_separator_char = COMMA;\n                break;\n        }\n        // and decimal mark\n        switch (this.decimal_mark) {\n            case _parser_types__WEBPACK_IMPORTED_MODULE_0__.DecimalMarkType.Comma:\n                this.decimal_mark_char = COMMA;\n                break;\n            default:\n                this.decimal_mark_char = PERIOD;\n                break;\n        }\n        // NOTE on this function: charCodeAt returns UTF-16. codePointAt returns\n        // unicode. length returns UTF-16 length. any characters that are not\n        // representable as a single character in UTF-16 will be 'the first unit\n        // of a surrogate pair...' and so on.\n        //\n        // we want UTF-16, not unicode. for the parser itself, we are only really\n        // looking for ASCII, so it's not material. for anything else, if we\n        // construct strings from the original data we want to map the UTF-16,\n        // otherwise we will construct the string incorrectly. this applies to\n        // strings, function names, and anything else.\n        //\n        // which is all a long way of saying, don't be tempted to replace this\n        // with codePointAt.\n        for (let i = 0; i < this.length; i++) {\n            this.data[i] = expression.charCodeAt(i);\n        }\n        const expr = this.ParseGeneric();\n        // remove extraneous addresses\n        // NOTE: we still may have duplicates that have different absolute/relative\n        // modifiers, e.g. C3 and $C$3 (and $C3 and C$3). not sure what we should\n        // do about that, since some consumers may consider these different -- we\n        // need to establish a contract about this\n        const addresses = {};\n        for (const key of Object.keys(this.dependencies.addresses)) {\n            if (this.address_refcount[key]) {\n                addresses[key] = this.dependencies.addresses[key];\n            }\n        }\n        this.dependencies.addresses = addresses;\n        return {\n            expression: expr || undefined,\n            valid: this.valid,\n            error: this.error,\n            error_position: this.error_position,\n            dependencies: this.dependencies,\n            separator: this.argument_separator,\n            decimal_mark: this.decimal_mark,\n            full_reference_list: this.full_reference_list.slice(0),\n        };\n    }\n    /** generates column label (\"A\") from column index (0-based) */\n    ColumnLabel(column) {\n        if (column === Infinity) {\n            return '';\n        }\n        let s = String.fromCharCode(65 + (column % 26));\n        while (column > 25) {\n            column = Math.floor(column / 26) - 1;\n            s = String.fromCharCode(65 + (column % 26)) + s;\n        }\n        return s;\n    }\n    /** generates address label (\"C3\") from address (0-based) */\n    AddressLabel(address, offset) {\n        let column = address.column;\n        if (!address.absolute_column && address.column !== Infinity)\n            column += offset.columns;\n        let row = address.row;\n        if (!address.absolute_row && address.row !== Infinity)\n            row += offset.rows;\n        if (row < 0 || column < 0 || (row === Infinity && column === Infinity))\n            return '#REF';\n        let label = '';\n        if (address.sheet) {\n            label = (QuotedSheetNameRegex.test(address.sheet) ?\n                '\\'' + address.sheet + '\\'' : address.sheet) + '!';\n        }\n        if (row === Infinity) {\n            return label +\n                (address.absolute_column ? '$' : '') +\n                this.ColumnLabel(column);\n        }\n        if (column === Infinity) {\n            return label +\n                (address.absolute_row ? '$' : '') +\n                (row + 1);\n        }\n        return (label +\n            (address.absolute_column ? '$' : '') +\n            this.ColumnLabel(column) +\n            (address.absolute_row ? '$' : '') +\n            (row + 1));\n    }\n    /**\n     * base parse routine; may recurse inside parens (either as grouped\n     * operations or in function arguments).\n     *\n     * @param exit exit on specific characters\n     */\n    ParseGeneric(exit = [0]) {\n        const stream = [];\n        for (; this.index < this.length;) {\n            const unit = this.ParseNext(stream.length === 0);\n            if (typeof unit === 'number') {\n                if (exit.some((test) => unit === test)) {\n                    break;\n                }\n                else if (unit === OPEN_PAREN) {\n                    // note that function calls are handled elsewhere,\n                    // so we only have to worry about grouping. parse\n                    // up to the closing paren...\n                    this.index++; // open paren\n                    const group = this.ParseGeneric([CLOSE_PAREN]);\n                    this.index++; // close paren\n                    // and wrap up in a group element to prevent reordering.\n                    // flag indicates that this is a user grouping, not ours\n                    // skip nulls\n                    if (group) {\n                        stream.push({\n                            type: 'group',\n                            id: this.id_counter++,\n                            elements: [group],\n                            explicit: true,\n                        });\n                    }\n                }\n                else {\n                    // this can probably move to PNext? except for the test\n                    // on looking for a binary operator? (...)\n                    const operator = this.ConsumeOperator();\n                    if (operator)\n                        stream.push(operator);\n                    else {\n                        this.error = `unexpected character [1]: ${String.fromCharCode(unit)}, ${unit}`;\n                        this.valid = false;\n                        this.index++;\n                    }\n                }\n            }\n            else {\n                stream.push(unit);\n            }\n        }\n        if (stream.length === 0)\n            return null;\n        if (stream.length === 1)\n            return stream[0];\n        // fix ordering of binary operations based on precedence; also\n        // convert and validate ranges\n        return this.BinaryToRange(this.ArrangeUnits(stream));\n    }\n    /**\n     * helper function, @see BinaryToRange\n     * @param unit\n     * @returns\n     */\n    UnitToAddress(unit) {\n        // console.info(\"U2\", unit);\n        // for literals, only numbers are valid\n        if (unit.type === 'literal') {\n            if (typeof unit.value === 'number' && unit.value > 0 && !/\\./.test(unit.text || '')) {\n                return {\n                    type: 'address',\n                    position: unit.position,\n                    label: unit.value.toString(),\n                    row: unit.value - 1,\n                    id: this.id_counter++,\n                    column: Infinity,\n                };\n            }\n        }\n        else {\n            // UPDATE: sheet names... we may actually need a subparser for this?\n            // or can we do it with a regex? (...)\n            let sheet;\n            let name = unit.name;\n            const tokens = name.split('!');\n            if (tokens.length > 1) {\n                sheet = tokens.slice(0, tokens.length - 1).join('!');\n                name = name.substr(sheet.length + 1);\n                if (sheet[0] === '\\'') {\n                    if (sheet.length > 1 && sheet[sheet.length - 1] === '\\'') {\n                        sheet = sheet.substr(1, sheet.length - 2);\n                    }\n                    else {\n                        // console.info('mismatched single quote');\n                        return undefined;\n                    }\n                }\n            }\n            const absolute = name[0] === '$';\n            name = (absolute ? name.substr(1) : name).toUpperCase();\n            const as_number = Number(name);\n            // if it looks like a number, consider it a number and then be strict\n            if (!isNaN(as_number)) {\n                if (as_number > 0 && as_number !== Infinity && !/\\./.test(name)) {\n                    return {\n                        type: 'address',\n                        position: unit.position,\n                        absolute_row: absolute,\n                        label: unit.name,\n                        row: as_number - 1,\n                        id: this.id_counter++,\n                        column: Infinity,\n                        sheet,\n                    };\n                }\n            }\n            else if (/[A-Z]{1,3}/.test(name)) {\n                let column = -1; // clever\n                for (let i = 0; i < name.length; i++) {\n                    const char = name[i].charCodeAt(0);\n                    column = 26 * (1 + column) + (char - UC_A);\n                }\n                return {\n                    type: 'address',\n                    position: unit.position,\n                    absolute_column: absolute,\n                    label: unit.name,\n                    column,\n                    id: this.id_counter++,\n                    row: Infinity,\n                    sheet,\n                };\n            }\n        }\n        return undefined;\n    }\n    /**\n     * converts binary operations with a colon operator to ranges. this also\n     * validates that there are no colon operations with non-address operands\n     * (which is why it's called after precendence reordering; colon has the\n     * highest preference). recursive only over binary ops AND unary ops.\n     *\n     * NOTE: there are other legal arguments to a colon operator. specifically:\n     *\n     * (1) two numbers, in either order\n     *\n     * 15:16\n     * 16:16\n     * 16:15\n     *\n     * (2) with one or both optionally having a $\n     *\n     * 15:$16\n     * $16:$16\n     *\n     * (3) two column identifiers, in either order\n     *\n     * A:F\n     * B:A\n     *\n     * (4) and the same with $\n     *\n     * $A:F\n     * $A:$F\n     *\n     * because none of these are legal in any other context, we leave the\n     * default treatment of them UNLESS they are arguments to the colon\n     * operator, in which case we will grab them. that does mean we parse\n     * them twice, but (...)\n     *\n     * FIXME: will need some updated to rendering these, we don't have any\n     * handler for rendering infinity\n     */\n    BinaryToRange(unit) {\n        if (unit.type === 'binary') {\n            if (unit.operator === ':') {\n                let range;\n                let label = '';\n                if (unit.left.type === 'address' && unit.right.type === 'address') {\n                    // construct a label using the full text. there's a possibility,\n                    // I suppose, that there are spaces (this should probably not be\n                    // legal). this is a canonical label, though (generated)\n                    // it might be better to let this slip, or treat it as an error\n                    // and force a correction... not sure (TODO/FIXME)\n                    const start_index = unit.left.position + unit.left.label.length;\n                    const end_index = unit.right.position;\n                    range = {\n                        type: 'range',\n                        id: this.id_counter++,\n                        position: unit.left.position,\n                        start: unit.left,\n                        end: unit.right,\n                        label: unit.left.label +\n                            this.expression.substring(start_index, end_index) +\n                            unit.right.label,\n                    };\n                    label = range.start.label + ':' + range.end.label;\n                    this.address_refcount[range.start.label]--;\n                    this.address_refcount[range.end.label]--;\n                    // remove entries from the list for start, stop\n                    const positions = [unit.left.position, unit.right.position];\n                    this.full_reference_list = this.full_reference_list.filter((test) => {\n                        return (test.position !== positions[0] && test.position !== positions[1]);\n                    });\n                }\n                else if ((unit.left.type === 'literal' || unit.left.type === 'identifier')\n                    && (unit.right.type === 'literal' || unit.right.type === 'identifier')) {\n                    // see if we can plausibly interpret both of these as rows or columns\n                    const left = this.UnitToAddress(unit.left);\n                    const right = this.UnitToAddress(unit.right);\n                    // and they need to match\n                    if (left && right\n                        && ((left.column === Infinity && right.column === Infinity)\n                            || (left.row === Infinity && right.row === Infinity))) {\n                        label = left.label + ':' + right.label;\n                        // we don't support out-of-order ranges, so we should correct.\n                        // they just won't work otherwise. (TODO/FIXME)\n                        range = {\n                            type: 'range',\n                            id: this.id_counter++,\n                            position: unit.left.position,\n                            start: left,\n                            end: right,\n                            label,\n                        };\n                    }\n                }\n                /*\n                else if ( unit.left.type === 'literal'\n                          && unit.right.type === 'literal'\n                          && typeof unit.left.value === 'number'\n                          && typeof unit.right.value === 'number') {\n        \n                  // technically we don't want to support any number that has\n                  // a decimal place, but I'm not sure we have a useful way of\n                  // measuring that... could look at the original text?\n        \n                  if (unit.left.value > 0\n                      && unit.right.value > 0\n                      && !/\\./.test(unit.left.text||'')\n                      && !/\\./.test(unit.right.text||'')\n                      ) {\n        \n                    label = unit.left.value.toString() + ':' + unit.right.value.toString();\n        \n                    console.info('m2:', label);\n        \n                    const left: UnitAddress = {\n                      type: 'address',\n                      position: unit.left.position,\n                      label: unit.left.value.toString(),\n                      row: unit.left.value - 1,\n                      id: this.id_counter++,\n                      column: Infinity,\n                    };\n        \n                    const right: UnitAddress = {\n                      type: 'address',\n                      position: unit.right.position,\n                      label: unit.right.value.toString(),\n                      row: unit.right.value - 1,\n                      id: this.id_counter++,\n                      column: Infinity,\n                    };\n        \n                    range = {\n                      type: 'range',\n                      id: this.id_counter++,\n                      position: unit.left.position,\n                      start: left,\n                      end: right,\n                      label,\n                    };\n        \n                  }\n                  \n                }\n                */\n                if (range) {\n                    this.dependencies.ranges[label] = range;\n                    // and add the range\n                    this.full_reference_list.push(range);\n                    return range;\n                }\n                else {\n                    this.error = `unexpected character: :`;\n                    this.valid = false;\n                    // console.info('xx', unit);\n                }\n            }\n            // recurse\n            unit.left = this.BinaryToRange(unit.left);\n            unit.right = this.BinaryToRange(unit.right);\n        }\n        // this should no longer be required, because we explicitly check\n        // when we construct the unary operations...\n        // else if (unit.type === 'unary') {\n        //   unit.operand = this.BinaryToRange(unit.operand);\n        // }\n        return unit;\n    }\n    /**\n     * reorders operations for precendence\n     */\n    ArrangeUnits(stream) {\n        // probably should not happen\n        if (stream.length === 0)\n            return { type: 'missing', id: this.id_counter++ };\n        // this is probably already covered\n        if (stream.length === 1)\n            return stream[0];\n        const stack = [];\n        // work left-to-right (implied precendence), unless there\n        // is actual precendence. spreadsheet language only supports\n        // binary operators, so we always expect unit - operator - unit\n        //\n        // UPDATE: that's incorrect. SL supports unary + and - operators.\n        // which makes this more complicated.\n        //\n        // we explicitly support unfinished expressions for the first pass\n        // to build dependencies, but if they're invalid the resulting\n        // parse tree isn't expected to be correct. in that case we\n        // generally will pass back a bag of parts, with a flag set.\n        for (let index = 0; index < stream.length; index++) {\n            let element = stream[index];\n            // given that we need to support unary operators, the logic needs\n            // to be a little different. operators are OK at any position, provided\n            // we can construct either a unary or binary operation.\n            if (element.type === 'operator') {\n                if (stack.length === 0 || stack[stack.length - 1].type === 'operator') {\n                    // valid if unary operator and we can construct a unary operation.\n                    // in this case we do it with recursion.\n                    if (unary_operators[element.operator]) {\n                        const right = this.BinaryToRange(this.ArrangeUnits(stream.slice(index + 1)));\n                        // this ensures we return the highest-level group, even if we recurse\n                        if (!this.valid) {\n                            return {\n                                type: 'group',\n                                id: this.id_counter++,\n                                elements: stream,\n                                explicit: false,\n                            };\n                        }\n                        // if it succeeded, then we need to apply the unary operator to\n                        // the result, or if it's a binary operation, to the left-hand side\n                        // (because we have precedence) -- unless it's a range [this is now\n                        // handled above]\n                        if (right.type === 'binary') {\n                            right.left = {\n                                type: 'unary',\n                                id: this.id_counter++,\n                                operator: element.operator,\n                                operand: right.left,\n                                position: element.position,\n                            };\n                            element = right;\n                        }\n                        else {\n                            // create a unary operation which will replace the element\n                            element = {\n                                type: 'unary',\n                                id: this.id_counter++,\n                                operator: element.operator,\n                                operand: right,\n                                position: element.position,\n                            };\n                        }\n                        // end loop after this pass, because the recurse consumes everything else\n                        index = stream.length;\n                    }\n                    else {\n                        this.error = `unexpected character [2]: ${element.operator}`;\n                        this.error_position = element.position;\n                        this.valid = false;\n                        return {\n                            type: 'group',\n                            id: this.id_counter++,\n                            elements: stream,\n                            explicit: false,\n                        };\n                    }\n                }\n                else {\n                    stack.push(element);\n                    continue;\n                }\n            }\n            if (stack.length < 2) {\n                stack.push(element);\n            }\n            else if (stack[stack.length - 1].type === 'operator') {\n                const left = stack[stack.length - 2];\n                const operator_unit = stack[stack.length - 1];\n                const operator = operator_unit.operator;\n                // assume we can construct it as follows: [A op B]\n                const operation = {\n                    type: 'binary',\n                    id: this.id_counter++,\n                    left,\n                    operator,\n                    position: operator_unit.position,\n                    right: element,\n                };\n                // we have to reorder if left (A) is a binary operation, and the\n                // precedence of the new operator is higher. note that we will\n                // deal with range operations later, for now just worry about\n                // operator precedence\n                if (left.type === 'binary' &&\n                    binary_operators_precendence[operator] >\n                        binary_operators_precendence[left.operator]) {\n                    // so we have [[A op1 B] op2 C], and we need to re-order this into [A op1 [B op2 C]].\n                    operation.left = left.left; // <- A\n                    operation.operator = left.operator; // <- op1\n                    operation.position = left.position;\n                    operation.right = {\n                        type: 'binary',\n                        id: this.id_counter++,\n                        left: left.right,\n                        right: element,\n                        operator,\n                        position: operator_unit.position,\n                    };\n                }\n                stack.splice(-2, 2, operation);\n            }\n            else {\n                this.error = `multiple expressions`;\n                this.error_position = element.position;\n                this.valid = false;\n                return {\n                    type: 'group',\n                    id: this.id_counter++,\n                    elements: stream,\n                    explicit: false,\n                };\n            }\n        }\n        return stack[0];\n    }\n    /**\n     * parses literals and tokens from the stream, ignoring whitespace,\n     * and stopping on unexpected tokens (generally operators or parens).\n     *\n     * @param naked treat -/+ as signs (part of numbers) rather than operators.\n     */\n    ParseNext(naked = true) {\n        this.ConsumeWhiteSpace();\n        const char = this.data[this.index];\n        if (char === DOUBLE_QUOTE) {\n            return {\n                type: 'literal',\n                id: this.id_counter++,\n                position: this.index,\n                value: this.ConsumeString(),\n            };\n        }\n        else if ((char >= ZERO && char <= NINE) || char === this.decimal_mark_char) {\n            // FIXME: is there a case where period needs to be handled the\n            // same way as plus and minus, below?\n            const position = this.index;\n            const [value, text] = this.ConsumeNumber();\n            return {\n                type: 'literal',\n                id: this.id_counter++,\n                position,\n                value,\n                text,\n            };\n        }\n        else if (char === OPEN_BRACE) {\n            return this.ConsumeArray();\n        }\n        else if (naked && (char === MINUS || char === PLUS)) {\n            // there's a case where you type '=-func()', which should support\n            // '=+func()' as well, both of which are naked operators and not numbers.\n            // the only way to figure this out is to check for a second number char.\n            // this is turning into lookahead, which we did not want to do...\n            const check = this.data[this.index + 1];\n            if ((check >= ZERO && check <= NINE) ||\n                check === this.decimal_mark_char) {\n                const position = this.index;\n                const [value, text] = this.ConsumeNumber();\n                return {\n                    type: 'literal',\n                    id: this.id_counter++,\n                    position,\n                    value,\n                    text,\n                }; // : this.ConsumeNumber() };\n            }\n        }\n        else if ((char >= UC_A && char <= UC_Z) ||\n            (char >= LC_A && char <= LC_Z) ||\n            char === UNDERSCORE ||\n            char === SINGLE_QUOTE ||\n            char === DOLLAR_SIGN ||\n            (char >= ACCENTED_RANGE_START && char <= ACCENTED_RANGE_END) // adding accented characters, needs some testing\n        ) {\n            // FIXME: this only tests for ASCII tokens? (...)\n            return this.ConsumeToken(char);\n        }\n        // else throw(new Error('Unexpected character: ' + char));\n        return char;\n    }\n    ConsumeArray() {\n        const expression = {\n            type: 'array',\n            id: this.id_counter++,\n            values: [],\n            position: this.index,\n        };\n        this.index++;\n        let row = 0;\n        let column = 0;\n        while (this.index < this.length) {\n            const item = this.ParseNext();\n            const start_position = this.index;\n            if (typeof item === 'number') {\n                this.index++;\n                switch (item) {\n                    case SEMICOLON:\n                        //column = 0;\n                        //row++;\n                        column++;\n                        row = 0;\n                        break;\n                    case COMMA:\n                        //column++;\n                        row++;\n                        break;\n                    case CLOSE_BRACE:\n                        return expression;\n                    default:\n                        if (this.valid) {\n                            this.error = `invalid character in array literal`;\n                            this.error_position = start_position;\n                            this.valid = false;\n                        }\n                        break;\n                }\n            }\n            else {\n                switch (item.type) {\n                    case 'literal':\n                        if (!expression.values[row]) {\n                            expression.values[row] = [];\n                        }\n                        expression.values[row][column] = item.value;\n                        break;\n                    default:\n                        if (this.valid) {\n                            this.error = `invalid value in array literal`;\n                            this.error_position = start_position;\n                            this.valid = false;\n                        }\n                        break;\n                }\n            }\n        }\n        return expression;\n    }\n    ConsumeOperator() {\n        for (const operator of binary_operators) {\n            if (this.expression.substr(this.index, operator.length) === operator) {\n                const position = this.index;\n                this.index += operator.length;\n                return {\n                    type: 'operator',\n                    id: this.id_counter++,\n                    operator,\n                    position,\n                };\n            }\n        }\n        return null;\n    }\n    /** consume function arguments, which can be of any type */\n    ConsumeArguments() {\n        this.index++; // open paren\n        let argument_index = 0;\n        const args = [];\n        for (; this.index < this.length;) {\n            const unit = this.ParseGeneric([\n                this.argument_separator_char,\n                CLOSE_PAREN,\n            ]);\n            if (null !== unit)\n                args.push(unit);\n            // why did parsing stop?\n            const char = this.data[this.index];\n            if (char === this.argument_separator_char) {\n                this.index++;\n                argument_index++;\n                for (let i = args.length; i < argument_index; i++) {\n                    args.push({ type: 'missing', id: this.id_counter++ });\n                }\n            }\n            else if (char === CLOSE_PAREN) {\n                this.index++;\n                return args;\n            }\n            // else console.info('UNEXPECTED (CA)', char);\n        }\n        return args;\n    }\n    /**\n     * consume token. also checks for function call, because parens\n     * have a different meaning (grouping/precedence) when they appear\n     * not immediately after a token.\n     *\n     * regarding periods: as long as there's no intervening whitespace\n     * or operator, period should be a valid token character. tokens\n     * cannot start with a period.\n     *\n     * NOTE: that's true irrespective of decimal mark type.\n     *\n     * you can have tokens (addresses) with single quotes; these are used\n     * to escape sheet names with spaces (which is a bad idea, but hey). this\n     * should only be legal if the token starts with a single quote, and only\n     * for one (closing) quote.\n     */\n    ConsumeToken(initial_char) {\n        const token = [initial_char];\n        const position = this.index;\n        let single_quote = (initial_char === SINGLE_QUOTE);\n        for (++this.index; this.index < this.length; this.index++) {\n            const char = this.data[this.index];\n            if ((char >= UC_A && char <= UC_Z) ||\n                (char >= LC_A && char <= LC_Z) ||\n                (char >= ACCENTED_RANGE_START && char <= ACCENTED_RANGE_END) ||\n                char === UNDERSCORE ||\n                char === DOLLAR_SIGN ||\n                char === PERIOD ||\n                char === EXCLAMATION_MARK ||\n                single_quote || // ((char === SINGLE_QUOTE || char === SPACE) && single_quote) ||\n                (char >= ZERO && char <= NINE) // tokens can't start with a number, but this loop starts at index 1\n            ) {\n                token.push(char);\n                if (char === SINGLE_QUOTE) {\n                    single_quote = false; // one only\n                }\n            }\n            else\n                break;\n        }\n        const str = token.map((num) => String.fromCharCode(num)).join('');\n        // special handling: unbalanced single quote (probably sheet name),\n        // this is an error\n        if (single_quote) { // unbalanced\n            this.error = `unbalanced single quote`;\n            this.error_position = position;\n            this.valid = false;\n            return {\n                type: 'identifier',\n                id: this.id_counter++,\n                name: str,\n                position,\n            };\n        }\n        // special handling\n        if (str.toLowerCase() === 'true') {\n            return {\n                type: 'literal',\n                id: this.id_counter++,\n                value: true,\n                position,\n            };\n        }\n        if (str.toLowerCase() === 'false') {\n            return {\n                type: 'literal',\n                id: this.id_counter++,\n                value: false,\n                position,\n            };\n        }\n        // function takes precendence over address? I guess so\n        this.ConsumeWhiteSpace();\n        const next_char = this.data[this.index];\n        if (next_char === OPEN_PAREN) {\n            const args = this.ConsumeArguments();\n            return {\n                type: 'call',\n                id: this.id_counter++,\n                name: str,\n                args,\n                position,\n            };\n        }\n        // check for address. in the case of a range, we'll see an address, the\n        // range operator, and a second address. that will be turned into a range\n        // later.\n        const address = this.ConsumeAddress(str, position);\n        if (address)\n            return address;\n        const identifier = {\n            type: 'identifier',\n            id: this.id_counter++,\n            name: str,\n            position,\n        };\n        this.full_reference_list.push(identifier);\n        return identifier;\n    }\n    /**\n     * consumes address. this is outside of the normal parse flow;\n     * we already have a token, here we're checking if it's an address.\n     *\n     * this used to check for ranges as well, but we now treat ranges as\n     * an operation on two addresses; that supports whitespace between the\n     * tokens.\n     *\n     * FIXME: that means we can now inline the column/row routines, since\n     * they are not called more than once\n     */\n    ConsumeAddress(token, position) {\n        const index = position;\n        const token_length = token.length;\n        // FIXME: should mark this (!) when it hits, rather than search\n        // UPDATE: ! is legal in sheet names, although it needs to be quoted.\n        let sheet;\n        const tokens = token.split('!');\n        if (tokens.length > 1) {\n            sheet = tokens.slice(0, tokens.length - 1).join('!');\n            position += sheet.length + 1;\n        }\n        /*\n        if (tokens.length === 2) {\n          sheet = tokens[0];\n          position += (tokens[0].length + 1);\n        }\n        */\n        // FIXME: can inline\n        const c = this.ConsumeAddressColumn(position);\n        if (!c)\n            return null;\n        position = c.position;\n        const r = this.ConsumeAddressRow(position);\n        if (!r)\n            return null;\n        position = r.position;\n        const label = sheet ?\n            sheet + token.substr(sheet.length, position - index).toUpperCase() :\n            token.substr(0, position - index).toUpperCase();\n        if (sheet && sheet[0] === '\\'') {\n            sheet = sheet.substr(1, sheet.length - 2);\n        }\n        const addr = {\n            type: 'address',\n            id: this.id_counter++,\n            label,\n            row: r.row,\n            column: c.column,\n            absolute_row: r.absolute,\n            absolute_column: c.absolute,\n            position: index,\n            sheet,\n        };\n        // if that's not the complete token, then it's invalid\n        if (token_length !== position - index)\n            return null;\n        // store ref, increment count\n        this.dependencies.addresses[addr.label] = addr;\n        this.address_refcount[addr.label] =\n            (this.address_refcount[addr.label] || 0) + 1;\n        // add to new address list. use the actual object (not a clone or copy);\n        // we update the list later, and we may want to remove it (if it turns\n        // out it's part of a range)\n        this.full_reference_list.push(addr);\n        return addr;\n    }\n    /**\n     * consumes a row, possibly absolute ($). returns the numeric row\n     * (0-based) and metadata\n     */\n    ConsumeAddressRow(position) {\n        const absolute = this.data[position] === DOLLAR_SIGN;\n        if (absolute)\n            position++;\n        const start = position;\n        let value = 0;\n        for (;; position++) {\n            const char = this.data[position];\n            if (char >= ZERO && char <= NINE) {\n                value *= 10;\n                value += char - ZERO;\n            }\n            else\n                break;\n        }\n        if (start === position)\n            return false;\n        return { absolute, row: value - 1, position };\n    }\n    /**\n     * consumes a column, possibly absolute ($). returns the numeric\n     * column (0-based) and metadata\n     */\n    ConsumeAddressColumn(position) {\n        let column = -1; // clever\n        let length = 0; // max 3 chars for column\n        const absolute = this.data[position] === DOLLAR_SIGN;\n        if (absolute)\n            position++;\n        for (;; position++, length++) {\n            if (length >= 4)\n                return false; // max 3 chars for column\n            const char = this.data[position];\n            if (char >= UC_A && char <= UC_Z) {\n                column = 26 * (1 + column) + (char - UC_A);\n            }\n            else if (char >= LC_A && char <= LC_Z) {\n                column = 26 * (1 + column) + (char - LC_A);\n            }\n            else\n                break;\n        }\n        if (column < 0)\n            return false;\n        return { absolute, column, position };\n    }\n    /**\n     * consumes number. supported formats (WIP):\n     *\n     * -3\n     * +3\n     * 100.9\n     * 10.0%\n     * 1e-2.2\n     *\n     * ~1,333,123.22~\n     *\n     * UPDATE: commas (separators) are not acceptable in numbers passed\n     * in formulae, can't distinguish between them and function argument\n     * separators.\n     *\n     * regarding the above, a couple of rules:\n     *\n     * 1. +/- is only legal in position 0 or immediately after e/E\n     * 2. only one decimal point is allowed.\n     * 3. any number of separators, in any position, are legal, but\n     *    only before the decimal point.\n     * 4. only one % is allowed, and only in the last position\n     *\n     * NOTE: this is probably going to break on unfinished strings that\n     * end in - or +... if they're not treated as operators...\n     *\n     * FIXME: find test cases for that so we can fix it\n     *\n     * UPDATE: exporting original text string for preservation/insertion.\n     * this function now returns a tuple of [value, text].\n     *\n     */\n    ConsumeNumber() {\n        // for exponential notation\n        let exponent = 0;\n        let negative_exponent = false;\n        // general\n        let negative = false;\n        let integer = 0;\n        let decimal = 0;\n        let fraction = 0;\n        let state = 'integer';\n        let position = 0;\n        const start_index = this.index;\n        for (; this.index < this.length; this.index++, position++) {\n            const char = this.data[this.index];\n            if (char === this.decimal_mark_char) {\n                if (state === 'integer')\n                    state = 'fraction';\n                else\n                    break; // end of token; not consuming\n            }\n            else if (char === PERCENT) {\n                // FIXME: disallow combination of exponential and percent notation\n                integer /= 100; // this is a dumb way to do this\n                fraction /= 100;\n                this.index++; // we are consuming\n                break; // end of token\n            }\n            else if (char === PLUS || char === MINUS) {\n                // NOTE: handling of positive/negative exponent in exponential\n                // notation is handled separately, see below\n                if (position === 0) {\n                    if (char === MINUS)\n                        negative = true;\n                }\n                else\n                    break; // end of token -- not consuming\n            }\n            // else if (char === COMMA){\n            //  // ... FIXME: validate that we're in the integer part\n            // }\n            else if (char === UC_E || char === LC_E) {\n                if (state === 'integer' || state === 'fraction') {\n                    state = 'exponent';\n                    if (this.index < this.length - 1) {\n                        if (this.data[this.index + 1] === PLUS)\n                            this.index++;\n                        else if (this.data[this.index + 1] === MINUS) {\n                            this.index++;\n                            negative_exponent = true;\n                        }\n                    }\n                }\n                else\n                    break; // not sure what this is, then\n            }\n            else if (char >= ZERO && char <= NINE) {\n                switch (state) {\n                    case 'integer':\n                        integer = integer * 10 + (char - ZERO);\n                        break;\n                    case 'fraction':\n                        fraction = fraction * 10 + (char - ZERO);\n                        decimal++;\n                        break;\n                    case 'exponent':\n                        exponent = exponent * 10 + (char - ZERO);\n                        break;\n                }\n            }\n            else\n                break;\n        }\n        let value = integer + fraction * Math.pow(10, -decimal);\n        if (state === 'exponent') {\n            value = value * Math.pow(10, (negative_exponent ? -1 : 1) * exponent);\n        }\n        const text = this.expression.substring(start_index, this.index) || '';\n        return [negative ? -value : value, text];\n    }\n    /**\n     * in spreadsheet language ONLY double-quoted strings are legal. there\n     * are no escape characters, and a backslash is a legal character. to\n     * embed a quotation mark, use \"\" (double-double quote); that's an escaped\n     * double-quote.\n     */\n    ConsumeString() {\n        this.index++; // open quote\n        const str = [];\n        for (; this.index < this.length; this.index++) {\n            const char = this.data[this.index];\n            if (char === DOUBLE_QUOTE) {\n                // always do this: either it's part of the string (and\n                // we want to skip the next one), or it's the end of the\n                // string and we want to close the literal.\n                this.index++;\n                // check for an escaped double-quote; otherwise close the string\n                // note (1) we already incremented, so check the current value,\n                // and (2) it will increment again on the loop pass so it will\n                // drop the extra one. I note these because this was confusing to\n                // write.\n                if (this.index >= this.length ||\n                    this.data[this.index] !== DOUBLE_QUOTE) {\n                    break;\n                }\n            }\n            str.push(char);\n        }\n        return str.map((char) => String.fromCharCode(char)).join('');\n    }\n    /** run through any intervening whitespace */\n    ConsumeWhiteSpace() {\n        for (; this.index < this.length;) {\n            const char = this.data[this.index];\n            if (char === SPACE ||\n                char === TAB ||\n                char === CR ||\n                char === LF ||\n                char === NON_BREAKING_SPACE) {\n                this.index++;\n            }\n            else\n                return;\n        }\n    }\n}\n\n\n//# sourceURL=webpack://treb/./treb-parser/src/parser.ts?");

/***/ }),

/***/ "./treb-utils/src/dispatch.ts":
/*!************************************!*\
  !*** ./treb-utils/src/dispatch.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Yield\": () => (/* binding */ Yield)\n/* harmony export */ });\n/**\n * UPDATE: dropping dispatch altogether. there were really very few\n * cases where queue length > 1, so it seems like unecessary overhead.\n *\n * it's still somewhat useful to have an interface, in the event we\n * change this again, so keep using the Yield() function.\n *\n * TODO: is anyone using the callback version? could drop...\n */\n/** implementation */\nfunction Yield(fn) {\n    return fn ? Promise.resolve().then(fn) : Promise.resolve();\n}\n/* for perf testing, we don't need this anymore\n(self as any).__dispatcher_instance = {\n  Call: Yield\n}\n*/\n\n\n//# sourceURL=webpack://treb/./treb-utils/src/dispatch.ts?");

/***/ }),

/***/ "./treb-utils/src/event_source.ts":
/*!****************************************!*\
  !*** ./treb-utils/src/event_source.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EventSource\": () => (/* binding */ EventSource)\n/* harmony export */ });\n/* harmony import */ var _dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dispatch */ \"./treb-utils/src/dispatch.ts\");\n\nlet subscription_token_generator = 1000;\n/**\n * relatively simple event publish/subscribe mechanism.\n * not as simple as it used to be.\n */\nclass EventSource {\n    constructor(verbose = false, log_id = 'undefined') {\n        this.verbose = verbose;\n        this.log_id = log_id;\n        /** pending events */\n        this.queue = [];\n        /** flag indicating whether we have already triggered a callback */\n        this.dispatched = false;\n        /** regular subscriptions */\n        this.subscribers = [];\n        /** pass-through modules: these are peers */\n        this.pass_through = [];\n    }\n    /**\n     * FIXME: does anybody call this with an array? it's no longer\n     * necessary for multiple messages to prevent extra callbacks...\n     */\n    Publish(event) {\n        if (this.verbose) {\n            console.info(`es publish (${this.log_id})`, event);\n        }\n        // here's our updated synchronous mechanism, passing through\n        // FIXME: no one uses this (I think). drop it.\n        this.pass_through.forEach((source) => source.Publish(event));\n        // don't bother if there are no subscribers (implies you must\n        // subscribe before first event... not sure if that's reasonable)\n        /*\n        if (!this.subscribers.length) {\n          return; // ...\n        }\n        */\n        // queue event or events\n        if (Array.isArray(event)) {\n            this.queue.push(...event);\n        }\n        else {\n            this.queue.push(event);\n        }\n        // then call the dispatch function. gate this in case we get\n        // this call multiple times before a callback.\n        if (!this.dispatched) {\n            this.dispatched = true;\n            (0,_dispatch__WEBPACK_IMPORTED_MODULE_0__.Yield)().then(() => {\n                const events = this.queue.slice(0);\n                this.dispatched = false;\n                this.queue = [];\n                // FIXME: should we cache subscribers as well? (...)\n                for (const queued_event of events) {\n                    for (const subscription of this.subscribers) {\n                        subscription.subscriber(queued_event);\n                    }\n                }\n            });\n        }\n    }\n    /**\n     * subscription returns a token which can be used to cancel subscription.\n     * this token is a number, guaranteed to be !0 so you can test for falsy.\n     */\n    Subscribe(subscriber) {\n        const token = subscription_token_generator++;\n        this.subscribers.push({ subscriber, token });\n        return token;\n    }\n    /** cancel a single subscription */\n    Cancel(token) {\n        this.subscribers = this.subscribers.filter((subscription) => subscription.token !== token);\n    }\n    /**\n     * cancel all subscriptions AND ALL PASS-THROUGH SOURCES.\n     */\n    CancelAll() {\n        this.subscribers = [];\n        this.pass_through = [];\n    }\n    /**\n     * pass-through (redirected) subscription, synchronous on this end. does\n     * not support unsubscribe atm (FIXME)\n     */\n    PassThrough(source) {\n        this.pass_through.push(source);\n    }\n}\n\n\n//# sourceURL=webpack://treb/./treb-utils/src/event_source.ts?");

/***/ }),

/***/ "./treb-utils/src/ievent_source.ts":
/*!*****************************************!*\
  !*** ./treb-utils/src/ievent_source.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\n\n\n//# sourceURL=webpack://treb/./treb-utils/src/ievent_source.ts?");

/***/ }),

/***/ "./treb-utils/src/index.ts":
/*!*********************************!*\
  !*** ./treb-utils/src/index.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Yield\": () => (/* reexport safe */ _dispatch__WEBPACK_IMPORTED_MODULE_0__.Yield),\n/* harmony export */   \"EventSource\": () => (/* reexport safe */ _event_source__WEBPACK_IMPORTED_MODULE_1__.EventSource),\n/* harmony export */   \"Resizable\": () => (/* reexport safe */ _resizable__WEBPACK_IMPORTED_MODULE_3__.Resizable),\n/* harmony export */   \"Measurement\": () => (/* reexport safe */ _measurement__WEBPACK_IMPORTED_MODULE_4__.Measurement),\n/* harmony export */   \"SerializeHTML\": () => (/* reexport safe */ _serialize_html__WEBPACK_IMPORTED_MODULE_5__.SerializeHTML),\n/* harmony export */   \"Scale\": () => (/* reexport safe */ _scale__WEBPACK_IMPORTED_MODULE_6__.Scale),\n/* harmony export */   \"composite\": () => (/* reexport safe */ _template__WEBPACK_IMPORTED_MODULE_7__.composite),\n/* harmony export */   \"css\": () => (/* reexport safe */ _template__WEBPACK_IMPORTED_MODULE_7__.css),\n/* harmony export */   \"tmpl\": () => (/* reexport safe */ _template__WEBPACK_IMPORTED_MODULE_7__.tmpl)\n/* harmony export */ });\n/* harmony import */ var _dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dispatch */ \"./treb-utils/src/dispatch.ts\");\n/* harmony import */ var _event_source__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./event_source */ \"./treb-utils/src/event_source.ts\");\n/* harmony import */ var _ievent_source__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ievent_source */ \"./treb-utils/src/ievent_source.ts\");\n/* harmony import */ var _resizable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resizable */ \"./treb-utils/src/resizable.ts\");\n/* harmony import */ var _measurement__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./measurement */ \"./treb-utils/src/measurement.ts\");\n/* harmony import */ var _serialize_html__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./serialize_html */ \"./treb-utils/src/serialize_html.ts\");\n/* harmony import */ var _scale__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./scale */ \"./treb-utils/src/scale.ts\");\n/* harmony import */ var _template__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./template */ \"./treb-utils/src/template.ts\");\n\n\n\n\n\n// export * from './color';\n\n\n\n\n\n//# sourceURL=webpack://treb/./treb-utils/src/index.ts?");

/***/ }),

/***/ "./treb-utils/src/measurement.ts":
/*!***************************************!*\
  !*** ./treb-utils/src/measurement.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Measurement\": () => (/* binding */ Measurement)\n/* harmony export */ });\nclass Measurement {\n    static MeasureColorARGB(color) {\n        const bytes = this.MeasureColor(color);\n        let argb = 'FF'; // always 100%\n        for (let i = 0; i < 3; i++) {\n            const hex = bytes[i].toString(16);\n            if (hex.length === 0)\n                argb += '00';\n            else if (hex.length === 1)\n                argb += `0${hex}`;\n            else\n                argb += hex;\n        }\n        return argb.toUpperCase();\n    }\n    /**\n     * measure a color. turns symbolic or rgb colors into rgb values.\n     *\n     * UPDATE: prefill with #fff. that prevents it from randomly returning\n     * the last value, if the color doesn't work for some reason.\n     */\n    static MeasureColor(color) {\n        let cached = this.color_cache[color];\n        if (cached) {\n            return cached;\n        }\n        if (!this.color_measurement_canvas) {\n            this.color_measurement_canvas = document.createElement('canvas');\n            this.color_measurement_canvas.width = 1;\n            this.color_measurement_canvas.height = 1;\n        }\n        const context = this.color_measurement_canvas.getContext('2d');\n        if (context) {\n            context.fillStyle = '#fff';\n            context.fillRect(0, 0, 1, 1);\n            context.fillStyle = color;\n            context.fillRect(0, 0, 1, 1);\n            cached = context.getImageData(0, 0, 1, 1).data;\n            this.color_cache[color] = cached;\n            return cached;\n        }\n        return new Uint8ClampedArray(3);\n    }\n    static EnsureMeasurementNode() {\n        if (!this.text_measurement_node) {\n            const node = document.querySelector('.treb-chart-measurement-node');\n            if (node) {\n                this.text_measurement_node = node;\n            }\n            else {\n                this.text_measurement_node = document.createElement('div');\n                this.text_measurement_node.classList.add('treb-chart-measurement-node');\n                this.text_measurement_node.style.margin = '0px';\n                this.text_measurement_node.style.padding = '0px';\n                this.text_measurement_node.style.whiteSpace = 'nowrap';\n                this.text_measurement_node.style.position = 'fixed';\n                this.text_measurement_node.style.border = '0px';\n                this.text_measurement_node.style.border = '1px solid red';\n                this.text_measurement_node.style.boxSizing = 'content-box';\n                this.text_measurement_node.style.top =\n                    this.text_measurement_node.style.left = '-1000px';\n                document.body.appendChild(this.text_measurement_node);\n            }\n        }\n    }\n    /**\n     * check if font is loaded, based on the theory that the alternatives\n     * will be different sizes. note that this probably doesn't test weights\n     * or italics properly, as those can be emulated without the specific face.\n     *\n     * I guess the thing to do in that case would be to load the alternate faces\n     * first, and assume they are loaded serially (they're not).\n     *\n     * @param font_face\n     * @param italic\n     * @param bold\n     */\n    static FontLoaded(font_face, italic = false, weight = 400) {\n        const face = `${italic ? 'italic' : ''} ${weight} 20pt ${font_face}`;\n        const m1 = this.MeasureText(`${face}, sans-serif`, `check font`);\n        const m2 = this.MeasureText(`${face}, serif`, `check font`);\n        const m3 = this.MeasureText(`${face}, monospace`, `check font`);\n        return (m1.width === m2.width && m2.width === m3.width);\n    }\n    /**\n     * measure width, height of text, accounting for rotation\n     */\n    static MeasureText(font, text, angle = 0) {\n        this.EnsureMeasurementNode();\n        this.text_measurement_node.style.font = font;\n        if (/\\n/.test(text)) {\n            text = text.replace(/\\n/g, '<BR/>');\n            this.text_measurement_node.innerHTML = text;\n        }\n        else {\n            this.text_measurement_node.textContent = text;\n        }\n        this.text_measurement_node.style.lineHeight = '1em';\n        if (angle) {\n            this.text_measurement_node.style.transform = `rotate(${angle}deg)`;\n        }\n        else\n            this.text_measurement_node.style.transform = '';\n        const rect = this.text_measurement_node.getBoundingClientRect();\n        return {\n            width: rect.width,\n            height: rect.height,\n        };\n    }\n}\n/** cache for color lookups */\nMeasurement.color_cache = {};\n\n\n//# sourceURL=webpack://treb/./treb-utils/src/measurement.ts?");

/***/ }),

/***/ "./treb-utils/src/resizable.ts":
/*!*************************************!*\
  !*** ./treb-utils/src/resizable.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Resizable\": () => (/* binding */ Resizable)\n/* harmony export */ });\n/**\n * support for resizable node, drag handle, drag rect, mask\n * FIXME: make this composable (decorator?)\n * FIXME: make this generic, we can use it for some other stuff (charts?)\n */\nclass Resizable {\n    /**\n     * adding layout_reference to move the handle. to keep this backwards\n     * compatible, we add it as a last, optional parameter. at some point\n     * we can create a replacement class and migrate.\n     *\n     * this is a weird pattern, we don't need an instance of this class...\n     * goint to refactor\n     *\n     */\n    constructor(container, node, resize_callback, layout_reference = container) {\n        Resizable.Create({\n            container,\n            node,\n            resize_callback,\n            layout_reference\n        });\n    }\n    static Create(options) {\n        const resize_handle = document.createElement('div');\n        resize_handle.classList.add('treb-embed-resize-handle');\n        (options.layout_reference || options.container).appendChild(resize_handle);\n        if (!Resizable.resize_mask) {\n            let mask = document.querySelector('.treb-embed-mouse-mask');\n            if (!mask) {\n                mask = document.createElement('div');\n                mask.classList.add('treb-embed-mouse-mask');\n                document.body.appendChild(mask);\n            }\n            Resizable.resize_mask = mask;\n        }\n        if (!Resizable.resize_rect) {\n            let rect = document.querySelector('.treb-embed-resize-rect');\n            if (!rect) {\n                rect = document.createElement('div');\n                rect.classList.add('treb-embed-resize-rect');\n                Resizable.resize_mask.appendChild(rect);\n            }\n            Resizable.resize_rect = rect;\n        }\n        // eslint-disable-next-line prefer-const\n        let mouseup;\n        // eslint-disable-next-line prefer-const\n        let mousemove;\n        let container_rect = { width: 0, height: 0 };\n        let offset = { x: 0, y: 0 };\n        let delta = { x: 0, y: 0 };\n        const cleanup = () => {\n            Resizable.resize_mask.removeEventListener('mousemove', mousemove);\n            Resizable.resize_mask.removeEventListener('mouseup', mouseup);\n            Resizable.resize_mask.style.display = 'none';\n            if (delta.x || delta.y) {\n                const bounding_rect = options.container.getBoundingClientRect();\n                const width = bounding_rect.width + delta.x;\n                const height = bounding_rect.height + delta.y;\n                options.container.style.width = `${width}px`;\n                options.container.style.height = `${height}px`;\n                if (options.resize_callback) {\n                    options.resize_callback();\n                }\n            }\n        };\n        mousemove = (event) => {\n            if (!event.buttons) {\n                cleanup();\n                return;\n            }\n            if (delta.x !== event.clientX - offset.x) {\n                delta.x = event.clientX - offset.x;\n                Resizable.resize_rect.style.width = `${container_rect.width + delta.x + 4}px`;\n            }\n            if (delta.y !== event.clientY - offset.y) {\n                delta.y = event.clientY - offset.y;\n                Resizable.resize_rect.style.height = `${container_rect.height + delta.y + 4}px`;\n            }\n        };\n        mouseup = () => {\n            cleanup();\n        };\n        resize_handle.addEventListener('mousedown', (event) => {\n            event.stopPropagation();\n            event.preventDefault();\n            const bounding_rect = options.node.getBoundingClientRect();\n            container_rect = { width: bounding_rect.width, height: bounding_rect.height };\n            if (Resizable.resize_rect) {\n                Resizable.resize_rect.style.top = `${bounding_rect.top - 2}px`;\n                Resizable.resize_rect.style.left = `${bounding_rect.left - 2}px`;\n                Resizable.resize_rect.style.width = `${bounding_rect.width + 4}px`;\n                Resizable.resize_rect.style.height = `${bounding_rect.height + 4}px`;\n            }\n            offset = { x: event.clientX, y: event.clientY };\n            delta = { x: 0, y: 0 };\n            Resizable.resize_mask.style.display = 'block';\n            Resizable.resize_mask.addEventListener('mousemove', mousemove);\n            Resizable.resize_mask.addEventListener('mouseup', mouseup);\n        });\n    }\n}\n\n\n//# sourceURL=webpack://treb/./treb-utils/src/resizable.ts?");

/***/ }),

/***/ "./treb-utils/src/scale.ts":
/*!*********************************!*\
  !*** ./treb-utils/src/scale.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Scale\": () => (/* binding */ Scale)\n/* harmony export */ });\n/**\n * making this a little more generic so we can use it outside of charts.\n * specifically, for the sheet \"histogram table\" function. for that, we\n * do need to ensure that the count is not greater than our request.\n *\n * we have a new parameter for that, default behavior should not change.\n */\nconst Scale = (min, max, count = 6.5, limit_count = false) => {\n    if (max === min) {\n        // we should either have optional behavior here or have this as\n        // some sort of wrapper method -- it just seems arbitrary\n        max++;\n        if (min) {\n            min--;\n        }\n    }\n    else {\n        // let's fix this specific problem, where you get accumulated fp errors. round to 5 places...\n        // const tmp_range = max - min;\n        const rounded = Math.round(max * 100000) / 100000;\n        if (Math.abs(rounded - max) / (max - min) < 1e-5) {\n            max = rounded;\n        }\n    }\n    const range = max - min;\n    const log10 = Math.log(range) / Math.log(10); // just avoid the problem (problem being IE11 lack of Math.log10)\n    const scale = Math.floor(Math.abs(log10)) * (log10 < 0 ? -1 : 1) - 1;\n    const steps = [.1, .25, .5, 1, 2.5, 5, 10, 25, 50, 100];\n    let step = -1;\n    let delta = 0;\n    for (const x of steps) {\n        const test_step = x * Math.pow(10, scale);\n        const test_min = Math.floor(min / test_step) * test_step;\n        const test_max = Math.ceil(max / test_step) * test_step;\n        const test_count = (test_max - test_min) / test_step;\n        const test_delta = Math.abs(test_count - count);\n        if (step < 0 || test_delta < delta) {\n            if (!limit_count || (test_count <= count)) {\n                delta = test_delta;\n                step = test_step;\n            }\n        }\n        /*\n        else if (!limit_count && (test_delta < delta)) {\n          delta = test_delta;\n          step = test_step;\n        }\n        else if (limit_count && test_delta < delta && test_count <= count) {\n          delta = test_delta;\n          step = test_step;\n        }\n        */\n        /*\n    \n        if (step < 0 || test_delta < delta){\n          delta = test_delta;\n          step = test_step;\n        }\n        else if (step >= 0 && test_delta > delta) {\n          if (limit_count) {\n            min = Math.floor(min / step) * step;\n            max = Math.ceil(max / step) * step;\n            const check = Math.round((max - min) / step);\n            if (check > count) {\n              delta = test_delta;\n              step = test_step;\n              continue;\n            }\n          }\n          break;\n        }\n        */\n    }\n    min = Math.floor(min / step) * step;\n    max = Math.ceil(max / step) * step;\n    count = Math.round((max - min) / step); // accounts for fp errors\n    return { scale, step, count, min, max };\n};\n\n\n//# sourceURL=webpack://treb/./treb-utils/src/scale.ts?");

/***/ }),

/***/ "./treb-utils/src/serialize_html.ts":
/*!******************************************!*\
  !*** ./treb-utils/src/serialize_html.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SerializeHTML\": () => (/* binding */ SerializeHTML)\n/* harmony export */ });\n/**\n * defaults are global, since we assume they never change. created on demand.\n */\nlet default_properties;\n/**\n * get applied style as text (for attribute)\n */\nconst GetAppliedStyle = (node, computed, defaults) => {\n    const applied = {};\n    Array.prototype.forEach.call(computed, (key) => {\n        if (computed[key] !== defaults[key]) {\n            applied[key] = computed[key];\n        }\n    });\n    return (Object.keys(applied).map((key) => `${key}: ${applied[key]}`).join('; ') +\n        '; ' + (node.getAttribute('style') || '')).trim().replace(/\"/g, '\\'');\n};\n/**\n * create a clone of the node with static styles applied\n */\nconst RenderNode = (node, defaults) => {\n    const clone = node.cloneNode(false);\n    const computed = getComputedStyle(node);\n    const style = GetAppliedStyle(node, computed, defaults);\n    clone.removeAttribute('class');\n    clone.setAttribute('style', style);\n    Array.prototype.forEach.call(node.childNodes, (child) => {\n        switch (child.nodeType) {\n            case Node.ELEMENT_NODE:\n                // here we use the parent as the default style, assuming the child will inherit\n                clone.appendChild(RenderNode(child, computed));\n                break;\n            case Node.TEXT_NODE:\n                if (node.textContent) {\n                    clone.appendChild(document.createTextNode(node.textContent));\n                }\n                break;\n            case Node.COMMENT_NODE:\n                // silently drop comments\n                break;\n            default:\n                console.warn('unhandled node type in serialize', child);\n        }\n    });\n    return clone;\n};\n/**\n * serialize a node by creating a clone with static styling that can be\n * used stand-alone (intended for svg, but could apply generically).\n */\nconst SerializeHTML = (node) => {\n    if (!default_properties) {\n        const defaults = {};\n        const iframe = document.createElement('iframe');\n        iframe.style.width = '10px';\n        iframe.style.height = '10px';\n        iframe.style.position = 'absolute';\n        iframe.style.left = '-100px';\n        document.body.appendChild(iframe);\n        const frame_document = iframe.contentDocument;\n        if (frame_document) {\n            const div = frame_document.createElement('div');\n            frame_document.body.appendChild(div);\n            const computed = getComputedStyle(div);\n            Array.prototype.forEach.call(computed, (key) => defaults[key] = computed[key]);\n        }\n        document.body.removeChild(iframe);\n        default_properties = defaults;\n    }\n    return RenderNode(node, default_properties);\n};\n// (self as any).SerializeHTML = SerializeHTML;\n\n\n//# sourceURL=webpack://treb/./treb-utils/src/serialize_html.ts?");

/***/ }),

/***/ "./treb-utils/src/template.ts":
/*!************************************!*\
  !*** ./treb-utils/src/template.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"composite\": () => (/* binding */ composite),\n/* harmony export */   \"tmpl\": () => (/* binding */ tmpl),\n/* harmony export */   \"css\": () => (/* binding */ css)\n/* harmony export */ });\nconst ParseTail = (node, scope, model) => {\n    [].forEach.call(node.children, (child) => {\n        if (child.id) {\n            model[child.id] = child;\n            child.id = `${scope}-${child.id}`;\n        }\n        if (child.children && child.children.length) {\n            ParseTail(child, scope, model);\n        }\n    });\n};\nconst ParseTemplate = (template, container) => {\n    const scope = Math.random().toString(36).substring(2, 15);\n    const temp = document.createElement('div');\n    temp.innerHTML = template;\n    const model = {};\n    ParseTail(temp, scope, model);\n    if (typeof container === 'string') {\n        container = document.querySelector(container);\n    }\n    if (container) {\n        const nodes = [].map.call(temp.childNodes, child => child);\n        for (const child of nodes) {\n            container.appendChild(child);\n        }\n    }\n    return model;\n};\nconst composite = (strings, ...args) => {\n    const output = [];\n    for (let i = 0; i < strings.length; i++) {\n        output.push(strings[i]);\n        if (args[i]) {\n            output.push(args[i].toString());\n        }\n    }\n    return output.join('');\n};\nconst tmpl = (strings, ...args) => {\n    return ParseTemplate(composite(strings, ...args));\n};\nconst css = composite;\n\n\n//# sourceURL=webpack://treb/./treb-utils/src/template.ts?");

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"__extends\": () => (/* binding */ __extends),\n/* harmony export */   \"__assign\": () => (/* binding */ __assign),\n/* harmony export */   \"__rest\": () => (/* binding */ __rest),\n/* harmony export */   \"__decorate\": () => (/* binding */ __decorate),\n/* harmony export */   \"__param\": () => (/* binding */ __param),\n/* harmony export */   \"__metadata\": () => (/* binding */ __metadata),\n/* harmony export */   \"__awaiter\": () => (/* binding */ __awaiter),\n/* harmony export */   \"__generator\": () => (/* binding */ __generator),\n/* harmony export */   \"__createBinding\": () => (/* binding */ __createBinding),\n/* harmony export */   \"__exportStar\": () => (/* binding */ __exportStar),\n/* harmony export */   \"__values\": () => (/* binding */ __values),\n/* harmony export */   \"__read\": () => (/* binding */ __read),\n/* harmony export */   \"__spread\": () => (/* binding */ __spread),\n/* harmony export */   \"__spreadArrays\": () => (/* binding */ __spreadArrays),\n/* harmony export */   \"__spreadArray\": () => (/* binding */ __spreadArray),\n/* harmony export */   \"__await\": () => (/* binding */ __await),\n/* harmony export */   \"__asyncGenerator\": () => (/* binding */ __asyncGenerator),\n/* harmony export */   \"__asyncDelegator\": () => (/* binding */ __asyncDelegator),\n/* harmony export */   \"__asyncValues\": () => (/* binding */ __asyncValues),\n/* harmony export */   \"__makeTemplateObject\": () => (/* binding */ __makeTemplateObject),\n/* harmony export */   \"__importStar\": () => (/* binding */ __importStar),\n/* harmony export */   \"__importDefault\": () => (/* binding */ __importDefault),\n/* harmony export */   \"__classPrivateFieldGet\": () => (/* binding */ __classPrivateFieldGet),\n/* harmony export */   \"__classPrivateFieldSet\": () => (/* binding */ __classPrivateFieldSet)\n/* harmony export */ });\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\n\n//# sourceURL=webpack://treb/./node_modules/tslib/tslib.es6.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./treb-mc/src/calculation-worker/index-modern.ts");
/******/ 	
/******/ })()
;